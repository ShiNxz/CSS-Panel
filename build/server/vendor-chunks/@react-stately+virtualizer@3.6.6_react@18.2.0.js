"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-stately+virtualizer@3.6.6_react@18.2.0";
exports.ids = ["vendor-chunks/@react-stately+virtualizer@3.6.6_react@18.2.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@react-stately+virtualizer@3.6.6_react@18.2.0/node_modules/@react-stately/virtualizer/dist/import.mjs":
/*!**********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@react-stately+virtualizer@3.6.6_react@18.2.0/node_modules/@react-stately/virtualizer/dist/import.mjs ***!
  \**********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Layout: () => (/* binding */ $c74cda7d31af1253$export$c84671f46d6a1ca),\n/* harmony export */   LayoutInfo: () => (/* binding */ $d7fd61009c21d0bb$export$7e0eeb9da702a085),\n/* harmony export */   Point: () => (/* binding */ $3041db3296945e6e$export$baf26146a414f24a),\n/* harmony export */   Rect: () => (/* binding */ $60423f92c7f9ad87$export$c79fc6492f3af13d),\n/* harmony export */   ReusableView: () => (/* binding */ $ad1d98aa8f0c31b4$export$1a5223887c560441),\n/* harmony export */   Size: () => (/* binding */ $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec),\n/* harmony export */   useVirtualizerState: () => (/* binding */ $fc0b13b484ac1194$export$1505db82fe357e65)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/.pnpm/next@14.1.0_react-dom@18.2.0_react@18.2.0_sass@1.70.0/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-aria/utils */ \"(ssr)/./node_modules/.pnpm/@react-aria+utils@3.23.0_react@18.2.0/node_modules/@react-aria/utils/dist/import.mjs\");\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $c74cda7d31af1253$export$c84671f46d6a1ca {\n    /**\n   * Returns whether the layout should invalidate in response to\n   * visible rectangle changes. By default, it only invalidates\n   * when the collection view's size changes. Return true always\n   * to make the layout invalidate while scrolling (e.g. sticky headers).\n   */ shouldInvalidate(newRect, oldRect) {\n        // By default, invalidate when the size changes\n        return newRect.width !== oldRect.width || newRect.height !== oldRect.height;\n    }\n    /**\n   * This method allows the layout to perform any pre-computation\n   * it needs to in order to prepare {@link LayoutInfo}s for retrieval.\n   * Called by the collection view before {@link getVisibleLayoutInfos}\n   * or {@link getLayoutInfo} are called.\n   */ validate(invalidationContext) {}\n    /**\n   * Returns a {@link DragTarget} describing a view at the given point to be dragged.\n   * Return `null` to cancel the drag. The default implementation returns the view at the given point.\n   * @param point The point at which the drag occurred.\n   */ // getDragTarget(point: Point): DragTarget | null {\n    //   let target = this.virtualizer.keyAtPoint(point);\n    //   if (!target) {\n    //     return null;\n    //   }\n    //   return {\n    //     type: 'item',\n    //     key: target\n    //   };\n    // }\n    /**\n   * Returns a {@link DragTarget} object describing where a drop should occur. Return `null`\n   * to reject the drop. The dropped items will be inserted before the resulting target.\n   * @param point The point at which the drop occurred.\n   */ // getDropTarget(point: Point): DropTarget | null {\n    //   return null;\n    // }\n    /**\n   * Returns the starting attributes for an animated insertion.\n   * The view is animated from this {@link LayoutInfo} to the one returned by {@link getLayoutInfo}.\n   * The default implementation just returns its input.\n   *\n   * @param layoutInfo The proposed LayoutInfo for this view.\n   */ getInitialLayoutInfo(layoutInfo) {\n        return layoutInfo;\n    }\n    /**\n   * Returns the ending attributes for an animated removal.\n   * The view is animated from the {@link LayoutInfo} returned by {@link getLayoutInfo}\n   * to the one returned by this method. The default implementation returns its input.\n   *\n   * @param layoutInfo The original LayoutInfo for this view.\n   */ getFinalLayoutInfo(layoutInfo) {\n        return layoutInfo;\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $d7fd61009c21d0bb$export$7e0eeb9da702a085 {\n    /**\n   * Returns a copy of the LayoutInfo.\n   */ copy() {\n        let res = new $d7fd61009c21d0bb$export$7e0eeb9da702a085(this.type, this.key, this.rect.copy());\n        res.estimatedSize = this.estimatedSize;\n        res.opacity = this.opacity;\n        res.transform = this.transform;\n        res.parentKey = this.parentKey;\n        res.isSticky = this.isSticky;\n        res.zIndex = this.zIndex;\n        res.allowOverflow = this.allowOverflow;\n        return res;\n    }\n    /**\n   * @param type A string representing the view type. Should be `'item'` for item views.\n                            Other types are used by supplementary views.\n   * @param key The unique key for this view.\n   * @param rect The rectangle describing the size and position of this view.\n   */ constructor(type, key, rect){\n        this.type = type;\n        this.key = key;\n        this.parentKey = null;\n        this.rect = rect;\n        this.estimatedSize = false;\n        this.isSticky = false;\n        this.opacity = 1;\n        this.transform = null;\n        this.zIndex = 0;\n        this.allowOverflow = false;\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $3041db3296945e6e$export$baf26146a414f24a {\n    /**\n   * Returns a copy of this point.\n   */ copy() {\n        return new $3041db3296945e6e$export$baf26146a414f24a(this.x, this.y);\n    }\n    /**\n   * Checks if two points are equal.\n   */ equals(point) {\n        return this.x === point.x && this.y === point.y;\n    }\n    /**\n   * Returns true if this point is the origin.\n   */ isOrigin() {\n        return this.x === 0 && this.y === 0;\n    }\n    constructor(x = 0, y = 0){\n        this.x = x;\n        this.y = y;\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $60423f92c7f9ad87$export$c79fc6492f3af13d {\n    /**\n   * The maximum x-coordinate in the rectangle.\n   */ get maxX() {\n        return this.x + this.width;\n    }\n    /**\n   * The maximum y-coordinate in the rectangle.\n   */ get maxY() {\n        return this.y + this.height;\n    }\n    /**\n   * The area of the rectangle.\n   */ get area() {\n        return this.width * this.height;\n    }\n    /**\n   * The top left corner of the rectangle.\n   */ get topLeft() {\n        return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.x, this.y);\n    }\n    /**\n   * The top right corner of the rectangle.\n   */ get topRight() {\n        return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.maxX, this.y);\n    }\n    /**\n   * The bottom left corner of the rectangle.\n   */ get bottomLeft() {\n        return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.x, this.maxY);\n    }\n    /**\n   * The bottom right corner of the rectangle.\n   */ get bottomRight() {\n        return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.maxX, this.maxY);\n    }\n    /**\n   * Returns whether this rectangle intersects another rectangle.\n   * @param rect - The rectangle to check.\n   */ intersects(rect) {\n        return this.x <= rect.x + rect.width && rect.x <= this.x + this.width && this.y <= rect.y + rect.height && rect.y <= this.y + this.height;\n    }\n    /**\n   * Returns whether this rectangle fully contains another rectangle.\n   * @param rect - The rectangle to check.\n   */ containsRect(rect) {\n        return this.x <= rect.x && this.y <= rect.y && this.maxX >= rect.maxX && this.maxY >= rect.maxY;\n    }\n    /**\n   * Returns whether the rectangle contains the given point.\n   * @param point - The point to check.\n   */ containsPoint(point) {\n        return this.x <= point.x && this.y <= point.y && this.maxX >= point.x && this.maxY >= point.y;\n    }\n    /**\n   * Returns the first corner of this rectangle (from top to bottom, left to right)\n   * that is contained in the given rectangle, or null of the rectangles do not intersect.\n   * @param rect - The rectangle to check.\n   */ getCornerInRect(rect) {\n        for (let key of [\n            \"topLeft\",\n            \"topRight\",\n            \"bottomLeft\",\n            \"bottomRight\"\n        ]){\n            if (rect.containsPoint(this[key])) return key;\n        }\n        return null;\n    }\n    equals(rect) {\n        return rect.x === this.x && rect.y === this.y && rect.width === this.width && rect.height === this.height;\n    }\n    pointEquals(point) {\n        return this.x === point.x && this.y === point.y;\n    }\n    sizeEquals(size) {\n        return this.width === size.width && this.height === size.height;\n    }\n    /**\n   * Returns the union of this Rect and another.\n   */ union(other) {\n        let x = Math.min(this.x, other.x);\n        let y = Math.min(this.y, other.y);\n        let width = Math.max(this.maxX, other.maxX) - x;\n        let height = Math.max(this.maxY, other.maxY) - y;\n        return new $60423f92c7f9ad87$export$c79fc6492f3af13d(x, y, width, height);\n    }\n    /**\n   * Returns the intersection of this Rect with another.\n   * If the rectangles do not intersect, an all zero Rect is returned.\n   */ intersection(other) {\n        if (!this.intersects(other)) return new $60423f92c7f9ad87$export$c79fc6492f3af13d(0, 0, 0, 0);\n        let x = Math.max(this.x, other.x);\n        let y = Math.max(this.y, other.y);\n        return new $60423f92c7f9ad87$export$c79fc6492f3af13d(x, y, Math.min(this.maxX, other.maxX) - x, Math.min(this.maxY, other.maxY) - y);\n    }\n    /**\n   * Returns a copy of this rectangle.\n   */ copy() {\n        return new $60423f92c7f9ad87$export$c79fc6492f3af13d(this.x, this.y, this.width, this.height);\n    }\n    constructor(x = 0, y = 0, width = 0, height = 0){\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec {\n    /**\n   * Returns a copy of this size.\n   */ copy() {\n        return new $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec(this.width, this.height);\n    }\n    /**\n   * Returns whether this size is equal to another one.\n   */ equals(other) {\n        return this.width === other.width && this.height === other.height;\n    }\n    /**\n   * The total area of the Size.\n   */ get area() {\n        return this.width * this.height;\n    }\n    constructor(width = 0, height = 0){\n        this.width = width;\n        this.height = height;\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ let $ad1d98aa8f0c31b4$var$KEY = 0;\nclass $ad1d98aa8f0c31b4$export$1a5223887c560441 {\n    /**\n   * Prepares the view for reuse. Called just before the view is removed from the DOM.\n   */ prepareForReuse() {\n        this.content = null;\n        this.rendered = null;\n        this.layoutInfo = null;\n    }\n    constructor(virtualizer){\n        this.virtualizer = virtualizer;\n        this.key = ++$ad1d98aa8f0c31b4$var$KEY;\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // use high res timer if available\nlet $3eb131dcf37ad5f8$var$perf =  false ? 0 : null;\n// @ts-ignore\nlet $3eb131dcf37ad5f8$var$perfNow = $3eb131dcf37ad5f8$var$perf && ($3eb131dcf37ad5f8$var$perf.now || $3eb131dcf37ad5f8$var$perf.webkitNow || $3eb131dcf37ad5f8$var$perf.msNow || $3eb131dcf37ad5f8$var$perf.mozNow);\nlet $3eb131dcf37ad5f8$var$getTime = $3eb131dcf37ad5f8$var$perfNow ? $3eb131dcf37ad5f8$var$perfNow.bind($3eb131dcf37ad5f8$var$perf) : function() {\n    return Date.now ? Date.now() : new Date().getTime();\n};\nlet $3eb131dcf37ad5f8$var$fixTs;\nfunction $3eb131dcf37ad5f8$export$dc0b63720788090c(begin, end, duration, ease, fn) {\n    let canceled = false;\n    let raf_id;\n    let promise = new Promise((resolve)=>{\n        let start = $3eb131dcf37ad5f8$var$getTime();\n        let diffX = end.x - begin.x;\n        let diffY = end.y - begin.y;\n        raf_id = requestAnimationFrame(function run(t) {\n            // if we're using a high res timer, make sure timestamp is not the old epoch-based value.\n            // http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision\n            if ($3eb131dcf37ad5f8$var$fixTs == null) $3eb131dcf37ad5f8$var$fixTs = t > 1e12 !== $3eb131dcf37ad5f8$var$getTime() > 1e12;\n            if ($3eb131dcf37ad5f8$var$fixTs) t = $3eb131dcf37ad5f8$var$getTime();\n            // check if we're done\n            let delta = t - start;\n            if (delta > duration) {\n                fn(end);\n                resolve();\n            } else {\n                // call frame callback after computing eased time and get the next frame\n                let proceed = fn(new (0, $3041db3296945e6e$export$baf26146a414f24a)(begin.x + diffX * ease(delta / duration), begin.y + diffY * ease(delta / duration)));\n                if (proceed !== false && !canceled) raf_id = requestAnimationFrame(run);\n            }\n        });\n    });\n    promise.cancel = function() {\n        canceled = true;\n        cancelAnimationFrame(raf_id);\n    };\n    return promise;\n}\nfunction $3eb131dcf37ad5f8$export$77860c106b4a6a2e(t) {\n    return t;\n}\nfunction $3eb131dcf37ad5f8$export$57636bb43b1ccbb0(t) {\n    return Math.sin(t * Math.PI / 2);\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $fc36f9a046a9ce79$export$37a26b283fd7740e(a, b) {\n    let res = new Set();\n    for (let key of a.keys())if (!b.has(key)) res.add(key);\n    return res;\n}\nfunction $fc36f9a046a9ce79$export$acaf96a27438246b(a, b) {\n    let toRemove = $fc36f9a046a9ce79$export$37a26b283fd7740e(a, b);\n    let toAdd = $fc36f9a046a9ce79$export$37a26b283fd7740e(b, a);\n    let toUpdate = new Set;\n    for (let key of a.keys())if (b.has(key)) toUpdate.add(key);\n    return {\n        toRemove: toRemove,\n        toAdd: toAdd,\n        toUpdate: toUpdate\n    };\n}\nfunction* $fc36f9a046a9ce79$export$cfc14088dfefce5f(...iterators) {\n    for (let iterator of iterators)yield* iterator;\n}\nfunction $fc36f9a046a9ce79$export$6897c284b6f9f4dc(object) {\n    let res = {};\n    for(let key in object)res[object[key]] = key;\n    return res;\n}\nfunction $fc36f9a046a9ce79$export$a8d0d0c8d1c5df64(a, b) {\n    if (a === b) return true;\n    if (a.size !== b.size) return false;\n    for (let key of a){\n        if (!b.has(key)) return false;\n    }\n    return true;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $364191b3decf3697$var$RollingAverage {\n    addSample(sample) {\n        this.count++;\n        this.value += (sample - this.value) / this.count;\n    }\n    constructor(){\n        this.count = 0;\n        this.value = 0;\n    }\n}\nclass $364191b3decf3697$export$4455ee6afb38dcbb {\n    setVisibleRect(rect) {\n        let time = performance.now() - this.startTime;\n        if (time < 500) {\n            this.averageTime.addSample(time);\n            if (rect.x !== this.visibleRect.x && time > 0) this.velocity.x = (rect.x - this.visibleRect.x) / time;\n            if (rect.y !== this.visibleRect.y && time > 0) this.velocity.y = (rect.y - this.visibleRect.y) / time;\n        }\n        this.startTime = performance.now();\n        this.visibleRect = rect;\n    }\n    collectMetrics() {\n        let time = performance.now() - this.startTime;\n        if (time < 500) this.averagePerf.addSample(time);\n        if (this.visibleRect.height > 0) {\n            let o = Math.abs(this.velocity.y * (this.averageTime.value + this.averagePerf.value));\n            this.overscanY.addSample(o);\n        }\n        if (this.visibleRect.width > 0) {\n            let o = Math.abs(this.velocity.x * (this.averageTime.value + this.averagePerf.value));\n            this.overscanX.addSample(o);\n        }\n    }\n    getOverscannedRect() {\n        let overscanned = this.visibleRect.copy();\n        let overscanY = Math.round(Math.min(this.visibleRect.height * 2, this.overscanY.value) / 100) * 100;\n        if (this.velocity.y > 0) {\n            overscanned.y -= overscanY * 0.2;\n            overscanned.height += overscanY + overscanY * 0.2;\n        } else {\n            overscanned.y -= overscanY;\n            overscanned.height += overscanY + overscanY * 0.2;\n        }\n        let overscanX = Math.round(Math.min(this.visibleRect.width * 2, this.overscanX.value) / 100) * 100;\n        if (this.velocity.x > 0) {\n            overscanned.x -= overscanX * 0.2;\n            overscanned.width += overscanX + overscanX * 0.2;\n        } else {\n            overscanned.x -= overscanX;\n            overscanned.width += overscanX + overscanX * 0.2;\n        }\n        return overscanned;\n    }\n    constructor(){\n        this.startTime = 0;\n        this.averagePerf = new $364191b3decf3697$var$RollingAverage();\n        this.averageTime = new $364191b3decf3697$var$RollingAverage();\n        this.velocity = new (0, $3041db3296945e6e$export$baf26146a414f24a)(5, 5);\n        this.overscanX = new $364191b3decf3697$var$RollingAverage();\n        this.overscanY = new $364191b3decf3697$var$RollingAverage();\n        this.visibleRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)();\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $8e135e531d8dcb66$export$febc5573c75cefb0 {\n    constructor(){\n        this.level = 0;\n        this.actions = [];\n        this.animated = true;\n        this.initialMap = new Map();\n        this.finalMap = new Map();\n        this.initialLayoutInfo = new Map();\n        this.finalLayoutInfo = new Map();\n        this.removed = new Map();\n        this.toRemove = new Map();\n    }\n}\nclass $38b9490c1cca8fc4$export$89be5a243e59c4b2 {\n    _setContentSize(size) {\n        this._contentSize = size;\n        this.delegate.setContentSize(size);\n    }\n    _setContentOffset(offset) {\n        let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(offset.x, offset.y, this._visibleRect.width, this._visibleRect.height);\n        this.delegate.setVisibleRect(rect);\n    }\n    /**\n   * Get the size of the scrollable content.\n   */ get contentSize() {\n        return this._contentSize;\n    }\n    /**\n   * Get the collection view's currently visible rectangle.\n   */ get visibleRect() {\n        return this._visibleRect;\n    }\n    /**\n   * Set the collection view's currently visible rectangle.\n   */ set visibleRect(rect) {\n        this._setVisibleRect(rect);\n    }\n    _setVisibleRect(rect, forceUpdate = false) {\n        let current = this._visibleRect;\n        // Ignore if the rects are equal\n        if (rect.equals(current)) return;\n        if (this.shouldOverscan) this._overscanManager.setVisibleRect(rect);\n        let shouldInvalidate = this.layout && this.layout.shouldInvalidate(rect, this._visibleRect);\n        this._resetAnimatedContentOffset();\n        this._visibleRect = rect;\n        if (shouldInvalidate) this.relayoutNow({\n            offsetChanged: !rect.pointEquals(current),\n            sizeChanged: !rect.sizeEquals(current)\n        });\n        else this.updateSubviews(forceUpdate);\n    }\n    get collection() {\n        return this._collection;\n    }\n    set collection(data) {\n        this._setData(data);\n    }\n    _setData(data) {\n        if (data === this._collection) return;\n        if (this._collection) this._runTransaction(()=>{\n            this._collection = data;\n        }, this.transitionDuration > 0);\n        else {\n            this._collection = data;\n            this.reloadData();\n        }\n    }\n    /**\n   * Reloads the data from the data source and relayouts the collection view.\n   * Does not animate any changes. Equivalent to re-assigning the same data source\n   * to the collection view.\n   */ reloadData() {\n        this.relayout({\n            contentChanged: true\n        });\n    }\n    /**\n   * Returns the item with the given key.\n   */ getItem(key) {\n        return this._collection ? this._collection.getItem(key) : null;\n    }\n    /** The set of persisted keys are always present in the DOM, even if not currently in view. */ get persistedKeys() {\n        return this._persistedKeys;\n    }\n    /** The set of persisted keys are always present in the DOM, even if not currently in view. */ set persistedKeys(persistedKeys) {\n        if (!(0, $fc36f9a046a9ce79$export$a8d0d0c8d1c5df64)(persistedKeys, this._persistedKeys)) {\n            this._persistedKeys = persistedKeys;\n            this.updateSubviews();\n        }\n    }\n    /** Returns whether the given key, or an ancestor, is persisted. */ isPersistedKey(key) {\n        // Quick check if the key is directly in the set of persisted keys.\n        if (this._persistedKeys.has(key)) return true;\n        // If not, check if the key is an ancestor of any of the persisted keys.\n        for (let k of this._persistedKeys)while(k != null){\n            let layoutInfo = this.layout.getLayoutInfo(k);\n            if (!layoutInfo) break;\n            k = layoutInfo.parentKey;\n            if (k === key) return true;\n        }\n        return false;\n    }\n    /**\n   * Get the collection view's layout.\n   */ get layout() {\n        return this._layout;\n    }\n    /**\n   * Set the collection view's layout.\n   */ set layout(layout) {\n        this.setLayout(layout);\n    }\n    /**\n   * Sets the collection view's layout, optionally with an animated transition\n   * from the current layout to the new layout.\n   * @param layout The layout to switch to.\n   * @param animated Whether to animate the layout change.\n   */ setLayout(layout, animated = false) {\n        if (layout === this._layout) return;\n        let applyLayout = ()=>{\n            if (this._layout) this._layout.virtualizer = null;\n            layout.virtualizer = this;\n            this._layout = layout;\n        };\n        if (animated) // We just set the layout inside a transaction action, which runs after the initial\n        // layout infos for the animation are retrieved from the previous layout. Then, the\n        // final layout infos are retrieved from the new layout, and animations occur.\n        this._runTransaction(applyLayout);\n        else {\n            applyLayout();\n            this.relayout();\n        }\n    }\n    _getReuseType(layoutInfo, content) {\n        if (layoutInfo.type === \"item\" && content) {\n            let type = this.delegate.getType ? this.delegate.getType(content) : \"item\";\n            let reuseType = type === \"item\" ? \"item\" : layoutInfo.type + \"_\" + type;\n            return {\n                type: type,\n                reuseType: reuseType\n            };\n        }\n        return {\n            type: layoutInfo.type,\n            reuseType: layoutInfo.type\n        };\n    }\n    getReusableView(layoutInfo) {\n        let content = this.getItem(layoutInfo.key);\n        let { reuseType: reuseType } = this._getReuseType(layoutInfo, content);\n        if (!this._reusableViews[reuseType]) this._reusableViews[reuseType] = [];\n        let reusable = this._reusableViews[reuseType];\n        let view = reusable.length > 0 ? reusable.pop() : new (0, $ad1d98aa8f0c31b4$export$1a5223887c560441)(this);\n        view.viewType = reuseType;\n        if (!this._animatedContentOffset.isOrigin()) {\n            layoutInfo = layoutInfo.copy();\n            layoutInfo.rect.x += this._animatedContentOffset.x;\n            layoutInfo.rect.y += this._animatedContentOffset.y;\n        }\n        view.layoutInfo = layoutInfo;\n        this._renderView(view);\n        return view;\n    }\n    _renderView(reusableView) {\n        let { type: type, key: key } = reusableView.layoutInfo;\n        reusableView.content = this.getItem(key);\n        reusableView.rendered = this._renderContent(type, reusableView.content);\n    }\n    _renderContent(type, content) {\n        let cached = this._renderedContent.get(content);\n        if (cached != null) return cached;\n        let rendered = this.delegate.renderView(type, content);\n        if (content) this._renderedContent.set(content, rendered);\n        return rendered;\n    }\n    /**\n   * Returns an array of all currently visible views, including both\n   * item views and supplementary views.\n   */ get visibleViews() {\n        return Array.from(this._visibleViews.values());\n    }\n    /**\n   * Gets the visible view for the given type and key. Returns null if\n   * the view is not currently visible.\n   *\n   * @param key The key of the view to retrieve.\n   */ getView(key) {\n        return this._visibleViews.get(key) || null;\n    }\n    /**\n   * Returns an array of visible views matching the given type.\n   * @param type The view type to find.\n   */ getViewsOfType(type) {\n        return this.visibleViews.filter((v)=>v.layoutInfo && v.layoutInfo.type === type);\n    }\n    /**\n   * Returns the key for the given view. Returns null\n   * if the view is not currently visible.\n   */ keyForView(view) {\n        if (view && view.layoutInfo) return view.layoutInfo.key;\n        return null;\n    }\n    /**\n   * Returns the key for the item view currently at the given point.\n   */ keyAtPoint(point) {\n        let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(point.x, point.y, 1, 1);\n        let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n        // Layout may return multiple layout infos in the case of\n        // persisted keys, so find the first one that actually intersects.\n        for (let layoutInfo of layoutInfos){\n            if (layoutInfo.rect.intersects(rect)) return layoutInfo.key;\n        }\n        return null;\n    }\n    /**\n   * Cleanup for when the Virtualizer will be unmounted.\n   */ willUnmount() {\n        cancelAnimationFrame(this._relayoutRaf);\n    }\n    /**\n   * Triggers a layout invalidation, and updates the visible subviews.\n   */ relayout(context = {}) {\n        // Ignore relayouts while animating the scroll position\n        if (this._scrollAnimation || typeof requestAnimationFrame === \"undefined\") return;\n        // If we already scheduled a relayout, extend the invalidation\n        // context so we coalesce multiple relayouts in the same frame.\n        if (this._invalidationContext) {\n            Object.assign(this._invalidationContext, context);\n            return;\n        }\n        this._invalidationContext = context;\n    }\n    /**\n   * Performs a relayout immediately. Prefer {@link relayout} over this method\n   * where possible, since it coalesces multiple layout passes in the same tick.\n   */ relayoutNow(context = this._invalidationContext || {}) {\n        // Cancel the scheduled relayout, since we're doing it now.\n        if (this._relayoutRaf) {\n            cancelAnimationFrame(this._relayoutRaf);\n            this._relayoutRaf = null;\n            // Update the provided context with the current invalidationContext since we are cancelling\n            // a scheduled relayoutNow call that has this._invalidationContext set as its default context arg (relayoutNow() in relayout)\n            context = {\n                ...this._invalidationContext,\n                ...context\n            };\n        }\n        // Reset the invalidation context\n        this._invalidationContext = null;\n        // Do nothing if we don't have a layout or content, or we are\n        // in the middle of an animated scroll transition.\n        if (!this.layout || !this._collection || this._scrollAnimation) return;\n        let scrollAnchor = this._getScrollAnchor();\n        // Trigger the beforeLayout hook, if provided\n        if (typeof context.beforeLayout === \"function\") context.beforeLayout();\n        // Validate the layout\n        this.layout.validate(context);\n        this._setContentSize(this.layout.getContentSize());\n        // Trigger the afterLayout hook, if provided\n        if (typeof context.afterLayout === \"function\") context.afterLayout();\n        // Adjust scroll position based on scroll anchor, and constrain.\n        // If the content changed, scroll to the top.\n        let visibleRect = this.getVisibleRect();\n        let restoredScrollAnchor = this._restoreScrollAnchor(scrollAnchor, context);\n        let contentOffsetX = context.contentChanged ? 0 : restoredScrollAnchor.x;\n        let contentOffsetY = context.contentChanged ? 0 : restoredScrollAnchor.y;\n        contentOffsetX = Math.max(0, Math.min(this.contentSize.width - visibleRect.width, contentOffsetX));\n        contentOffsetY = Math.max(0, Math.min(this.contentSize.height - visibleRect.height, contentOffsetY));\n        let hasLayoutUpdates = false;\n        if (contentOffsetX !== visibleRect.x || contentOffsetY !== visibleRect.y) {\n            // If this is an animated relayout, we do not immediately scroll because it would be jittery.\n            // Save the difference between the current and new content offsets, and apply it to the\n            // individual content items instead. At the end of the animation, we'll reset and set the\n            // scroll offset for real. This ensures jitter-free animation since we don't need to sync\n            // the scroll animation and the content animation.\n            if (context.animated || !this._animatedContentOffset.isOrigin()) {\n                this._animatedContentOffset.x += visibleRect.x - contentOffsetX;\n                this._animatedContentOffset.y += visibleRect.y - contentOffsetY;\n                hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n            } else this._setContentOffset(new (0, $3041db3296945e6e$export$baf26146a414f24a)(contentOffsetX, contentOffsetY));\n        } else hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n        // Apply layout infos, unless this is coming from an animated transaction\n        if (!(context.transaction && context.animated)) this._applyLayoutInfos();\n        // Wait for animations, and apply the afterAnimation hook, if provided\n        if (context.animated && hasLayoutUpdates) {\n            this._enableTransitions();\n            let done = ()=>{\n                this._disableTransitions();\n                // Reset scroll position after animations (see above comment).\n                if (!this._animatedContentOffset.isOrigin()) {\n                    // Get the content offset to scroll to, taking _animatedContentOffset into account.\n                    let { x: x, y: y } = this.getVisibleRect();\n                    this._resetAnimatedContentOffset();\n                    this._setContentOffset(new (0, $3041db3296945e6e$export$baf26146a414f24a)(x, y));\n                }\n                if (typeof context.afterAnimation === \"function\") context.afterAnimation();\n            };\n            // Sometimes the animation takes slightly longer than expected.\n            setTimeout(done, this.transitionDuration + 100);\n            return;\n        } else if (typeof context.afterAnimation === \"function\") context.afterAnimation();\n    }\n    /**\n   * Corrects DOM order of visible views to match item order of collection.\n   */ _correctItemOrder() {\n        // Defer until after scrolling and animated transactions are complete\n        if (this._isScrolling || this._transaction) return;\n        for (let key of this._visibleLayoutInfos.keys()){\n            let view = this._visibleViews.get(key);\n            this._children.delete(view);\n            this._children.add(view);\n        }\n    }\n    _enableTransitions() {\n        this.delegate.beginAnimations();\n    }\n    _disableTransitions() {\n        this.delegate.endAnimations();\n    }\n    _getScrollAnchor() {\n        if (!this.anchorScrollPosition) return null;\n        let visibleRect = this.getVisibleRect();\n        // Ask the delegate to provide a scroll anchor, if possible\n        if (this.delegate.getScrollAnchor) {\n            let key = this.delegate.getScrollAnchor(visibleRect);\n            if (key != null) {\n                let layoutInfo = this.layout.getLayoutInfo(key);\n                let corner = layoutInfo.rect.getCornerInRect(visibleRect);\n                if (corner) {\n                    let key = layoutInfo.key;\n                    let offset = layoutInfo.rect[corner].y - visibleRect.y;\n                    return {\n                        key: key,\n                        layoutInfo: layoutInfo,\n                        corner: corner,\n                        offset: offset\n                    };\n                }\n            }\n        }\n        // No need to anchor the scroll position if it is at the top\n        if (visibleRect.y === 0 && !this.anchorScrollPositionAtTop) return null;\n        // Find a view with a visible corner that has the smallest distance to the top of the collection view\n        let cornerAnchor = null;\n        for (let [key, view] of this._visibleViews){\n            let layoutInfo = view.layoutInfo;\n            if (layoutInfo && layoutInfo.rect.area > 0) {\n                let corner = layoutInfo.rect.getCornerInRect(visibleRect);\n                if (corner) {\n                    let offset = layoutInfo.rect[corner].y - visibleRect.y;\n                    if (!cornerAnchor || offset < cornerAnchor.offset) cornerAnchor = {\n                        key: key,\n                        layoutInfo: layoutInfo,\n                        corner: corner,\n                        offset: offset\n                    };\n                }\n            }\n        }\n        return cornerAnchor;\n    }\n    _restoreScrollAnchor(scrollAnchor, context) {\n        let contentOffset = this.getVisibleRect();\n        if (scrollAnchor) {\n            var _context_transaction;\n            let finalAnchor = ((_context_transaction = context.transaction) === null || _context_transaction === void 0 ? void 0 : _context_transaction.animated) ? context.transaction.finalMap.get(scrollAnchor.key) : this.layout.getLayoutInfo(scrollAnchor.layoutInfo.key);\n            if (finalAnchor) {\n                let adjustment = finalAnchor.rect[scrollAnchor.corner].y - contentOffset.y - scrollAnchor.offset;\n                contentOffset.y += adjustment;\n            }\n        }\n        return contentOffset;\n    }\n    getVisibleRect() {\n        let v = this.visibleRect;\n        let x = v.x - this._animatedContentOffset.x;\n        let y = v.y - this._animatedContentOffset.y;\n        return new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(x, y, v.width, v.height);\n    }\n    getVisibleLayoutInfos() {\n        let rect = this.shouldOverscan ? this._overscanManager.getOverscannedRect() : this.getVisibleRect();\n        this._visibleLayoutInfos = this._getLayoutInfoMap(rect);\n        return this._visibleLayoutInfos;\n    }\n    _getLayoutInfoMap(rect, copy = false) {\n        let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n        let map = new Map;\n        for (let layoutInfo of layoutInfos){\n            if (copy) layoutInfo = layoutInfo.copy();\n            map.set(layoutInfo.key, layoutInfo);\n        }\n        return map;\n    }\n    updateSubviews(forceUpdate = false) {\n        if (!this._collection) return;\n        let visibleLayoutInfos = this.getVisibleLayoutInfos();\n        let currentlyVisible = this._visibleViews;\n        let toAdd, toRemove, toUpdate;\n        // If this is a force update, remove and re-add all views.\n        // Otherwise, find and update the diff.\n        if (forceUpdate) {\n            toAdd = visibleLayoutInfos;\n            toRemove = currentlyVisible;\n            toUpdate = new Set();\n        } else {\n            ({ toAdd: toAdd, toRemove: toRemove, toUpdate: toUpdate } = (0, $fc36f9a046a9ce79$export$acaf96a27438246b)(currentlyVisible, visibleLayoutInfos));\n            for (let key of toUpdate){\n                let view = currentlyVisible.get(key);\n                if (!view || !view.layoutInfo) continue;\n                let item = this.getItem(visibleLayoutInfos.get(key).key);\n                if (view.content === item) toUpdate.delete(key);\n                else {\n                    // If the view type changes, delete and recreate the view instead of updating\n                    let { reuseType: reuseType } = this._getReuseType(view.layoutInfo, item);\n                    if (view.viewType !== reuseType) {\n                        toUpdate.delete(key);\n                        toAdd.add(key);\n                        toRemove.add(key);\n                    }\n                }\n            }\n            // We are done if the sets are equal\n            if (toAdd.size === 0 && toRemove.size === 0 && toUpdate.size === 0) {\n                if (this._transaction) this._applyLayoutInfos();\n                return;\n            }\n        }\n        // Track views that should be removed. They are not removed from\n        // the DOM immediately, since we may reuse and need to re-insert\n        // them back into the DOM anyway.\n        let removed = new Set();\n        for (let key of toRemove.keys()){\n            let view = this._visibleViews.get(key);\n            if (view) {\n                removed.add(view);\n                this._visibleViews.delete(key);\n                // If we are in the middle of a transaction, wait until the end\n                // of the animations to remove the views from the DOM. Also means\n                // we can't reuse those views immediately.\n                if (this._transaction) this._transaction.toRemove.set(key, view);\n                else this.reuseView(view);\n            }\n        }\n        for (let key of toAdd.keys()){\n            let layoutInfo = visibleLayoutInfos.get(key);\n            let view;\n            // If we're in a transaction, and a layout change happens\n            // during the animations such that a view that was going\n            // to be removed is now not, we don't create a new view\n            // since the old one is still in the DOM, marked as toRemove.\n            if (this._transaction) {\n                // if transaction, get initial layout attributes for the animation\n                if (this._transaction.initialLayoutInfo.has(key)) layoutInfo = this._transaction.initialLayoutInfo.get(key);\n                view = this._transaction.toRemove.get(key);\n                if (view) {\n                    this._transaction.toRemove.delete(key);\n                    this._applyLayoutInfo(view, layoutInfo);\n                }\n            }\n            if (!view) {\n                // Create or reuse a view for this row\n                view = this.getReusableView(layoutInfo);\n                // Add the view to the DOM if needed\n                if (!removed.has(view)) this._children.add(view);\n            }\n            this._visibleViews.set(key, view);\n            removed.delete(view);\n        }\n        for (let key of toUpdate){\n            let view = currentlyVisible.get(key);\n            this._renderedContent.delete(key);\n            this._renderView(view);\n        }\n        // Remove the remaining rows to delete from the DOM\n        if (!this._transaction) this.removeViews(removed);\n        this._correctItemOrder();\n        this._flushVisibleViews();\n        let hasLayoutUpdates = this._transaction && (toAdd.size > 0 || toRemove.size > 0 || this._hasLayoutUpdates());\n        if (hasLayoutUpdates) requestAnimationFrame(()=>{\n            // If we're in a transaction, apply animations to visible views\n            // and \"to be removed\" views, which animate off screen.\n            if (this._transaction) requestAnimationFrame(()=>this._applyLayoutInfos());\n        });\n        return hasLayoutUpdates;\n    }\n    afterRender() {\n        if (this._transactionQueue.length > 0) this._processTransactionQueue();\n        else if (this._invalidationContext) this.relayoutNow();\n        if (this.shouldOverscan) this._overscanManager.collectMetrics();\n    }\n    _flushVisibleViews() {\n        // CollectionVirtualizer deals with a flattened set of LayoutInfos, but they can represent heirarchy\n        // by referencing a parentKey. Just before rendering the visible views, we rebuild this heirarchy\n        // by creating a mapping of views by parent key and recursively calling the delegate's renderWrapper\n        // method to build the final tree.\n        let viewsByParentKey = new Map([\n            [\n                null,\n                []\n            ]\n        ]);\n        for (let view of this._children){\n            var _view_layoutInfo, _viewsByParentKey_get, _view_layoutInfo1, _view_layoutInfo2, _view_layoutInfo3;\n            if (((_view_layoutInfo = view.layoutInfo) === null || _view_layoutInfo === void 0 ? void 0 : _view_layoutInfo.parentKey) != null && !viewsByParentKey.has(view.layoutInfo.parentKey)) viewsByParentKey.set(view.layoutInfo.parentKey, []);\n            (_viewsByParentKey_get = viewsByParentKey.get((_view_layoutInfo1 = view.layoutInfo) === null || _view_layoutInfo1 === void 0 ? void 0 : _view_layoutInfo1.parentKey)) === null || _viewsByParentKey_get === void 0 ? void 0 : _viewsByParentKey_get.push(view);\n            if (!viewsByParentKey.has((_view_layoutInfo2 = view.layoutInfo) === null || _view_layoutInfo2 === void 0 ? void 0 : _view_layoutInfo2.key)) viewsByParentKey.set((_view_layoutInfo3 = view.layoutInfo) === null || _view_layoutInfo3 === void 0 ? void 0 : _view_layoutInfo3.key, []);\n        }\n        let buildTree = (parent, views)=>views.map((view)=>{\n                let children = viewsByParentKey.get(view.layoutInfo.key);\n                return this.delegate.renderWrapper(parent, view, children, (childViews)=>buildTree(view, childViews));\n            });\n        let children = buildTree(null, viewsByParentKey.get(null));\n        this.delegate.setVisibleViews(children);\n    }\n    _applyLayoutInfo(view, layoutInfo) {\n        if (view.layoutInfo === layoutInfo) return false;\n        view.layoutInfo = layoutInfo;\n        return true;\n    }\n    _applyLayoutInfos() {\n        let updated = false;\n        // Apply layout infos to visible views\n        for (let view of this._visibleViews.values()){\n            let cur = view.layoutInfo;\n            if ((cur === null || cur === void 0 ? void 0 : cur.key) != null) {\n                let layoutInfo = this.layout.getLayoutInfo(cur.key);\n                if (this._applyLayoutInfo(view, layoutInfo)) updated = true;\n            }\n        }\n        // Apply final layout infos for views that will be removed\n        if (this._transaction) {\n            for (let view of this._transaction.toRemove.values()){\n                let cur = view.layoutInfo;\n                if ((cur === null || cur === void 0 ? void 0 : cur.key) != null) {\n                    let layoutInfo = this.layout.getLayoutInfo(cur.key);\n                    if (this._applyLayoutInfo(view, layoutInfo)) updated = true;\n                }\n            }\n            for (let view of this._transaction.removed.values()){\n                let cur = view.layoutInfo;\n                let layoutInfo = this._transaction.finalLayoutInfo.get(cur.key) || cur;\n                layoutInfo = this.layout.getFinalLayoutInfo(layoutInfo.copy());\n                if (this._applyLayoutInfo(view, layoutInfo)) updated = true;\n            }\n        }\n        if (updated) this._flushVisibleViews();\n    }\n    _hasLayoutUpdates() {\n        if (!this._transaction) return false;\n        for (let view of this._visibleViews.values()){\n            let cur = view.layoutInfo;\n            if (!cur) return true;\n            let layoutInfo = this.layout.getLayoutInfo(cur.key);\n            if (!cur.rect.equals(layoutInfo.rect) || cur.opacity !== layoutInfo.opacity || cur.transform !== layoutInfo.transform) return true;\n        }\n        return false;\n    }\n    reuseView(view) {\n        view.prepareForReuse();\n        this._reusableViews[view.viewType].push(view);\n    }\n    removeViews(toRemove) {\n        for (let view of toRemove)this._children.delete(view);\n    }\n    updateItemSize(key, size) {\n        // TODO: we should be able to invalidate a single index path\n        // @ts-ignore\n        if (!this.layout.updateItemSize) return;\n        // If the scroll position is currently animating, add the update\n        // to a queue to be processed after the animation is complete.\n        if (this._scrollAnimation) {\n            this._sizeUpdateQueue.set(key, size);\n            return;\n        }\n        // @ts-ignore\n        let changed = this.layout.updateItemSize(key, size);\n        if (changed) this.relayout();\n    }\n    startScrolling() {\n        this._isScrolling = true;\n    }\n    endScrolling() {\n        this._isScrolling = false;\n        this._correctItemOrder();\n        this._flushVisibleViews();\n    }\n    _resetAnimatedContentOffset() {\n        // Reset the animated content offset of subviews. See comment in relayoutNow for details.\n        if (!this._animatedContentOffset.isOrigin()) {\n            this._animatedContentOffset = new (0, $3041db3296945e6e$export$baf26146a414f24a)(0, 0);\n            this._applyLayoutInfos();\n        }\n    }\n    /**\n   * Scrolls the item with the given key into view, optionally with an animation.\n   * @param key The key of the item to scroll into view.\n   * @param duration The duration of the scroll animation.\n   */ scrollToItem(key, options) {\n        // key can be 0, so check if null or undefined\n        if (key == null) return;\n        let layoutInfo = this.layout.getLayoutInfo(key);\n        if (!layoutInfo) return;\n        let { duration: duration = 300, shouldScrollX: shouldScrollX = true, shouldScrollY: shouldScrollY = true, offsetX: offsetX = 0, offsetY: offsetY = 0 } = options;\n        let x = this.visibleRect.x;\n        let y = this.visibleRect.y;\n        let minX = layoutInfo.rect.x - offsetX;\n        let minY = layoutInfo.rect.y - offsetY;\n        let maxX = x + this.visibleRect.width;\n        let maxY = y + this.visibleRect.height;\n        if (shouldScrollX) {\n            if (minX <= x || maxX === 0) x = minX;\n            else if (layoutInfo.rect.maxX > maxX) x += layoutInfo.rect.maxX - maxX;\n        }\n        if (shouldScrollY) {\n            if (minY <= y || maxY === 0) y = minY;\n            else if (layoutInfo.rect.maxY > maxY) y += layoutInfo.rect.maxY - maxY;\n        }\n        return this.scrollTo(new (0, $3041db3296945e6e$export$baf26146a414f24a)(x, y), duration);\n    }\n    /**\n   * Performs an animated scroll to the given offset.\n   * @param offset - The offset to scroll to.\n   * @param duration The duration of the animation.\n   * @returns A promise that resolves when the animation is complete.\n   */ scrollTo(offset, duration = 300) {\n        // Cancel the current scroll animation\n        if (this._scrollAnimation) {\n            this._scrollAnimation.cancel();\n            this._scrollAnimation = null;\n        }\n        // Set the content offset synchronously if the duration is zero\n        if (duration <= 0 || this.visibleRect.pointEquals(offset)) {\n            this._setContentOffset(offset);\n            return Promise.resolve();\n        }\n        this.startScrolling();\n        this._scrollAnimation = (0, $3eb131dcf37ad5f8$export$dc0b63720788090c)(this.visibleRect, offset, duration, (0, $3eb131dcf37ad5f8$export$57636bb43b1ccbb0), (offset)=>{\n            this._setContentOffset(offset);\n        });\n        this._scrollAnimation.then(()=>{\n            this._scrollAnimation = null;\n            // Process view size updates that occurred during the animation.\n            // Only views that are still visible will be actually updated.\n            for (let [key, size] of this._sizeUpdateQueue)this.updateItemSize(key, size);\n            this._sizeUpdateQueue.clear();\n            this.relayout();\n            this._processTransactionQueue();\n            this.endScrolling();\n        });\n        return this._scrollAnimation;\n    }\n    _runTransaction(action, animated) {\n        this._startTransaction();\n        if (this._nextTransaction) this._nextTransaction.actions.push(action);\n        this._endTransaction(animated);\n    }\n    _startTransaction() {\n        if (!this._nextTransaction) this._nextTransaction = new (0, $8e135e531d8dcb66$export$febc5573c75cefb0);\n        this._nextTransaction.level++;\n    }\n    _endTransaction(animated) {\n        if (!this._nextTransaction) return false;\n        // Save whether the transaction should be animated.\n        if (animated != null) this._nextTransaction.animated = animated;\n        // If we haven't reached level 0, we are still in a\n        // nested transaction. Wait for the parent to end.\n        if (--this._nextTransaction.level > 0) return false;\n        // Do nothing for empty transactions\n        if (this._nextTransaction.actions.length === 0) {\n            this._nextTransaction = null;\n            return false;\n        }\n        // Default animations to true\n        if (this._nextTransaction.animated == null) this._nextTransaction.animated = true;\n        // Enqueue the transaction\n        this._transactionQueue.push(this._nextTransaction);\n        this._nextTransaction = null;\n        return true;\n    }\n    _processTransactionQueue() {\n        // If the current transaction is animating, wait until the end\n        // to process the next transaction.\n        if (this._transaction || this._scrollAnimation) return;\n        let next = this._transactionQueue.shift();\n        if (next) this._performTransaction(next);\n    }\n    _getContentRect() {\n        return new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, 0, this.contentSize.width, this.contentSize.height);\n    }\n    _performTransaction(transaction) {\n        this._transaction = transaction;\n        this.relayoutNow({\n            transaction: transaction,\n            animated: transaction.animated,\n            beforeLayout: ()=>{\n                // Get the initial layout infos for all views before the updates\n                // so we can figure out which views to add and remove.\n                if (transaction.animated) transaction.initialMap = this._getLayoutInfoMap(this._getContentRect(), true);\n                // Apply the actions that occurred during this transaction\n                for (let action of transaction.actions)action();\n            },\n            afterLayout: ()=>{\n                // Get the final layout infos after the updates\n                if (transaction.animated) {\n                    transaction.finalMap = this._getLayoutInfoMap(this._getContentRect());\n                    this._setupTransactionAnimations(transaction);\n                } else this._transaction = null;\n            },\n            afterAnimation: ()=>{\n                // Remove and reuse views when animations are done\n                if (transaction.toRemove.size > 0 || transaction.removed.size > 0) for (let view of (0, $fc36f9a046a9ce79$export$cfc14088dfefce5f)(transaction.toRemove.values(), transaction.removed.values())){\n                    this._children.delete(view);\n                    this.reuseView(view);\n                }\n                this._transaction = null;\n                // Ensure DOM order is correct for accessibility after animations are complete\n                this._correctItemOrder();\n                this._flushVisibleViews();\n                this._processTransactionQueue();\n            }\n        });\n    }\n    _setupTransactionAnimations(transaction) {\n        let { initialMap: initialMap, finalMap: finalMap } = transaction;\n        // Store initial and final layout infos for animations\n        for (let [key, layoutInfo] of initialMap)if (finalMap.has(key)) transaction.initialLayoutInfo.set(key, layoutInfo);\n        else // in Layout#getFinalLayoutInfo during animations.\n        transaction.finalLayoutInfo.set(layoutInfo.key, layoutInfo);\n        // Get initial layout infos for views that were added\n        for (let [key, layoutInfo] of finalMap)if (!initialMap.has(key)) {\n            let initialLayoutInfo = this.layout.getInitialLayoutInfo(layoutInfo.copy());\n            transaction.initialLayoutInfo.set(key, initialLayoutInfo);\n        }\n        // Figure out which views were removed.\n        for (let [key, view] of this._visibleViews)// Removing an item with  width of 0 can cause a loop where the item gets added, removed,\n        // added, removed... etc in a loop.\n        if (!finalMap.has(key) && view.layoutInfo.rect.width > 0) {\n            transaction.removed.set(key, view);\n            this._visibleViews.delete(key);\n            // In case something weird happened, where we have a view but no\n            // initial layout info, use the one attached to the view.\n            if (view.layoutInfo) {\n                if (!transaction.finalLayoutInfo.has(view.layoutInfo.key)) transaction.finalLayoutInfo.set(view.layoutInfo.key, view.layoutInfo);\n            }\n        }\n    }\n    constructor(options = {}){\n        this._contentSize = new (0, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec);\n        this._visibleRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d);\n        this._reusableViews = {};\n        this._visibleLayoutInfos = new Map();\n        this._visibleViews = new Map();\n        this._renderedContent = new WeakMap();\n        this._children = new Set();\n        this._invalidationContext = null;\n        this._overscanManager = new (0, $364191b3decf3697$export$4455ee6afb38dcbb)();\n        this._persistedKeys = new Set();\n        this._scrollAnimation = null;\n        this._isScrolling = false;\n        this._sizeUpdateQueue = new Map();\n        this._animatedContentOffset = new (0, $3041db3296945e6e$export$baf26146a414f24a)(0, 0);\n        this._transaction = null;\n        this._nextTransaction = null;\n        this._transactionQueue = [];\n        var _options_transitionDuration;\n        // Set options from passed object if given\n        this.transitionDuration = (_options_transitionDuration = options.transitionDuration) !== null && _options_transitionDuration !== void 0 ? _options_transitionDuration : 500;\n        this.anchorScrollPosition = options.anchorScrollPosition || false;\n        this.anchorScrollPositionAtTop = options.anchorScrollPositionAtTop || false;\n        this.shouldOverscan = options.shouldOverscan !== false;\n        for (let key of [\n            \"delegate\",\n            \"size\",\n            \"layout\",\n            \"collection\"\n        ])if (options[key]) this[key] = options[key];\n    }\n}\nfunction $fc0b13b484ac1194$export$1505db82fe357e65(opts) {\n    let [visibleViews, setVisibleViews] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    let [contentSize, setContentSize] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(new (0, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec)());\n    let [isAnimating, setAnimating] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let [isScrolling, setScrolling] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let virtualizer = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, $38b9490c1cca8fc4$export$89be5a243e59c4b2)(), []);\n    virtualizer.delegate = {\n        setVisibleViews: setVisibleViews,\n        setVisibleRect (rect) {\n            virtualizer.visibleRect = rect;\n            opts.onVisibleRectChange(rect);\n        },\n        setContentSize: setContentSize,\n        renderView: opts.renderView,\n        renderWrapper: opts.renderWrapper,\n        beginAnimations: ()=>setAnimating(true),\n        endAnimations: ()=>setAnimating(false),\n        getScrollAnchor: opts.getScrollAnchor\n    };\n    virtualizer.layout = opts.layout;\n    virtualizer.collection = opts.collection;\n    virtualizer.transitionDuration = opts.transitionDuration;\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect)(()=>{\n        virtualizer.afterRender();\n    });\n    // eslint-disable-next-line arrow-body-style\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>virtualizer.willUnmount();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    let setVisibleRect = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((rect)=>{\n        virtualizer.visibleRect = rect;\n    }, [\n        virtualizer\n    ]);\n    let startScrolling = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        virtualizer.startScrolling();\n        setScrolling(true);\n    }, [\n        virtualizer\n    ]);\n    let endScrolling = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        virtualizer.endScrolling();\n        setScrolling(false);\n    }, [\n        virtualizer\n    ]);\n    let state = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            virtualizer: virtualizer,\n            visibleViews: visibleViews,\n            setVisibleRect: setVisibleRect,\n            contentSize: contentSize,\n            isAnimating: isAnimating,\n            isScrolling: isScrolling,\n            startScrolling: startScrolling,\n            endScrolling: endScrolling\n        }), [\n        virtualizer,\n        visibleViews,\n        setVisibleRect,\n        contentSize,\n        isAnimating,\n        isScrolling,\n        startScrolling,\n        endScrolling\n    ]);\n    return state;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHJlYWN0LXN0YXRlbHkrdmlydHVhbGl6ZXJAMy42LjZfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS92aXJ0dWFsaXplci9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQStJO0FBQ25FO0FBRTVFOzs7Ozs7Ozs7O0NBVUMsR0FBRzs7Ozs7Ozs7OztDQVVILEdBQUcsTUFBTVU7SUFDTjs7Ozs7R0FLRCxHQUFHQyxpQkFBaUJDLE9BQU8sRUFBRUMsT0FBTyxFQUFFO1FBQ2pDLCtDQUErQztRQUMvQyxPQUFPRCxRQUFRRSxLQUFLLEtBQUtELFFBQVFDLEtBQUssSUFBSUYsUUFBUUcsTUFBTSxLQUFLRixRQUFRRSxNQUFNO0lBQy9FO0lBQ0E7Ozs7O0dBS0QsR0FBR0MsU0FBU0MsbUJBQW1CLEVBQUUsQ0FBQztJQUNqQzs7OztHQUlELEdBQUcsbURBQW1EO0lBQ3JELHFEQUFxRDtJQUNyRCxtQkFBbUI7SUFDbkIsbUJBQW1CO0lBQ25CLE1BQU07SUFDTixhQUFhO0lBQ2Isb0JBQW9CO0lBQ3BCLGtCQUFrQjtJQUNsQixPQUFPO0lBQ1AsSUFBSTtJQUNKOzs7O0dBSUQsR0FBRyxtREFBbUQ7SUFDckQsaUJBQWlCO0lBQ2pCLElBQUk7SUFDSjs7Ozs7O0dBTUQsR0FBR0MscUJBQXFCQyxVQUFVLEVBQUU7UUFDL0IsT0FBT0E7SUFDWDtJQUNBOzs7Ozs7R0FNRCxHQUFHQyxtQkFBbUJELFVBQVUsRUFBRTtRQUM3QixPQUFPQTtJQUNYO0FBQ0o7QUFHQTs7Ozs7Ozs7OztDQVVDLEdBQUcsTUFBTUU7SUFDTjs7R0FFRCxHQUFHQyxPQUFPO1FBQ0wsSUFBSUMsTUFBTSxJQUFJRiwwQ0FBMEMsSUFBSSxDQUFDRyxJQUFJLEVBQUUsSUFBSSxDQUFDQyxHQUFHLEVBQUUsSUFBSSxDQUFDQyxJQUFJLENBQUNKLElBQUk7UUFDM0ZDLElBQUlJLGFBQWEsR0FBRyxJQUFJLENB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LFdBQVc7SUFDdEMsdURBQXVEO0lBQ3ZELEdBQUcsRUFBRTtJQUNMLElBQUkvRixpQkFBaUIsQ0FBQyxHQUFHM0gsOENBQWlCLEVBQUcsQ0FBQ21CO1FBQzFDMEMsWUFBWWtFLFdBQVcsR0FBRzVHO0lBQzlCLEdBQUc7UUFDQzBDO0tBQ0g7SUFDRCxJQUFJdU8saUJBQWlCLENBQUMsR0FBR3BTLDhDQUFpQixFQUFHO1FBQ3pDNkQsWUFBWXVPLGNBQWM7UUFDMUI2QixhQUFhO0lBQ2pCLEdBQUc7UUFDQ3BRO0tBQ0g7SUFDRCxJQUFJd08sZUFBZSxDQUFDLEdBQUdyUyw4Q0FBaUIsRUFBRztRQUN2QzZELFlBQVl3TyxZQUFZO1FBQ3hCNEIsYUFBYTtJQUNqQixHQUFHO1FBQ0NwUTtLQUNIO0lBQ0QsSUFBSXNRLFFBQVEsQ0FBQyxHQUFHdlUsMENBQWEsRUFBRyxJQUFLO1lBQzdCaUUsYUFBYUE7WUFDYmdKLGNBQWNBO1lBQ2RsRixnQkFBZ0JBO1lBQ2hCaUMsYUFBYUE7WUFDYmtLLGFBQWFBO1lBQ2JFLGFBQWFBO1lBQ2I1QixnQkFBZ0JBO1lBQ2hCQyxjQUFjQTtRQUNsQixJQUFJO1FBQ0p4TztRQUNBZ0o7UUFDQWxGO1FBQ0FpQztRQUNBa0s7UUFDQUU7UUFDQTVCO1FBQ0FDO0tBQ0g7SUFDRCxPQUFPOEI7QUFDWDtBQUs0WSxDQUM1WSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jc3MtcGFuZWwvLi9ub2RlX21vZHVsZXMvLnBucG0vQHJlYWN0LXN0YXRlbHkrdmlydHVhbGl6ZXJAMy42LjZfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS92aXJ0dWFsaXplci9kaXN0L2ltcG9ydC5tanM/ZmFlZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3VzZVN0YXRlIGFzICQ4RDNuciR1c2VTdGF0ZSwgdXNlTWVtbyBhcyAkOEQzbnIkdXNlTWVtbywgdXNlRWZmZWN0IGFzICQ4RDNuciR1c2VFZmZlY3QsIHVzZUNhbGxiYWNrIGFzICQ4RDNuciR1c2VDYWxsYmFja30gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQge3VzZUxheW91dEVmZmVjdCBhcyAkOEQzbnIkdXNlTGF5b3V0RWZmZWN0fSBmcm9tIFwiQHJlYWN0LWFyaWEvdXRpbHNcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBjbGFzcyAkYzc0Y2RhN2QzMWFmMTI1MyRleHBvcnQkYzg0NjcxZjQ2ZDZhMWNhIHtcbiAgICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBsYXlvdXQgc2hvdWxkIGludmFsaWRhdGUgaW4gcmVzcG9uc2UgdG9cbiAgICogdmlzaWJsZSByZWN0YW5nbGUgY2hhbmdlcy4gQnkgZGVmYXVsdCwgaXQgb25seSBpbnZhbGlkYXRlc1xuICAgKiB3aGVuIHRoZSBjb2xsZWN0aW9uIHZpZXcncyBzaXplIGNoYW5nZXMuIFJldHVybiB0cnVlIGFsd2F5c1xuICAgKiB0byBtYWtlIHRoZSBsYXlvdXQgaW52YWxpZGF0ZSB3aGlsZSBzY3JvbGxpbmcgKGUuZy4gc3RpY2t5IGhlYWRlcnMpLlxuICAgKi8gc2hvdWxkSW52YWxpZGF0ZShuZXdSZWN0LCBvbGRSZWN0KSB7XG4gICAgICAgIC8vIEJ5IGRlZmF1bHQsIGludmFsaWRhdGUgd2hlbiB0aGUgc2l6ZSBjaGFuZ2VzXG4gICAgICAgIHJldHVybiBuZXdSZWN0LndpZHRoICE9PSBvbGRSZWN0LndpZHRoIHx8IG5ld1JlY3QuaGVpZ2h0ICE9PSBvbGRSZWN0LmhlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGFsbG93cyB0aGUgbGF5b3V0IHRvIHBlcmZvcm0gYW55IHByZS1jb21wdXRhdGlvblxuICAgKiBpdCBuZWVkcyB0byBpbiBvcmRlciB0byBwcmVwYXJlIHtAbGluayBMYXlvdXRJbmZvfXMgZm9yIHJldHJpZXZhbC5cbiAgICogQ2FsbGVkIGJ5IHRoZSBjb2xsZWN0aW9uIHZpZXcgYmVmb3JlIHtAbGluayBnZXRWaXNpYmxlTGF5b3V0SW5mb3N9XG4gICAqIG9yIHtAbGluayBnZXRMYXlvdXRJbmZvfSBhcmUgY2FsbGVkLlxuICAgKi8gdmFsaWRhdGUoaW52YWxpZGF0aW9uQ29udGV4dCkge31cbiAgICAvKipcbiAgICogUmV0dXJucyBhIHtAbGluayBEcmFnVGFyZ2V0fSBkZXNjcmliaW5nIGEgdmlldyBhdCB0aGUgZ2l2ZW4gcG9pbnQgdG8gYmUgZHJhZ2dlZC5cbiAgICogUmV0dXJuIGBudWxsYCB0byBjYW5jZWwgdGhlIGRyYWcuIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHJldHVybnMgdGhlIHZpZXcgYXQgdGhlIGdpdmVuIHBvaW50LlxuICAgKiBAcGFyYW0gcG9pbnQgVGhlIHBvaW50IGF0IHdoaWNoIHRoZSBkcmFnIG9jY3VycmVkLlxuICAgKi8gLy8gZ2V0RHJhZ1RhcmdldChwb2ludDogUG9pbnQpOiBEcmFnVGFyZ2V0IHwgbnVsbCB7XG4gICAgLy8gICBsZXQgdGFyZ2V0ID0gdGhpcy52aXJ0dWFsaXplci5rZXlBdFBvaW50KHBvaW50KTtcbiAgICAvLyAgIGlmICghdGFyZ2V0KSB7XG4gICAgLy8gICAgIHJldHVybiBudWxsO1xuICAgIC8vICAgfVxuICAgIC8vICAgcmV0dXJuIHtcbiAgICAvLyAgICAgdHlwZTogJ2l0ZW0nLFxuICAgIC8vICAgICBrZXk6IHRhcmdldFxuICAgIC8vICAgfTtcbiAgICAvLyB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgYSB7QGxpbmsgRHJhZ1RhcmdldH0gb2JqZWN0IGRlc2NyaWJpbmcgd2hlcmUgYSBkcm9wIHNob3VsZCBvY2N1ci4gUmV0dXJuIGBudWxsYFxuICAgKiB0byByZWplY3QgdGhlIGRyb3AuIFRoZSBkcm9wcGVkIGl0ZW1zIHdpbGwgYmUgaW5zZXJ0ZWQgYmVmb3JlIHRoZSByZXN1bHRpbmcgdGFyZ2V0LlxuICAgKiBAcGFyYW0gcG9pbnQgVGhlIHBvaW50IGF0IHdoaWNoIHRoZSBkcm9wIG9jY3VycmVkLlxuICAgKi8gLy8gZ2V0RHJvcFRhcmdldChwb2ludDogUG9pbnQpOiBEcm9wVGFyZ2V0IHwgbnVsbCB7XG4gICAgLy8gICByZXR1cm4gbnVsbDtcbiAgICAvLyB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0YXJ0aW5nIGF0dHJpYnV0ZXMgZm9yIGFuIGFuaW1hdGVkIGluc2VydGlvbi5cbiAgICogVGhlIHZpZXcgaXMgYW5pbWF0ZWQgZnJvbSB0aGlzIHtAbGluayBMYXlvdXRJbmZvfSB0byB0aGUgb25lIHJldHVybmVkIGJ5IHtAbGluayBnZXRMYXlvdXRJbmZvfS5cbiAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24ganVzdCByZXR1cm5zIGl0cyBpbnB1dC5cbiAgICpcbiAgICogQHBhcmFtIGxheW91dEluZm8gVGhlIHByb3Bvc2VkIExheW91dEluZm8gZm9yIHRoaXMgdmlldy5cbiAgICovIGdldEluaXRpYWxMYXlvdXRJbmZvKGxheW91dEluZm8pIHtcbiAgICAgICAgcmV0dXJuIGxheW91dEluZm87XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlbmRpbmcgYXR0cmlidXRlcyBmb3IgYW4gYW5pbWF0ZWQgcmVtb3ZhbC5cbiAgICogVGhlIHZpZXcgaXMgYW5pbWF0ZWQgZnJvbSB0aGUge0BsaW5rIExheW91dEluZm99IHJldHVybmVkIGJ5IHtAbGluayBnZXRMYXlvdXRJbmZvfVxuICAgKiB0byB0aGUgb25lIHJldHVybmVkIGJ5IHRoaXMgbWV0aG9kLiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5zIGl0cyBpbnB1dC5cbiAgICpcbiAgICogQHBhcmFtIGxheW91dEluZm8gVGhlIG9yaWdpbmFsIExheW91dEluZm8gZm9yIHRoaXMgdmlldy5cbiAgICovIGdldEZpbmFsTGF5b3V0SW5mbyhsYXlvdXRJbmZvKSB7XG4gICAgICAgIHJldHVybiBsYXlvdXRJbmZvO1xuICAgIH1cbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gY2xhc3MgJGQ3ZmQ2MTAwOWMyMWQwYmIkZXhwb3J0JDdlMGVlYjlkYTcwMmEwODUge1xuICAgIC8qKlxuICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgTGF5b3V0SW5mby5cbiAgICovIGNvcHkoKSB7XG4gICAgICAgIGxldCByZXMgPSBuZXcgJGQ3ZmQ2MTAwOWMyMWQwYmIkZXhwb3J0JDdlMGVlYjlkYTcwMmEwODUodGhpcy50eXBlLCB0aGlzLmtleSwgdGhpcy5yZWN0LmNvcHkoKSk7XG4gICAgICAgIHJlcy5lc3RpbWF0ZWRTaXplID0gdGhpcy5lc3RpbWF0ZWRTaXplO1xuICAgICAgICByZXMub3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcbiAgICAgICAgcmVzLnRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICByZXMucGFyZW50S2V5ID0gdGhpcy5wYXJlbnRLZXk7XG4gICAgICAgIHJlcy5pc1N0aWNreSA9IHRoaXMuaXNTdGlja3k7XG4gICAgICAgIHJlcy56SW5kZXggPSB0aGlzLnpJbmRleDtcbiAgICAgICAgcmVzLmFsbG93T3ZlcmZsb3cgPSB0aGlzLmFsbG93T3ZlcmZsb3c7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIC8qKlxuICAgKiBAcGFyYW0gdHlwZSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZpZXcgdHlwZS4gU2hvdWxkIGJlIGAnaXRlbSdgIGZvciBpdGVtIHZpZXdzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE90aGVyIHR5cGVzIGFyZSB1c2VkIGJ5IHN1cHBsZW1lbnRhcnkgdmlld3MuXG4gICAqIEBwYXJhbSBrZXkgVGhlIHVuaXF1ZSBrZXkgZm9yIHRoaXMgdmlldy5cbiAgICogQHBhcmFtIHJlY3QgVGhlIHJlY3RhbmdsZSBkZXNjcmliaW5nIHRoZSBzaXplIGFuZCBwb3NpdGlvbiBvZiB0aGlzIHZpZXcuXG4gICAqLyBjb25zdHJ1Y3Rvcih0eXBlLCBrZXksIHJlY3Qpe1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5wYXJlbnRLZXkgPSBudWxsO1xuICAgICAgICB0aGlzLnJlY3QgPSByZWN0O1xuICAgICAgICB0aGlzLmVzdGltYXRlZFNpemUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1N0aWNreSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9wYWNpdHkgPSAxO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IG51bGw7XG4gICAgICAgIHRoaXMuekluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5hbGxvd092ZXJmbG93ID0gZmFsc2U7XG4gICAgfVxufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBjbGFzcyAkMzA0MWRiMzI5Njk0NWU2ZSRleHBvcnQkYmFmMjYxNDZhNDE0ZjI0YSB7XG4gICAgLyoqXG4gICAqIFJldHVybnMgYSBjb3B5IG9mIHRoaXMgcG9pbnQuXG4gICAqLyBjb3B5KCkge1xuICAgICAgICByZXR1cm4gbmV3ICQzMDQxZGIzMjk2OTQ1ZTZlJGV4cG9ydCRiYWYyNjE0NmE0MTRmMjRhKHRoaXMueCwgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAqIENoZWNrcyBpZiB0d28gcG9pbnRzIGFyZSBlcXVhbC5cbiAgICovIGVxdWFscyhwb2ludCkge1xuICAgICAgICByZXR1cm4gdGhpcy54ID09PSBwb2ludC54ICYmIHRoaXMueSA9PT0gcG9pbnQueTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHBvaW50IGlzIHRoZSBvcmlnaW4uXG4gICAqLyBpc09yaWdpbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCA9PT0gMCAmJiB0aGlzLnkgPT09IDA7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCl7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgfVxufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmNsYXNzICQ2MDQyM2Y5MmM3ZjlhZDg3JGV4cG9ydCRjNzlmYzY0OTJmM2FmMTNkIHtcbiAgICAvKipcbiAgICogVGhlIG1heGltdW0geC1jb29yZGluYXRlIGluIHRoZSByZWN0YW5nbGUuXG4gICAqLyBnZXQgbWF4WCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCArIHRoaXMud2lkdGg7XG4gICAgfVxuICAgIC8qKlxuICAgKiBUaGUgbWF4aW11bSB5LWNvb3JkaW5hdGUgaW4gdGhlIHJlY3RhbmdsZS5cbiAgICovIGdldCBtYXhZKCkge1xuICAgICAgICByZXR1cm4gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgKiBUaGUgYXJlYSBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKi8gZ2V0IGFyZWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoICogdGhpcy5oZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgKiBUaGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqLyBnZXQgdG9wTGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAoMCwgJDMwNDFkYjMyOTY5NDVlNmUkZXhwb3J0JGJhZjI2MTQ2YTQxNGYyNGEpKHRoaXMueCwgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFRoZSB0b3AgcmlnaHQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqLyBnZXQgdG9wUmlnaHQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgKDAsICQzMDQxZGIzMjk2OTQ1ZTZlJGV4cG9ydCRiYWYyNjE0NmE0MTRmMjRhKSh0aGlzLm1heFgsIHRoaXMueSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBUaGUgYm90dG9tIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqLyBnZXQgYm90dG9tTGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAoMCwgJDMwNDFkYjMyOTY5NDVlNmUkZXhwb3J0JGJhZjI2MTQ2YTQxNGYyNGEpKHRoaXMueCwgdGhpcy5tYXhZKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqLyBnZXQgYm90dG9tUmlnaHQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgKDAsICQzMDQxZGIzMjk2OTQ1ZTZlJGV4cG9ydCRiYWYyNjE0NmE0MTRmMjRhKSh0aGlzLm1heFgsIHRoaXMubWF4WSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyByZWN0YW5nbGUgaW50ZXJzZWN0cyBhbm90aGVyIHJlY3RhbmdsZS5cbiAgICogQHBhcmFtIHJlY3QgLSBUaGUgcmVjdGFuZ2xlIHRvIGNoZWNrLlxuICAgKi8gaW50ZXJzZWN0cyhyZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggPD0gcmVjdC54ICsgcmVjdC53aWR0aCAmJiByZWN0LnggPD0gdGhpcy54ICsgdGhpcy53aWR0aCAmJiB0aGlzLnkgPD0gcmVjdC55ICsgcmVjdC5oZWlnaHQgJiYgcmVjdC55IDw9IHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgcmVjdGFuZ2xlIGZ1bGx5IGNvbnRhaW5zIGFub3RoZXIgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0gcmVjdCAtIFRoZSByZWN0YW5nbGUgdG8gY2hlY2suXG4gICAqLyBjb250YWluc1JlY3QocmVjdCkge1xuICAgICAgICByZXR1cm4gdGhpcy54IDw9IHJlY3QueCAmJiB0aGlzLnkgPD0gcmVjdC55ICYmIHRoaXMubWF4WCA+PSByZWN0Lm1heFggJiYgdGhpcy5tYXhZID49IHJlY3QubWF4WTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBwb2ludC5cbiAgICogQHBhcmFtIHBvaW50IC0gVGhlIHBvaW50IHRvIGNoZWNrLlxuICAgKi8gY29udGFpbnNQb2ludChwb2ludCkge1xuICAgICAgICByZXR1cm4gdGhpcy54IDw9IHBvaW50LnggJiYgdGhpcy55IDw9IHBvaW50LnkgJiYgdGhpcy5tYXhYID49IHBvaW50LnggJiYgdGhpcy5tYXhZID49IHBvaW50Lnk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBjb3JuZXIgb2YgdGhpcyByZWN0YW5nbGUgKGZyb20gdG9wIHRvIGJvdHRvbSwgbGVmdCB0byByaWdodClcbiAgICogdGhhdCBpcyBjb250YWluZWQgaW4gdGhlIGdpdmVuIHJlY3RhbmdsZSwgb3IgbnVsbCBvZiB0aGUgcmVjdGFuZ2xlcyBkbyBub3QgaW50ZXJzZWN0LlxuICAgKiBAcGFyYW0gcmVjdCAtIFRoZSByZWN0YW5nbGUgdG8gY2hlY2suXG4gICAqLyBnZXRDb3JuZXJJblJlY3QocmVjdCkge1xuICAgICAgICBmb3IgKGxldCBrZXkgb2YgW1xuICAgICAgICAgICAgXCJ0b3BMZWZ0XCIsXG4gICAgICAgICAgICBcInRvcFJpZ2h0XCIsXG4gICAgICAgICAgICBcImJvdHRvbUxlZnRcIixcbiAgICAgICAgICAgIFwiYm90dG9tUmlnaHRcIlxuICAgICAgICBdKXtcbiAgICAgICAgICAgIGlmIChyZWN0LmNvbnRhaW5zUG9pbnQodGhpc1trZXldKSkgcmV0dXJuIGtleTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZXF1YWxzKHJlY3QpIHtcbiAgICAgICAgcmV0dXJuIHJlY3QueCA9PT0gdGhpcy54ICYmIHJlY3QueSA9PT0gdGhpcy55ICYmIHJlY3Qud2lkdGggPT09IHRoaXMud2lkdGggJiYgcmVjdC5oZWlnaHQgPT09IHRoaXMuaGVpZ2h0O1xuICAgIH1cbiAgICBwb2ludEVxdWFscyhwb2ludCkge1xuICAgICAgICByZXR1cm4gdGhpcy54ID09PSBwb2ludC54ICYmIHRoaXMueSA9PT0gcG9pbnQueTtcbiAgICB9XG4gICAgc2l6ZUVxdWFscyhzaXplKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoID09PSBzaXplLndpZHRoICYmIHRoaXMuaGVpZ2h0ID09PSBzaXplLmhlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgdGhlIHVuaW9uIG9mIHRoaXMgUmVjdCBhbmQgYW5vdGhlci5cbiAgICovIHVuaW9uKG90aGVyKSB7XG4gICAgICAgIGxldCB4ID0gTWF0aC5taW4odGhpcy54LCBvdGhlci54KTtcbiAgICAgICAgbGV0IHkgPSBNYXRoLm1pbih0aGlzLnksIG90aGVyLnkpO1xuICAgICAgICBsZXQgd2lkdGggPSBNYXRoLm1heCh0aGlzLm1heFgsIG90aGVyLm1heFgpIC0geDtcbiAgICAgICAgbGV0IGhlaWdodCA9IE1hdGgubWF4KHRoaXMubWF4WSwgb3RoZXIubWF4WSkgLSB5O1xuICAgICAgICByZXR1cm4gbmV3ICQ2MDQyM2Y5MmM3ZjlhZDg3JGV4cG9ydCRjNzlmYzY0OTJmM2FmMTNkKHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoaXMgUmVjdCB3aXRoIGFub3RoZXIuXG4gICAqIElmIHRoZSByZWN0YW5nbGVzIGRvIG5vdCBpbnRlcnNlY3QsIGFuIGFsbCB6ZXJvIFJlY3QgaXMgcmV0dXJuZWQuXG4gICAqLyBpbnRlcnNlY3Rpb24ob3RoZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmludGVyc2VjdHMob3RoZXIpKSByZXR1cm4gbmV3ICQ2MDQyM2Y5MmM3ZjlhZDg3JGV4cG9ydCRjNzlmYzY0OTJmM2FmMTNkKDAsIDAsIDAsIDApO1xuICAgICAgICBsZXQgeCA9IE1hdGgubWF4KHRoaXMueCwgb3RoZXIueCk7XG4gICAgICAgIGxldCB5ID0gTWF0aC5tYXgodGhpcy55LCBvdGhlci55KTtcbiAgICAgICAgcmV0dXJuIG5ldyAkNjA0MjNmOTJjN2Y5YWQ4NyRleHBvcnQkYzc5ZmM2NDkyZjNhZjEzZCh4LCB5LCBNYXRoLm1pbih0aGlzLm1heFgsIG90aGVyLm1heFgpIC0geCwgTWF0aC5taW4odGhpcy5tYXhZLCBvdGhlci5tYXhZKSAtIHkpO1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhpcyByZWN0YW5nbGUuXG4gICAqLyBjb3B5KCkge1xuICAgICAgICByZXR1cm4gbmV3ICQ2MDQyM2Y5MmM3ZjlhZDg3JGV4cG9ydCRjNzlmYzY0OTJmM2FmMTNkKHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgd2lkdGggPSAwLCBoZWlnaHQgPSAwKXtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB9XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGNsYXNzICRlZTFiZmE5MGE5NTdmYjhhJGV4cG9ydCRjYjZkYTg5YzZhZjFhOGVjIHtcbiAgICAvKipcbiAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhpcyBzaXplLlxuICAgKi8gY29weSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAkZWUxYmZhOTBhOTU3ZmI4YSRleHBvcnQkY2I2ZGE4OWM2YWYxYThlYyh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBzaXplIGlzIGVxdWFsIHRvIGFub3RoZXIgb25lLlxuICAgKi8gZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoID09PSBvdGhlci53aWR0aCAmJiB0aGlzLmhlaWdodCA9PT0gb3RoZXIuaGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICogVGhlIHRvdGFsIGFyZWEgb2YgdGhlIFNpemUuXG4gICAqLyBnZXQgYXJlYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggKiB0aGlzLmhlaWdodDtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iod2lkdGggPSAwLCBoZWlnaHQgPSAwKXtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB9XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGxldCAkYWQxZDk4YWE4ZjBjMzFiNCR2YXIkS0VZID0gMDtcbmNsYXNzICRhZDFkOThhYThmMGMzMWI0JGV4cG9ydCQxYTUyMjM4ODdjNTYwNDQxIHtcbiAgICAvKipcbiAgICogUHJlcGFyZXMgdGhlIHZpZXcgZm9yIHJldXNlLiBDYWxsZWQganVzdCBiZWZvcmUgdGhlIHZpZXcgaXMgcmVtb3ZlZCBmcm9tIHRoZSBET00uXG4gICAqLyBwcmVwYXJlRm9yUmV1c2UoKSB7XG4gICAgICAgIHRoaXMuY29udGVudCA9IG51bGw7XG4gICAgICAgIHRoaXMucmVuZGVyZWQgPSBudWxsO1xuICAgICAgICB0aGlzLmxheW91dEluZm8gPSBudWxsO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih2aXJ0dWFsaXplcil7XG4gICAgICAgIHRoaXMudmlydHVhbGl6ZXIgPSB2aXJ0dWFsaXplcjtcbiAgICAgICAgdGhpcy5rZXkgPSArKyRhZDFkOThhYThmMGMzMWI0JHZhciRLRVk7XG4gICAgfVxufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuLy8gdXNlIGhpZ2ggcmVzIHRpbWVyIGlmIGF2YWlsYWJsZVxubGV0ICQzZWIxMzFkY2YzN2FkNWY4JHZhciRwZXJmID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5wZXJmb3JtYW5jZSA6IG51bGw7XG4vLyBAdHMtaWdub3JlXG5sZXQgJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJHBlcmZOb3cgPSAkM2ViMTMxZGNmMzdhZDVmOCR2YXIkcGVyZiAmJiAoJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJHBlcmYubm93IHx8ICQzZWIxMzFkY2YzN2FkNWY4JHZhciRwZXJmLndlYmtpdE5vdyB8fCAkM2ViMTMxZGNmMzdhZDVmOCR2YXIkcGVyZi5tc05vdyB8fCAkM2ViMTMxZGNmMzdhZDVmOCR2YXIkcGVyZi5tb3pOb3cpO1xubGV0ICQzZWIxMzFkY2YzN2FkNWY4JHZhciRnZXRUaW1lID0gJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJHBlcmZOb3cgPyAkM2ViMTMxZGNmMzdhZDVmOCR2YXIkcGVyZk5vdy5iaW5kKCQzZWIxMzFkY2YzN2FkNWY4JHZhciRwZXJmKSA6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBEYXRlLm5vdyA/IERhdGUubm93KCkgOiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbn07XG5sZXQgJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJGZpeFRzO1xuZnVuY3Rpb24gJDNlYjEzMWRjZjM3YWQ1ZjgkZXhwb3J0JGRjMGI2MzcyMDc4ODA5MGMoYmVnaW4sIGVuZCwgZHVyYXRpb24sIGVhc2UsIGZuKSB7XG4gICAgbGV0IGNhbmNlbGVkID0gZmFsc2U7XG4gICAgbGV0IHJhZl9pZDtcbiAgICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKT0+e1xuICAgICAgICBsZXQgc3RhcnQgPSAkM2ViMTMxZGNmMzdhZDVmOCR2YXIkZ2V0VGltZSgpO1xuICAgICAgICBsZXQgZGlmZlggPSBlbmQueCAtIGJlZ2luLng7XG4gICAgICAgIGxldCBkaWZmWSA9IGVuZC55IC0gYmVnaW4ueTtcbiAgICAgICAgcmFmX2lkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uIHJ1bih0KSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSdyZSB1c2luZyBhIGhpZ2ggcmVzIHRpbWVyLCBtYWtlIHN1cmUgdGltZXN0YW1wIGlzIG5vdCB0aGUgb2xkIGVwb2NoLWJhc2VkIHZhbHVlLlxuICAgICAgICAgICAgLy8gaHR0cDovL3VwZGF0ZXMuaHRtbDVyb2Nrcy5jb20vMjAxMi8wNS9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUtQVBJLW5vdy13aXRoLXN1Yi1taWxsaXNlY29uZC1wcmVjaXNpb25cbiAgICAgICAgICAgIGlmICgkM2ViMTMxZGNmMzdhZDVmOCR2YXIkZml4VHMgPT0gbnVsbCkgJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJGZpeFRzID0gdCA+IDFlMTIgIT09ICQzZWIxMzFkY2YzN2FkNWY4JHZhciRnZXRUaW1lKCkgPiAxZTEyO1xuICAgICAgICAgICAgaWYgKCQzZWIxMzFkY2YzN2FkNWY4JHZhciRmaXhUcykgdCA9ICQzZWIxMzFkY2YzN2FkNWY4JHZhciRnZXRUaW1lKCk7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSdyZSBkb25lXG4gICAgICAgICAgICBsZXQgZGVsdGEgPSB0IC0gc3RhcnQ7XG4gICAgICAgICAgICBpZiAoZGVsdGEgPiBkdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGZuKGVuZCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjYWxsIGZyYW1lIGNhbGxiYWNrIGFmdGVyIGNvbXB1dGluZyBlYXNlZCB0aW1lIGFuZCBnZXQgdGhlIG5leHQgZnJhbWVcbiAgICAgICAgICAgICAgICBsZXQgcHJvY2VlZCA9IGZuKG5ldyAoMCwgJDMwNDFkYjMyOTY5NDVlNmUkZXhwb3J0JGJhZjI2MTQ2YTQxNGYyNGEpKGJlZ2luLnggKyBkaWZmWCAqIGVhc2UoZGVsdGEgLyBkdXJhdGlvbiksIGJlZ2luLnkgKyBkaWZmWSAqIGVhc2UoZGVsdGEgLyBkdXJhdGlvbikpKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2VlZCAhPT0gZmFsc2UgJiYgIWNhbmNlbGVkKSByYWZfaWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocnVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcHJvbWlzZS5jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY2FuY2VsZWQgPSB0cnVlO1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyYWZfaWQpO1xuICAgIH07XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5mdW5jdGlvbiAkM2ViMTMxZGNmMzdhZDVmOCRleHBvcnQkNzc4NjBjMTA2YjRhNmEyZSh0KSB7XG4gICAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiAkM2ViMTMxZGNmMzdhZDVmOCRleHBvcnQkNTc2MzZiYjQzYjFjY2JiMCh0KSB7XG4gICAgcmV0dXJuIE1hdGguc2luKHQgKiBNYXRoLlBJIC8gMik7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGZ1bmN0aW9uICRmYzM2ZjlhMDQ2YTljZTc5JGV4cG9ydCQzN2EyNmIyODNmZDc3NDBlKGEsIGIpIHtcbiAgICBsZXQgcmVzID0gbmV3IFNldCgpO1xuICAgIGZvciAobGV0IGtleSBvZiBhLmtleXMoKSlpZiAoIWIuaGFzKGtleSkpIHJlcy5hZGQoa2V5KTtcbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gJGZjMzZmOWEwNDZhOWNlNzkkZXhwb3J0JGFjYWY5NmEyNzQzODI0NmIoYSwgYikge1xuICAgIGxldCB0b1JlbW92ZSA9ICRmYzM2ZjlhMDQ2YTljZTc5JGV4cG9ydCQzN2EyNmIyODNmZDc3NDBlKGEsIGIpO1xuICAgIGxldCB0b0FkZCA9ICRmYzM2ZjlhMDQ2YTljZTc5JGV4cG9ydCQzN2EyNmIyODNmZDc3NDBlKGIsIGEpO1xuICAgIGxldCB0b1VwZGF0ZSA9IG5ldyBTZXQ7XG4gICAgZm9yIChsZXQga2V5IG9mIGEua2V5cygpKWlmIChiLmhhcyhrZXkpKSB0b1VwZGF0ZS5hZGQoa2V5KTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0b1JlbW92ZTogdG9SZW1vdmUsXG4gICAgICAgIHRvQWRkOiB0b0FkZCxcbiAgICAgICAgdG9VcGRhdGU6IHRvVXBkYXRlXG4gICAgfTtcbn1cbmZ1bmN0aW9uKiAkZmMzNmY5YTA0NmE5Y2U3OSRleHBvcnQkY2ZjMTQwODhkZmVmY2U1ZiguLi5pdGVyYXRvcnMpIHtcbiAgICBmb3IgKGxldCBpdGVyYXRvciBvZiBpdGVyYXRvcnMpeWllbGQqIGl0ZXJhdG9yO1xufVxuZnVuY3Rpb24gJGZjMzZmOWEwNDZhOWNlNzkkZXhwb3J0JDY4OTdjMjg0YjZmOWY0ZGMob2JqZWN0KSB7XG4gICAgbGV0IHJlcyA9IHt9O1xuICAgIGZvcihsZXQga2V5IGluIG9iamVjdClyZXNbb2JqZWN0W2tleV1dID0ga2V5O1xuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiAkZmMzNmY5YTA0NmE5Y2U3OSRleHBvcnQkYThkMGQwYzhkMWM1ZGY2NChhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuICAgIGlmIChhLnNpemUgIT09IGIuc2l6ZSkgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGtleSBvZiBhKXtcbiAgICAgICAgaWYgKCFiLmhhcyhrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuY2xhc3MgJDM2NDE5MWIzZGVjZjM2OTckdmFyJFJvbGxpbmdBdmVyYWdlIHtcbiAgICBhZGRTYW1wbGUoc2FtcGxlKSB7XG4gICAgICAgIHRoaXMuY291bnQrKztcbiAgICAgICAgdGhpcy52YWx1ZSArPSAoc2FtcGxlIC0gdGhpcy52YWx1ZSkgLyB0aGlzLmNvdW50O1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IDA7XG4gICAgfVxufVxuY2xhc3MgJDM2NDE5MWIzZGVjZjM2OTckZXhwb3J0JDQ0NTVlZTZhZmIzOGRjYmIge1xuICAgIHNldFZpc2libGVSZWN0KHJlY3QpIHtcbiAgICAgICAgbGV0IHRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHRoaXMuc3RhcnRUaW1lO1xuICAgICAgICBpZiAodGltZSA8IDUwMCkge1xuICAgICAgICAgICAgdGhpcy5hdmVyYWdlVGltZS5hZGRTYW1wbGUodGltZSk7XG4gICAgICAgICAgICBpZiAocmVjdC54ICE9PSB0aGlzLnZpc2libGVSZWN0LnggJiYgdGltZSA+IDApIHRoaXMudmVsb2NpdHkueCA9IChyZWN0LnggLSB0aGlzLnZpc2libGVSZWN0LngpIC8gdGltZTtcbiAgICAgICAgICAgIGlmIChyZWN0LnkgIT09IHRoaXMudmlzaWJsZVJlY3QueSAmJiB0aW1lID4gMCkgdGhpcy52ZWxvY2l0eS55ID0gKHJlY3QueSAtIHRoaXMudmlzaWJsZVJlY3QueSkgLyB0aW1lO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIHRoaXMudmlzaWJsZVJlY3QgPSByZWN0O1xuICAgIH1cbiAgICBjb2xsZWN0TWV0cmljcygpIHtcbiAgICAgICAgbGV0IHRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHRoaXMuc3RhcnRUaW1lO1xuICAgICAgICBpZiAodGltZSA8IDUwMCkgdGhpcy5hdmVyYWdlUGVyZi5hZGRTYW1wbGUodGltZSk7XG4gICAgICAgIGlmICh0aGlzLnZpc2libGVSZWN0LmhlaWdodCA+IDApIHtcbiAgICAgICAgICAgIGxldCBvID0gTWF0aC5hYnModGhpcy52ZWxvY2l0eS55ICogKHRoaXMuYXZlcmFnZVRpbWUudmFsdWUgKyB0aGlzLmF2ZXJhZ2VQZXJmLnZhbHVlKSk7XG4gICAgICAgICAgICB0aGlzLm92ZXJzY2FuWS5hZGRTYW1wbGUobyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmlzaWJsZVJlY3Qud2lkdGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgbyA9IE1hdGguYWJzKHRoaXMudmVsb2NpdHkueCAqICh0aGlzLmF2ZXJhZ2VUaW1lLnZhbHVlICsgdGhpcy5hdmVyYWdlUGVyZi52YWx1ZSkpO1xuICAgICAgICAgICAgdGhpcy5vdmVyc2NhblguYWRkU2FtcGxlKG8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldE92ZXJzY2FubmVkUmVjdCgpIHtcbiAgICAgICAgbGV0IG92ZXJzY2FubmVkID0gdGhpcy52aXNpYmxlUmVjdC5jb3B5KCk7XG4gICAgICAgIGxldCBvdmVyc2NhblkgPSBNYXRoLnJvdW5kKE1hdGgubWluKHRoaXMudmlzaWJsZVJlY3QuaGVpZ2h0ICogMiwgdGhpcy5vdmVyc2NhblkudmFsdWUpIC8gMTAwKSAqIDEwMDtcbiAgICAgICAgaWYgKHRoaXMudmVsb2NpdHkueSA+IDApIHtcbiAgICAgICAgICAgIG92ZXJzY2FubmVkLnkgLT0gb3ZlcnNjYW5ZICogMC4yO1xuICAgICAgICAgICAgb3ZlcnNjYW5uZWQuaGVpZ2h0ICs9IG92ZXJzY2FuWSArIG92ZXJzY2FuWSAqIDAuMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG92ZXJzY2FubmVkLnkgLT0gb3ZlcnNjYW5ZO1xuICAgICAgICAgICAgb3ZlcnNjYW5uZWQuaGVpZ2h0ICs9IG92ZXJzY2FuWSArIG92ZXJzY2FuWSAqIDAuMjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3ZlcnNjYW5YID0gTWF0aC5yb3VuZChNYXRoLm1pbih0aGlzLnZpc2libGVSZWN0LndpZHRoICogMiwgdGhpcy5vdmVyc2NhblgudmFsdWUpIC8gMTAwKSAqIDEwMDtcbiAgICAgICAgaWYgKHRoaXMudmVsb2NpdHkueCA+IDApIHtcbiAgICAgICAgICAgIG92ZXJzY2FubmVkLnggLT0gb3ZlcnNjYW5YICogMC4yO1xuICAgICAgICAgICAgb3ZlcnNjYW5uZWQud2lkdGggKz0gb3ZlcnNjYW5YICsgb3ZlcnNjYW5YICogMC4yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3ZlcnNjYW5uZWQueCAtPSBvdmVyc2Nhblg7XG4gICAgICAgICAgICBvdmVyc2Nhbm5lZC53aWR0aCArPSBvdmVyc2NhblggKyBvdmVyc2NhblggKiAwLjI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG92ZXJzY2FubmVkO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IDA7XG4gICAgICAgIHRoaXMuYXZlcmFnZVBlcmYgPSBuZXcgJDM2NDE5MWIzZGVjZjM2OTckdmFyJFJvbGxpbmdBdmVyYWdlKCk7XG4gICAgICAgIHRoaXMuYXZlcmFnZVRpbWUgPSBuZXcgJDM2NDE5MWIzZGVjZjM2OTckdmFyJFJvbGxpbmdBdmVyYWdlKCk7XG4gICAgICAgIHRoaXMudmVsb2NpdHkgPSBuZXcgKDAsICQzMDQxZGIzMjk2OTQ1ZTZlJGV4cG9ydCRiYWYyNjE0NmE0MTRmMjRhKSg1LCA1KTtcbiAgICAgICAgdGhpcy5vdmVyc2NhblggPSBuZXcgJDM2NDE5MWIzZGVjZjM2OTckdmFyJFJvbGxpbmdBdmVyYWdlKCk7XG4gICAgICAgIHRoaXMub3ZlcnNjYW5ZID0gbmV3ICQzNjQxOTFiM2RlY2YzNjk3JHZhciRSb2xsaW5nQXZlcmFnZSgpO1xuICAgICAgICB0aGlzLnZpc2libGVSZWN0ID0gbmV3ICgwLCAkNjA0MjNmOTJjN2Y5YWQ4NyRleHBvcnQkYzc5ZmM2NDkyZjNhZjEzZCkoKTtcbiAgICB9XG59XG5cblxuXG5cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gY2xhc3MgJDhlMTM1ZTUzMWQ4ZGNiNjYkZXhwb3J0JGZlYmM1NTczYzc1Y2VmYjAge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMubGV2ZWwgPSAwO1xuICAgICAgICB0aGlzLmFjdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5hbmltYXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaW5pdGlhbE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5maW5hbE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5pbml0aWFsTGF5b3V0SW5mbyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5maW5hbExheW91dEluZm8gPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucmVtb3ZlZCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy50b1JlbW92ZSA9IG5ldyBNYXAoKTtcbiAgICB9XG59XG5cblxuY2xhc3MgJDM4Yjk0OTBjMWNjYThmYzQkZXhwb3J0JDg5YmU1YTI0M2U1OWM0YjIge1xuICAgIF9zZXRDb250ZW50U2l6ZShzaXplKSB7XG4gICAgICAgIHRoaXMuX2NvbnRlbnRTaXplID0gc2l6ZTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5zZXRDb250ZW50U2l6ZShzaXplKTtcbiAgICB9XG4gICAgX3NldENvbnRlbnRPZmZzZXQob2Zmc2V0KSB7XG4gICAgICAgIGxldCByZWN0ID0gbmV3ICgwLCAkNjA0MjNmOTJjN2Y5YWQ4NyRleHBvcnQkYzc5ZmM2NDkyZjNhZjEzZCkob2Zmc2V0LngsIG9mZnNldC55LCB0aGlzLl92aXNpYmxlUmVjdC53aWR0aCwgdGhpcy5fdmlzaWJsZVJlY3QuaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5zZXRWaXNpYmxlUmVjdChyZWN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAqIEdldCB0aGUgc2l6ZSBvZiB0aGUgc2Nyb2xsYWJsZSBjb250ZW50LlxuICAgKi8gZ2V0IGNvbnRlbnRTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudFNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgKiBHZXQgdGhlIGNvbGxlY3Rpb24gdmlldydzIGN1cnJlbnRseSB2aXNpYmxlIHJlY3RhbmdsZS5cbiAgICovIGdldCB2aXNpYmxlUmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGVSZWN0O1xuICAgIH1cbiAgICAvKipcbiAgICogU2V0IHRoZSBjb2xsZWN0aW9uIHZpZXcncyBjdXJyZW50bHkgdmlzaWJsZSByZWN0YW5nbGUuXG4gICAqLyBzZXQgdmlzaWJsZVJlY3QocmVjdCkge1xuICAgICAgICB0aGlzLl9zZXRWaXNpYmxlUmVjdChyZWN0KTtcbiAgICB9XG4gICAgX3NldFZpc2libGVSZWN0KHJlY3QsIGZvcmNlVXBkYXRlID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLl92aXNpYmxlUmVjdDtcbiAgICAgICAgLy8gSWdub3JlIGlmIHRoZSByZWN0cyBhcmUgZXF1YWxcbiAgICAgICAgaWYgKHJlY3QuZXF1YWxzKGN1cnJlbnQpKSByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLnNob3VsZE92ZXJzY2FuKSB0aGlzLl9vdmVyc2Nhbk1hbmFnZXIuc2V0VmlzaWJsZVJlY3QocmVjdCk7XG4gICAgICAgIGxldCBzaG91bGRJbnZhbGlkYXRlID0gdGhpcy5sYXlvdXQgJiYgdGhpcy5sYXlvdXQuc2hvdWxkSW52YWxpZGF0ZShyZWN0LCB0aGlzLl92aXNpYmxlUmVjdCk7XG4gICAgICAgIHRoaXMuX3Jlc2V0QW5pbWF0ZWRDb250ZW50T2Zmc2V0KCk7XG4gICAgICAgIHRoaXMuX3Zpc2libGVSZWN0ID0gcmVjdDtcbiAgICAgICAgaWYgKHNob3VsZEludmFsaWRhdGUpIC8vIFdlIGFyZSBhbHJlYWR5IGluIGEgbGF5b3V0IGVmZmVjdCB3aGVuIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCwgc28gcmVsYXlvdXROb3cgaXMgYXBwcm9wcmlhdGUuXG4gICAgICAgIHRoaXMucmVsYXlvdXROb3coe1xuICAgICAgICAgICAgb2Zmc2V0Q2hhbmdlZDogIXJlY3QucG9pbnRFcXVhbHMoY3VycmVudCksXG4gICAgICAgICAgICBzaXplQ2hhbmdlZDogIXJlY3Quc2l6ZUVxdWFscyhjdXJyZW50KVxuICAgICAgICB9KTtcbiAgICAgICAgZWxzZSB0aGlzLnVwZGF0ZVN1YnZpZXdzKGZvcmNlVXBkYXRlKTtcbiAgICB9XG4gICAgZ2V0IGNvbGxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xsZWN0aW9uO1xuICAgIH1cbiAgICBzZXQgY29sbGVjdGlvbihkYXRhKSB7XG4gICAgICAgIHRoaXMuX3NldERhdGEoZGF0YSk7XG4gICAgfVxuICAgIF9zZXREYXRhKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IHRoaXMuX2NvbGxlY3Rpb24pIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuX2NvbGxlY3Rpb24pIHRoaXMuX3J1blRyYW5zYWN0aW9uKCgpPT57XG4gICAgICAgICAgICB0aGlzLl9jb2xsZWN0aW9uID0gZGF0YTtcbiAgICAgICAgfSwgdGhpcy50cmFuc2l0aW9uRHVyYXRpb24gPiAwKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jb2xsZWN0aW9uID0gZGF0YTtcbiAgICAgICAgICAgIHRoaXMucmVsb2FkRGF0YSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZWxvYWRzIHRoZSBkYXRhIGZyb20gdGhlIGRhdGEgc291cmNlIGFuZCByZWxheW91dHMgdGhlIGNvbGxlY3Rpb24gdmlldy5cbiAgICogRG9lcyBub3QgYW5pbWF0ZSBhbnkgY2hhbmdlcy4gRXF1aXZhbGVudCB0byByZS1hc3NpZ25pbmcgdGhlIHNhbWUgZGF0YSBzb3VyY2VcbiAgICogdG8gdGhlIGNvbGxlY3Rpb24gdmlldy5cbiAgICovIHJlbG9hZERhdGEoKSB7XG4gICAgICAgIHRoaXMucmVsYXlvdXQoe1xuICAgICAgICAgICAgY29udGVudENoYW5nZWQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpdGVtIHdpdGggdGhlIGdpdmVuIGtleS5cbiAgICovIGdldEl0ZW0oa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xsZWN0aW9uID8gdGhpcy5fY29sbGVjdGlvbi5nZXRJdGVtKGtleSkgOiBudWxsO1xuICAgIH1cbiAgICAvKiogVGhlIHNldCBvZiBwZXJzaXN0ZWQga2V5cyBhcmUgYWx3YXlzIHByZXNlbnQgaW4gdGhlIERPTSwgZXZlbiBpZiBub3QgY3VycmVudGx5IGluIHZpZXcuICovIGdldCBwZXJzaXN0ZWRLZXlzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGVyc2lzdGVkS2V5cztcbiAgICB9XG4gICAgLyoqIFRoZSBzZXQgb2YgcGVyc2lzdGVkIGtleXMgYXJlIGFsd2F5cyBwcmVzZW50IGluIHRoZSBET00sIGV2ZW4gaWYgbm90IGN1cnJlbnRseSBpbiB2aWV3LiAqLyBzZXQgcGVyc2lzdGVkS2V5cyhwZXJzaXN0ZWRLZXlzKSB7XG4gICAgICAgIGlmICghKDAsICRmYzM2ZjlhMDQ2YTljZTc5JGV4cG9ydCRhOGQwZDBjOGQxYzVkZjY0KShwZXJzaXN0ZWRLZXlzLCB0aGlzLl9wZXJzaXN0ZWRLZXlzKSkge1xuICAgICAgICAgICAgdGhpcy5fcGVyc2lzdGVkS2V5cyA9IHBlcnNpc3RlZEtleXM7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN1YnZpZXdzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIFJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4ga2V5LCBvciBhbiBhbmNlc3RvciwgaXMgcGVyc2lzdGVkLiAqLyBpc1BlcnNpc3RlZEtleShrZXkpIHtcbiAgICAgICAgLy8gUXVpY2sgY2hlY2sgaWYgdGhlIGtleSBpcyBkaXJlY3RseSBpbiB0aGUgc2V0IG9mIHBlcnNpc3RlZCBrZXlzLlxuICAgICAgICBpZiAodGhpcy5fcGVyc2lzdGVkS2V5cy5oYXMoa2V5KSkgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIElmIG5vdCwgY2hlY2sgaWYgdGhlIGtleSBpcyBhbiBhbmNlc3RvciBvZiBhbnkgb2YgdGhlIHBlcnNpc3RlZCBrZXlzLlxuICAgICAgICBmb3IgKGxldCBrIG9mIHRoaXMuX3BlcnNpc3RlZEtleXMpd2hpbGUoayAhPSBudWxsKXtcbiAgICAgICAgICAgIGxldCBsYXlvdXRJbmZvID0gdGhpcy5sYXlvdXQuZ2V0TGF5b3V0SW5mbyhrKTtcbiAgICAgICAgICAgIGlmICghbGF5b3V0SW5mbykgYnJlYWs7XG4gICAgICAgICAgICBrID0gbGF5b3V0SW5mby5wYXJlbnRLZXk7XG4gICAgICAgICAgICBpZiAoayA9PT0ga2V5KSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgKiBHZXQgdGhlIGNvbGxlY3Rpb24gdmlldydzIGxheW91dC5cbiAgICovIGdldCBsYXlvdXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXlvdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgKiBTZXQgdGhlIGNvbGxlY3Rpb24gdmlldydzIGxheW91dC5cbiAgICovIHNldCBsYXlvdXQobGF5b3V0KSB7XG4gICAgICAgIHRoaXMuc2V0TGF5b3V0KGxheW91dCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBTZXRzIHRoZSBjb2xsZWN0aW9uIHZpZXcncyBsYXlvdXQsIG9wdGlvbmFsbHkgd2l0aCBhbiBhbmltYXRlZCB0cmFuc2l0aW9uXG4gICAqIGZyb20gdGhlIGN1cnJlbnQgbGF5b3V0IHRvIHRoZSBuZXcgbGF5b3V0LlxuICAgKiBAcGFyYW0gbGF5b3V0IFRoZSBsYXlvdXQgdG8gc3dpdGNoIHRvLlxuICAgKiBAcGFyYW0gYW5pbWF0ZWQgV2hldGhlciB0byBhbmltYXRlIHRoZSBsYXlvdXQgY2hhbmdlLlxuICAgKi8gc2V0TGF5b3V0KGxheW91dCwgYW5pbWF0ZWQgPSBmYWxzZSkge1xuICAgICAgICBpZiAobGF5b3V0ID09PSB0aGlzLl9sYXlvdXQpIHJldHVybjtcbiAgICAgICAgbGV0IGFwcGx5TGF5b3V0ID0gKCk9PntcbiAgICAgICAgICAgIGlmICh0aGlzLl9sYXlvdXQpIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHRoaXMuX2xheW91dC52aXJ0dWFsaXplciA9IG51bGw7XG4gICAgICAgICAgICBsYXlvdXQudmlydHVhbGl6ZXIgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fbGF5b3V0ID0gbGF5b3V0O1xuICAgICAgICB9O1xuICAgICAgICBpZiAoYW5pbWF0ZWQpIC8vIEFuaW1hdGVkIGxheW91dCB0cmFuc2l0aW9ucyBhcmUgcmVhbGx5IHNpbXBsZSwgdGhhbmtzIHRvIG91ciB0cmFuc2FjdGlvbiBzdXBwb3J0LlxuICAgICAgICAvLyBXZSBqdXN0IHNldCB0aGUgbGF5b3V0IGluc2lkZSBhIHRyYW5zYWN0aW9uIGFjdGlvbiwgd2hpY2ggcnVucyBhZnRlciB0aGUgaW5pdGlhbFxuICAgICAgICAvLyBsYXlvdXQgaW5mb3MgZm9yIHRoZSBhbmltYXRpb24gYXJlIHJldHJpZXZlZCBmcm9tIHRoZSBwcmV2aW91cyBsYXlvdXQuIFRoZW4sIHRoZVxuICAgICAgICAvLyBmaW5hbCBsYXlvdXQgaW5mb3MgYXJlIHJldHJpZXZlZCBmcm9tIHRoZSBuZXcgbGF5b3V0LCBhbmQgYW5pbWF0aW9ucyBvY2N1ci5cbiAgICAgICAgdGhpcy5fcnVuVHJhbnNhY3Rpb24oYXBwbHlMYXlvdXQpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFwcGx5TGF5b3V0KCk7XG4gICAgICAgICAgICB0aGlzLnJlbGF5b3V0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2dldFJldXNlVHlwZShsYXlvdXRJbmZvLCBjb250ZW50KSB7XG4gICAgICAgIGlmIChsYXlvdXRJbmZvLnR5cGUgPT09IFwiaXRlbVwiICYmIGNvbnRlbnQpIHtcbiAgICAgICAgICAgIGxldCB0eXBlID0gdGhpcy5kZWxlZ2F0ZS5nZXRUeXBlID8gdGhpcy5kZWxlZ2F0ZS5nZXRUeXBlKGNvbnRlbnQpIDogXCJpdGVtXCI7XG4gICAgICAgICAgICBsZXQgcmV1c2VUeXBlID0gdHlwZSA9PT0gXCJpdGVtXCIgPyBcIml0ZW1cIiA6IGxheW91dEluZm8udHlwZSArIFwiX1wiICsgdHlwZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICByZXVzZVR5cGU6IHJldXNlVHlwZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogbGF5b3V0SW5mby50eXBlLFxuICAgICAgICAgICAgcmV1c2VUeXBlOiBsYXlvdXRJbmZvLnR5cGVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0UmV1c2FibGVWaWV3KGxheW91dEluZm8pIHtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSB0aGlzLmdldEl0ZW0obGF5b3V0SW5mby5rZXkpO1xuICAgICAgICBsZXQgeyByZXVzZVR5cGU6IHJldXNlVHlwZSB9ID0gdGhpcy5fZ2V0UmV1c2VUeXBlKGxheW91dEluZm8sIGNvbnRlbnQpO1xuICAgICAgICBpZiAoIXRoaXMuX3JldXNhYmxlVmlld3NbcmV1c2VUeXBlXSkgdGhpcy5fcmV1c2FibGVWaWV3c1tyZXVzZVR5cGVdID0gW107XG4gICAgICAgIGxldCByZXVzYWJsZSA9IHRoaXMuX3JldXNhYmxlVmlld3NbcmV1c2VUeXBlXTtcbiAgICAgICAgbGV0IHZpZXcgPSByZXVzYWJsZS5sZW5ndGggPiAwID8gcmV1c2FibGUucG9wKCkgOiBuZXcgKDAsICRhZDFkOThhYThmMGMzMWI0JGV4cG9ydCQxYTUyMjM4ODdjNTYwNDQxKSh0aGlzKTtcbiAgICAgICAgdmlldy52aWV3VHlwZSA9IHJldXNlVHlwZTtcbiAgICAgICAgaWYgKCF0aGlzLl9hbmltYXRlZENvbnRlbnRPZmZzZXQuaXNPcmlnaW4oKSkge1xuICAgICAgICAgICAgbGF5b3V0SW5mbyA9IGxheW91dEluZm8uY29weSgpO1xuICAgICAgICAgICAgbGF5b3V0SW5mby5yZWN0LnggKz0gdGhpcy5fYW5pbWF0ZWRDb250ZW50T2Zmc2V0Lng7XG4gICAgICAgICAgICBsYXlvdXRJbmZvLnJlY3QueSArPSB0aGlzLl9hbmltYXRlZENvbnRlbnRPZmZzZXQueTtcbiAgICAgICAgfVxuICAgICAgICB2aWV3LmxheW91dEluZm8gPSBsYXlvdXRJbmZvO1xuICAgICAgICB0aGlzLl9yZW5kZXJWaWV3KHZpZXcpO1xuICAgICAgICByZXR1cm4gdmlldztcbiAgICB9XG4gICAgX3JlbmRlclZpZXcocmV1c2FibGVWaWV3KSB7XG4gICAgICAgIGxldCB7IHR5cGU6IHR5cGUsIGtleToga2V5IH0gPSByZXVzYWJsZVZpZXcubGF5b3V0SW5mbztcbiAgICAgICAgcmV1c2FibGVWaWV3LmNvbnRlbnQgPSB0aGlzLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgcmV1c2FibGVWaWV3LnJlbmRlcmVkID0gdGhpcy5fcmVuZGVyQ29udGVudCh0eXBlLCByZXVzYWJsZVZpZXcuY29udGVudCk7XG4gICAgfVxuICAgIF9yZW5kZXJDb250ZW50KHR5cGUsIGNvbnRlbnQpIHtcbiAgICAgICAgbGV0IGNhY2hlZCA9IHRoaXMuX3JlbmRlcmVkQ29udGVudC5nZXQoY29udGVudCk7XG4gICAgICAgIGlmIChjYWNoZWQgIT0gbnVsbCkgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgbGV0IHJlbmRlcmVkID0gdGhpcy5kZWxlZ2F0ZS5yZW5kZXJWaWV3KHR5cGUsIGNvbnRlbnQpO1xuICAgICAgICBpZiAoY29udGVudCkgdGhpcy5fcmVuZGVyZWRDb250ZW50LnNldChjb250ZW50LCByZW5kZXJlZCk7XG4gICAgICAgIHJldHVybiByZW5kZXJlZDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIGN1cnJlbnRseSB2aXNpYmxlIHZpZXdzLCBpbmNsdWRpbmcgYm90aFxuICAgKiBpdGVtIHZpZXdzIGFuZCBzdXBwbGVtZW50YXJ5IHZpZXdzLlxuICAgKi8gZ2V0IHZpc2libGVWaWV3cygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5fdmlzaWJsZVZpZXdzLnZhbHVlcygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIEdldHMgdGhlIHZpc2libGUgdmlldyBmb3IgdGhlIGdpdmVuIHR5cGUgYW5kIGtleS4gUmV0dXJucyBudWxsIGlmXG4gICAqIHRoZSB2aWV3IGlzIG5vdCBjdXJyZW50bHkgdmlzaWJsZS5cbiAgICpcbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSB2aWV3IHRvIHJldHJpZXZlLlxuICAgKi8gZ2V0VmlldyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGVWaWV3cy5nZXQoa2V5KSB8fCBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiB2aXNpYmxlIHZpZXdzIG1hdGNoaW5nIHRoZSBnaXZlbiB0eXBlLlxuICAgKiBAcGFyYW0gdHlwZSBUaGUgdmlldyB0eXBlIHRvIGZpbmQuXG4gICAqLyBnZXRWaWV3c09mVHlwZSh0eXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2libGVWaWV3cy5maWx0ZXIoKHYpPT52LmxheW91dEluZm8gJiYgdi5sYXlvdXRJbmZvLnR5cGUgPT09IHR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyB0aGUga2V5IGZvciB0aGUgZ2l2ZW4gdmlldy4gUmV0dXJucyBudWxsXG4gICAqIGlmIHRoZSB2aWV3IGlzIG5vdCBjdXJyZW50bHkgdmlzaWJsZS5cbiAgICovIGtleUZvclZpZXcodmlldykge1xuICAgICAgICBpZiAodmlldyAmJiB2aWV3LmxheW91dEluZm8pIHJldHVybiB2aWV3LmxheW91dEluZm8ua2V5O1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgdGhlIGtleSBmb3IgdGhlIGl0ZW0gdmlldyBjdXJyZW50bHkgYXQgdGhlIGdpdmVuIHBvaW50LlxuICAgKi8ga2V5QXRQb2ludChwb2ludCkge1xuICAgICAgICBsZXQgcmVjdCA9IG5ldyAoMCwgJDYwNDIzZjkyYzdmOWFkODckZXhwb3J0JGM3OWZjNjQ5MmYzYWYxM2QpKHBvaW50LngsIHBvaW50LnksIDEsIDEpO1xuICAgICAgICBsZXQgbGF5b3V0SW5mb3MgPSB0aGlzLmxheW91dC5nZXRWaXNpYmxlTGF5b3V0SW5mb3MocmVjdCk7XG4gICAgICAgIC8vIExheW91dCBtYXkgcmV0dXJuIG11bHRpcGxlIGxheW91dCBpbmZvcyBpbiB0aGUgY2FzZSBvZlxuICAgICAgICAvLyBwZXJzaXN0ZWQga2V5cywgc28gZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgYWN0dWFsbHkgaW50ZXJzZWN0cy5cbiAgICAgICAgZm9yIChsZXQgbGF5b3V0SW5mbyBvZiBsYXlvdXRJbmZvcyl7XG4gICAgICAgICAgICBpZiAobGF5b3V0SW5mby5yZWN0LmludGVyc2VjdHMocmVjdCkpIHJldHVybiBsYXlvdXRJbmZvLmtleTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAqIENsZWFudXAgZm9yIHdoZW4gdGhlIFZpcnR1YWxpemVyIHdpbGwgYmUgdW5tb3VudGVkLlxuICAgKi8gd2lsbFVubW91bnQoKSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlbGF5b3V0UmFmKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFRyaWdnZXJzIGEgbGF5b3V0IGludmFsaWRhdGlvbiwgYW5kIHVwZGF0ZXMgdGhlIHZpc2libGUgc3Vidmlld3MuXG4gICAqLyByZWxheW91dChjb250ZXh0ID0ge30pIHtcbiAgICAgICAgLy8gSWdub3JlIHJlbGF5b3V0cyB3aGlsZSBhbmltYXRpbmcgdGhlIHNjcm9sbCBwb3NpdGlvblxuICAgICAgICBpZiAodGhpcy5fc2Nyb2xsQW5pbWF0aW9uIHx8IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybjtcbiAgICAgICAgLy8gSWYgd2UgYWxyZWFkeSBzY2hlZHVsZWQgYSByZWxheW91dCwgZXh0ZW5kIHRoZSBpbnZhbGlkYXRpb25cbiAgICAgICAgLy8gY29udGV4dCBzbyB3ZSBjb2FsZXNjZSBtdWx0aXBsZSByZWxheW91dHMgaW4gdGhlIHNhbWUgZnJhbWUuXG4gICAgICAgIGlmICh0aGlzLl9pbnZhbGlkYXRpb25Db250ZXh0KSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX2ludmFsaWRhdGlvbkNvbnRleHQsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ludmFsaWRhdGlvbkNvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cbiAgICAvKipcbiAgICogUGVyZm9ybXMgYSByZWxheW91dCBpbW1lZGlhdGVseS4gUHJlZmVyIHtAbGluayByZWxheW91dH0gb3ZlciB0aGlzIG1ldGhvZFxuICAgKiB3aGVyZSBwb3NzaWJsZSwgc2luY2UgaXQgY29hbGVzY2VzIG11bHRpcGxlIGxheW91dCBwYXNzZXMgaW4gdGhlIHNhbWUgdGljay5cbiAgICovIHJlbGF5b3V0Tm93KGNvbnRleHQgPSB0aGlzLl9pbnZhbGlkYXRpb25Db250ZXh0IHx8IHt9KSB7XG4gICAgICAgIC8vIENhbmNlbCB0aGUgc2NoZWR1bGVkIHJlbGF5b3V0LCBzaW5jZSB3ZSdyZSBkb2luZyBpdCBub3cuXG4gICAgICAgIGlmICh0aGlzLl9yZWxheW91dFJhZikge1xuICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fcmVsYXlvdXRSYWYpO1xuICAgICAgICAgICAgdGhpcy5fcmVsYXlvdXRSYWYgPSBudWxsO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBwcm92aWRlZCBjb250ZXh0IHdpdGggdGhlIGN1cnJlbnQgaW52YWxpZGF0aW9uQ29udGV4dCBzaW5jZSB3ZSBhcmUgY2FuY2VsbGluZ1xuICAgICAgICAgICAgLy8gYSBzY2hlZHVsZWQgcmVsYXlvdXROb3cgY2FsbCB0aGF0IGhhcyB0aGlzLl9pbnZhbGlkYXRpb25Db250ZXh0IHNldCBhcyBpdHMgZGVmYXVsdCBjb250ZXh0IGFyZyAocmVsYXlvdXROb3coKSBpbiByZWxheW91dClcbiAgICAgICAgICAgIGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5faW52YWxpZGF0aW9uQ29udGV4dCxcbiAgICAgICAgICAgICAgICAuLi5jb250ZXh0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc2V0IHRoZSBpbnZhbGlkYXRpb24gY29udGV4dFxuICAgICAgICB0aGlzLl9pbnZhbGlkYXRpb25Db250ZXh0ID0gbnVsbDtcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiB3ZSBkb24ndCBoYXZlIGEgbGF5b3V0IG9yIGNvbnRlbnQsIG9yIHdlIGFyZVxuICAgICAgICAvLyBpbiB0aGUgbWlkZGxlIG9mIGFuIGFuaW1hdGVkIHNjcm9sbCB0cmFuc2l0aW9uLlxuICAgICAgICBpZiAoIXRoaXMubGF5b3V0IHx8ICF0aGlzLl9jb2xsZWN0aW9uIHx8IHRoaXMuX3Njcm9sbEFuaW1hdGlvbikgcmV0dXJuO1xuICAgICAgICBsZXQgc2Nyb2xsQW5jaG9yID0gdGhpcy5fZ2V0U2Nyb2xsQW5jaG9yKCk7XG4gICAgICAgIC8vIFRyaWdnZXIgdGhlIGJlZm9yZUxheW91dCBob29rLCBpZiBwcm92aWRlZFxuICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQuYmVmb3JlTGF5b3V0ID09PSBcImZ1bmN0aW9uXCIpIGNvbnRleHQuYmVmb3JlTGF5b3V0KCk7XG4gICAgICAgIC8vIFZhbGlkYXRlIHRoZSBsYXlvdXRcbiAgICAgICAgdGhpcy5sYXlvdXQudmFsaWRhdGUoY29udGV4dCk7XG4gICAgICAgIHRoaXMuX3NldENvbnRlbnRTaXplKHRoaXMubGF5b3V0LmdldENvbnRlbnRTaXplKCkpO1xuICAgICAgICAvLyBUcmlnZ2VyIHRoZSBhZnRlckxheW91dCBob29rLCBpZiBwcm92aWRlZFxuICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQuYWZ0ZXJMYXlvdXQgPT09IFwiZnVuY3Rpb25cIikgY29udGV4dC5hZnRlckxheW91dCgpO1xuICAgICAgICAvLyBBZGp1c3Qgc2Nyb2xsIHBvc2l0aW9uIGJhc2VkIG9uIHNjcm9sbCBhbmNob3IsIGFuZCBjb25zdHJhaW4uXG4gICAgICAgIC8vIElmIHRoZSBjb250ZW50IGNoYW5nZWQsIHNjcm9sbCB0byB0aGUgdG9wLlxuICAgICAgICBsZXQgdmlzaWJsZVJlY3QgPSB0aGlzLmdldFZpc2libGVSZWN0KCk7XG4gICAgICAgIGxldCByZXN0b3JlZFNjcm9sbEFuY2hvciA9IHRoaXMuX3Jlc3RvcmVTY3JvbGxBbmNob3Ioc2Nyb2xsQW5jaG9yLCBjb250ZXh0KTtcbiAgICAgICAgbGV0IGNvbnRlbnRPZmZzZXRYID0gY29udGV4dC5jb250ZW50Q2hhbmdlZCA/IDAgOiByZXN0b3JlZFNjcm9sbEFuY2hvci54O1xuICAgICAgICBsZXQgY29udGVudE9mZnNldFkgPSBjb250ZXh0LmNvbnRlbnRDaGFuZ2VkID8gMCA6IHJlc3RvcmVkU2Nyb2xsQW5jaG9yLnk7XG4gICAgICAgIGNvbnRlbnRPZmZzZXRYID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odGhpcy5jb250ZW50U2l6ZS53aWR0aCAtIHZpc2libGVSZWN0LndpZHRoLCBjb250ZW50T2Zmc2V0WCkpO1xuICAgICAgICBjb250ZW50T2Zmc2V0WSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMuY29udGVudFNpemUuaGVpZ2h0IC0gdmlzaWJsZVJlY3QuaGVpZ2h0LCBjb250ZW50T2Zmc2V0WSkpO1xuICAgICAgICBsZXQgaGFzTGF5b3V0VXBkYXRlcyA9IGZhbHNlO1xuICAgICAgICBpZiAoY29udGVudE9mZnNldFggIT09IHZpc2libGVSZWN0LnggfHwgY29udGVudE9mZnNldFkgIT09IHZpc2libGVSZWN0LnkpIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYW4gYW5pbWF0ZWQgcmVsYXlvdXQsIHdlIGRvIG5vdCBpbW1lZGlhdGVseSBzY3JvbGwgYmVjYXVzZSBpdCB3b3VsZCBiZSBqaXR0ZXJ5LlxuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBjdXJyZW50IGFuZCBuZXcgY29udGVudCBvZmZzZXRzLCBhbmQgYXBwbHkgaXQgdG8gdGhlXG4gICAgICAgICAgICAvLyBpbmRpdmlkdWFsIGNvbnRlbnQgaXRlbXMgaW5zdGVhZC4gQXQgdGhlIGVuZCBvZiB0aGUgYW5pbWF0aW9uLCB3ZSdsbCByZXNldCBhbmQgc2V0IHRoZVxuICAgICAgICAgICAgLy8gc2Nyb2xsIG9mZnNldCBmb3IgcmVhbC4gVGhpcyBlbnN1cmVzIGppdHRlci1mcmVlIGFuaW1hdGlvbiBzaW5jZSB3ZSBkb24ndCBuZWVkIHRvIHN5bmNcbiAgICAgICAgICAgIC8vIHRoZSBzY3JvbGwgYW5pbWF0aW9uIGFuZCB0aGUgY29udGVudCBhbmltYXRpb24uXG4gICAgICAgICAgICBpZiAoY29udGV4dC5hbmltYXRlZCB8fCAhdGhpcy5fYW5pbWF0ZWRDb250ZW50T2Zmc2V0LmlzT3JpZ2luKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hbmltYXRlZENvbnRlbnRPZmZzZXQueCArPSB2aXNpYmxlUmVjdC54IC0gY29udGVudE9mZnNldFg7XG4gICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZWRDb250ZW50T2Zmc2V0LnkgKz0gdmlzaWJsZVJlY3QueSAtIGNvbnRlbnRPZmZzZXRZO1xuICAgICAgICAgICAgICAgIGhhc0xheW91dFVwZGF0ZXMgPSB0aGlzLnVwZGF0ZVN1YnZpZXdzKGNvbnRleHQuY29udGVudENoYW5nZWQpO1xuICAgICAgICAgICAgfSBlbHNlIHRoaXMuX3NldENvbnRlbnRPZmZzZXQobmV3ICgwLCAkMzA0MWRiMzI5Njk0NWU2ZSRleHBvcnQkYmFmMjYxNDZhNDE0ZjI0YSkoY29udGVudE9mZnNldFgsIGNvbnRlbnRPZmZzZXRZKSk7XG4gICAgICAgIH0gZWxzZSBoYXNMYXlvdXRVcGRhdGVzID0gdGhpcy51cGRhdGVTdWJ2aWV3cyhjb250ZXh0LmNvbnRlbnRDaGFuZ2VkKTtcbiAgICAgICAgLy8gQXBwbHkgbGF5b3V0IGluZm9zLCB1bmxlc3MgdGhpcyBpcyBjb21pbmcgZnJvbSBhbiBhbmltYXRlZCB0cmFuc2FjdGlvblxuICAgICAgICBpZiAoIShjb250ZXh0LnRyYW5zYWN0aW9uICYmIGNvbnRleHQuYW5pbWF0ZWQpKSB0aGlzLl9hcHBseUxheW91dEluZm9zKCk7XG4gICAgICAgIC8vIFdhaXQgZm9yIGFuaW1hdGlvbnMsIGFuZCBhcHBseSB0aGUgYWZ0ZXJBbmltYXRpb24gaG9vaywgaWYgcHJvdmlkZWRcbiAgICAgICAgaWYgKGNvbnRleHQuYW5pbWF0ZWQgJiYgaGFzTGF5b3V0VXBkYXRlcykge1xuICAgICAgICAgICAgdGhpcy5fZW5hYmxlVHJhbnNpdGlvbnMoKTtcbiAgICAgICAgICAgIGxldCBkb25lID0gKCk9PntcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNhYmxlVHJhbnNpdGlvbnMoKTtcbiAgICAgICAgICAgICAgICAvLyBSZXNldCBzY3JvbGwgcG9zaXRpb24gYWZ0ZXIgYW5pbWF0aW9ucyAoc2VlIGFib3ZlIGNvbW1lbnQpLlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fYW5pbWF0ZWRDb250ZW50T2Zmc2V0LmlzT3JpZ2luKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBjb250ZW50IG9mZnNldCB0byBzY3JvbGwgdG8sIHRha2luZyBfYW5pbWF0ZWRDb250ZW50T2Zmc2V0IGludG8gYWNjb3VudC5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgeDogeCwgeTogeSB9ID0gdGhpcy5nZXRWaXNpYmxlUmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXNldEFuaW1hdGVkQ29udGVudE9mZnNldCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRDb250ZW50T2Zmc2V0KG5ldyAoMCwgJDMwNDFkYjMyOTY5NDVlNmUkZXhwb3J0JGJhZjI2MTQ2YTQxNGYyNGEpKHgsIHkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0LmFmdGVyQW5pbWF0aW9uID09PSBcImZ1bmN0aW9uXCIpIGNvbnRleHQuYWZ0ZXJBbmltYXRpb24oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBTb21ldGltZXMgdGhlIGFuaW1hdGlvbiB0YWtlcyBzbGlnaHRseSBsb25nZXIgdGhhbiBleHBlY3RlZC5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoZG9uZSwgdGhpcy50cmFuc2l0aW9uRHVyYXRpb24gKyAxMDApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb250ZXh0LmFmdGVyQW5pbWF0aW9uID09PSBcImZ1bmN0aW9uXCIpIGNvbnRleHQuYWZ0ZXJBbmltYXRpb24oKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIENvcnJlY3RzIERPTSBvcmRlciBvZiB2aXNpYmxlIHZpZXdzIHRvIG1hdGNoIGl0ZW0gb3JkZXIgb2YgY29sbGVjdGlvbi5cbiAgICovIF9jb3JyZWN0SXRlbU9yZGVyKCkge1xuICAgICAgICAvLyBEZWZlciB1bnRpbCBhZnRlciBzY3JvbGxpbmcgYW5kIGFuaW1hdGVkIHRyYW5zYWN0aW9ucyBhcmUgY29tcGxldGVcbiAgICAgICAgaWYgKHRoaXMuX2lzU2Nyb2xsaW5nIHx8IHRoaXMuX3RyYW5zYWN0aW9uKSByZXR1cm47XG4gICAgICAgIGZvciAobGV0IGtleSBvZiB0aGlzLl92aXNpYmxlTGF5b3V0SW5mb3Mua2V5cygpKXtcbiAgICAgICAgICAgIGxldCB2aWV3ID0gdGhpcy5fdmlzaWJsZVZpZXdzLmdldChrZXkpO1xuICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW4uZGVsZXRlKHZpZXcpO1xuICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW4uYWRkKHZpZXcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9lbmFibGVUcmFuc2l0aW9ucygpIHtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5iZWdpbkFuaW1hdGlvbnMoKTtcbiAgICB9XG4gICAgX2Rpc2FibGVUcmFuc2l0aW9ucygpIHtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5lbmRBbmltYXRpb25zKCk7XG4gICAgfVxuICAgIF9nZXRTY3JvbGxBbmNob3IoKSB7XG4gICAgICAgIGlmICghdGhpcy5hbmNob3JTY3JvbGxQb3NpdGlvbikgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCB2aXNpYmxlUmVjdCA9IHRoaXMuZ2V0VmlzaWJsZVJlY3QoKTtcbiAgICAgICAgLy8gQXNrIHRoZSBkZWxlZ2F0ZSB0byBwcm92aWRlIGEgc2Nyb2xsIGFuY2hvciwgaWYgcG9zc2libGVcbiAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUuZ2V0U2Nyb2xsQW5jaG9yKSB7XG4gICAgICAgICAgICBsZXQga2V5ID0gdGhpcy5kZWxlZ2F0ZS5nZXRTY3JvbGxBbmNob3IodmlzaWJsZVJlY3QpO1xuICAgICAgICAgICAgaWYgKGtleSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxheW91dEluZm8gPSB0aGlzLmxheW91dC5nZXRMYXlvdXRJbmZvKGtleSk7XG4gICAgICAgICAgICAgICAgbGV0IGNvcm5lciA9IGxheW91dEluZm8ucmVjdC5nZXRDb3JuZXJJblJlY3QodmlzaWJsZVJlY3QpO1xuICAgICAgICAgICAgICAgIGlmIChjb3JuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGtleSA9IGxheW91dEluZm8ua2V5O1xuICAgICAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gbGF5b3V0SW5mby5yZWN0W2Nvcm5lcl0ueSAtIHZpc2libGVSZWN0Lnk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dEluZm86IGxheW91dEluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3JuZXI6IGNvcm5lcixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gYW5jaG9yIHRoZSBzY3JvbGwgcG9zaXRpb24gaWYgaXQgaXMgYXQgdGhlIHRvcFxuICAgICAgICBpZiAodmlzaWJsZVJlY3QueSA9PT0gMCAmJiAhdGhpcy5hbmNob3JTY3JvbGxQb3NpdGlvbkF0VG9wKSByZXR1cm4gbnVsbDtcbiAgICAgICAgLy8gRmluZCBhIHZpZXcgd2l0aCBhIHZpc2libGUgY29ybmVyIHRoYXQgaGFzIHRoZSBzbWFsbGVzdCBkaXN0YW5jZSB0byB0aGUgdG9wIG9mIHRoZSBjb2xsZWN0aW9uIHZpZXdcbiAgICAgICAgbGV0IGNvcm5lckFuY2hvciA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IFtrZXksIHZpZXddIG9mIHRoaXMuX3Zpc2libGVWaWV3cyl7XG4gICAgICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IHZpZXcubGF5b3V0SW5mbztcbiAgICAgICAgICAgIGlmIChsYXlvdXRJbmZvICYmIGxheW91dEluZm8ucmVjdC5hcmVhID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBjb3JuZXIgPSBsYXlvdXRJbmZvLnJlY3QuZ2V0Q29ybmVySW5SZWN0KHZpc2libGVSZWN0KTtcbiAgICAgICAgICAgICAgICBpZiAoY29ybmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSBsYXlvdXRJbmZvLnJlY3RbY29ybmVyXS55IC0gdmlzaWJsZVJlY3QueTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb3JuZXJBbmNob3IgfHwgb2Zmc2V0IDwgY29ybmVyQW5jaG9yLm9mZnNldCkgY29ybmVyQW5jaG9yID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXRJbmZvOiBsYXlvdXRJbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29ybmVyOiBjb3JuZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29ybmVyQW5jaG9yO1xuICAgIH1cbiAgICBfcmVzdG9yZVNjcm9sbEFuY2hvcihzY3JvbGxBbmNob3IsIGNvbnRleHQpIHtcbiAgICAgICAgbGV0IGNvbnRlbnRPZmZzZXQgPSB0aGlzLmdldFZpc2libGVSZWN0KCk7XG4gICAgICAgIGlmIChzY3JvbGxBbmNob3IpIHtcbiAgICAgICAgICAgIHZhciBfY29udGV4dF90cmFuc2FjdGlvbjtcbiAgICAgICAgICAgIGxldCBmaW5hbEFuY2hvciA9ICgoX2NvbnRleHRfdHJhbnNhY3Rpb24gPSBjb250ZXh0LnRyYW5zYWN0aW9uKSA9PT0gbnVsbCB8fCBfY29udGV4dF90cmFuc2FjdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NvbnRleHRfdHJhbnNhY3Rpb24uYW5pbWF0ZWQpID8gY29udGV4dC50cmFuc2FjdGlvbi5maW5hbE1hcC5nZXQoc2Nyb2xsQW5jaG9yLmtleSkgOiB0aGlzLmxheW91dC5nZXRMYXlvdXRJbmZvKHNjcm9sbEFuY2hvci5sYXlvdXRJbmZvLmtleSk7XG4gICAgICAgICAgICBpZiAoZmluYWxBbmNob3IpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWRqdXN0bWVudCA9IGZpbmFsQW5jaG9yLnJlY3Rbc2Nyb2xsQW5jaG9yLmNvcm5lcl0ueSAtIGNvbnRlbnRPZmZzZXQueSAtIHNjcm9sbEFuY2hvci5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgY29udGVudE9mZnNldC55ICs9IGFkanVzdG1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRlbnRPZmZzZXQ7XG4gICAgfVxuICAgIGdldFZpc2libGVSZWN0KCkge1xuICAgICAgICBsZXQgdiA9IHRoaXMudmlzaWJsZVJlY3Q7XG4gICAgICAgIGxldCB4ID0gdi54IC0gdGhpcy5fYW5pbWF0ZWRDb250ZW50T2Zmc2V0Lng7XG4gICAgICAgIGxldCB5ID0gdi55IC0gdGhpcy5fYW5pbWF0ZWRDb250ZW50T2Zmc2V0Lnk7XG4gICAgICAgIHJldHVybiBuZXcgKDAsICQ2MDQyM2Y5MmM3ZjlhZDg3JGV4cG9ydCRjNzlmYzY0OTJmM2FmMTNkKSh4LCB5LCB2LndpZHRoLCB2LmhlaWdodCk7XG4gICAgfVxuICAgIGdldFZpc2libGVMYXlvdXRJbmZvcygpIHtcbiAgICAgICAgbGV0IHJlY3QgPSB0aGlzLnNob3VsZE92ZXJzY2FuID8gdGhpcy5fb3ZlcnNjYW5NYW5hZ2VyLmdldE92ZXJzY2FubmVkUmVjdCgpIDogdGhpcy5nZXRWaXNpYmxlUmVjdCgpO1xuICAgICAgICB0aGlzLl92aXNpYmxlTGF5b3V0SW5mb3MgPSB0aGlzLl9nZXRMYXlvdXRJbmZvTWFwKHJlY3QpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZUxheW91dEluZm9zO1xuICAgIH1cbiAgICBfZ2V0TGF5b3V0SW5mb01hcChyZWN0LCBjb3B5ID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGxheW91dEluZm9zID0gdGhpcy5sYXlvdXQuZ2V0VmlzaWJsZUxheW91dEluZm9zKHJlY3QpO1xuICAgICAgICBsZXQgbWFwID0gbmV3IE1hcDtcbiAgICAgICAgZm9yIChsZXQgbGF5b3V0SW5mbyBvZiBsYXlvdXRJbmZvcyl7XG4gICAgICAgICAgICBpZiAoY29weSkgbGF5b3V0SW5mbyA9IGxheW91dEluZm8uY29weSgpO1xuICAgICAgICAgICAgbWFwLnNldChsYXlvdXRJbmZvLmtleSwgbGF5b3V0SW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG4gICAgdXBkYXRlU3Vidmlld3MoZm9yY2VVcGRhdGUgPSBmYWxzZSkge1xuICAgICAgICBpZiAoIXRoaXMuX2NvbGxlY3Rpb24pIHJldHVybjtcbiAgICAgICAgbGV0IHZpc2libGVMYXlvdXRJbmZvcyA9IHRoaXMuZ2V0VmlzaWJsZUxheW91dEluZm9zKCk7XG4gICAgICAgIGxldCBjdXJyZW50bHlWaXNpYmxlID0gdGhpcy5fdmlzaWJsZVZpZXdzO1xuICAgICAgICBsZXQgdG9BZGQsIHRvUmVtb3ZlLCB0b1VwZGF0ZTtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIGZvcmNlIHVwZGF0ZSwgcmVtb3ZlIGFuZCByZS1hZGQgYWxsIHZpZXdzLlxuICAgICAgICAvLyBPdGhlcndpc2UsIGZpbmQgYW5kIHVwZGF0ZSB0aGUgZGlmZi5cbiAgICAgICAgaWYgKGZvcmNlVXBkYXRlKSB7XG4gICAgICAgICAgICB0b0FkZCA9IHZpc2libGVMYXlvdXRJbmZvcztcbiAgICAgICAgICAgIHRvUmVtb3ZlID0gY3VycmVudGx5VmlzaWJsZTtcbiAgICAgICAgICAgIHRvVXBkYXRlID0gbmV3IFNldCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgKHsgdG9BZGQ6IHRvQWRkLCB0b1JlbW92ZTogdG9SZW1vdmUsIHRvVXBkYXRlOiB0b1VwZGF0ZSB9ID0gKDAsICRmYzM2ZjlhMDQ2YTljZTc5JGV4cG9ydCRhY2FmOTZhMjc0MzgyNDZiKShjdXJyZW50bHlWaXNpYmxlLCB2aXNpYmxlTGF5b3V0SW5mb3MpKTtcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBvZiB0b1VwZGF0ZSl7XG4gICAgICAgICAgICAgICAgbGV0IHZpZXcgPSBjdXJyZW50bHlWaXNpYmxlLmdldChrZXkpO1xuICAgICAgICAgICAgICAgIGlmICghdmlldyB8fCAhdmlldy5sYXlvdXRJbmZvKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBsZXQgaXRlbSA9IHRoaXMuZ2V0SXRlbSh2aXNpYmxlTGF5b3V0SW5mb3MuZ2V0KGtleSkua2V5KTtcbiAgICAgICAgICAgICAgICBpZiAodmlldy5jb250ZW50ID09PSBpdGVtKSB0b1VwZGF0ZS5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHZpZXcgdHlwZSBjaGFuZ2VzLCBkZWxldGUgYW5kIHJlY3JlYXRlIHRoZSB2aWV3IGluc3RlYWQgb2YgdXBkYXRpbmdcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgcmV1c2VUeXBlOiByZXVzZVR5cGUgfSA9IHRoaXMuX2dldFJldXNlVHlwZSh2aWV3LmxheW91dEluZm8sIGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmlldy52aWV3VHlwZSAhPT0gcmV1c2VUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1VwZGF0ZS5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvQWRkLmFkZChrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9SZW1vdmUuYWRkKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSBhcmUgZG9uZSBpZiB0aGUgc2V0cyBhcmUgZXF1YWxcbiAgICAgICAgICAgIGlmICh0b0FkZC5zaXplID09PSAwICYmIHRvUmVtb3ZlLnNpemUgPT09IDAgJiYgdG9VcGRhdGUuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl90cmFuc2FjdGlvbikgdGhpcy5fYXBwbHlMYXlvdXRJbmZvcygpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUcmFjayB2aWV3cyB0aGF0IHNob3VsZCBiZSByZW1vdmVkLiBUaGV5IGFyZSBub3QgcmVtb3ZlZCBmcm9tXG4gICAgICAgIC8vIHRoZSBET00gaW1tZWRpYXRlbHksIHNpbmNlIHdlIG1heSByZXVzZSBhbmQgbmVlZCB0byByZS1pbnNlcnRcbiAgICAgICAgLy8gdGhlbSBiYWNrIGludG8gdGhlIERPTSBhbnl3YXkuXG4gICAgICAgIGxldCByZW1vdmVkID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGxldCBrZXkgb2YgdG9SZW1vdmUua2V5cygpKXtcbiAgICAgICAgICAgIGxldCB2aWV3ID0gdGhpcy5fdmlzaWJsZVZpZXdzLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKHZpZXcpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVkLmFkZCh2aWV3KTtcbiAgICAgICAgICAgICAgICB0aGlzLl92aXNpYmxlVmlld3MuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGluIHRoZSBtaWRkbGUgb2YgYSB0cmFuc2FjdGlvbiwgd2FpdCB1bnRpbCB0aGUgZW5kXG4gICAgICAgICAgICAgICAgLy8gb2YgdGhlIGFuaW1hdGlvbnMgdG8gcmVtb3ZlIHRoZSB2aWV3cyBmcm9tIHRoZSBET00uIEFsc28gbWVhbnNcbiAgICAgICAgICAgICAgICAvLyB3ZSBjYW4ndCByZXVzZSB0aG9zZSB2aWV3cyBpbW1lZGlhdGVseS5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdHJhbnNhY3Rpb24pIHRoaXMuX3RyYW5zYWN0aW9uLnRvUmVtb3ZlLnNldChrZXksIHZpZXcpO1xuICAgICAgICAgICAgICAgIGVsc2UgdGhpcy5yZXVzZVZpZXcodmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQga2V5IG9mIHRvQWRkLmtleXMoKSl7XG4gICAgICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IHZpc2libGVMYXlvdXRJbmZvcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIGxldCB2aWV3O1xuICAgICAgICAgICAgLy8gSWYgd2UncmUgaW4gYSB0cmFuc2FjdGlvbiwgYW5kIGEgbGF5b3V0IGNoYW5nZSBoYXBwZW5zXG4gICAgICAgICAgICAvLyBkdXJpbmcgdGhlIGFuaW1hdGlvbnMgc3VjaCB0aGF0IGEgdmlldyB0aGF0IHdhcyBnb2luZ1xuICAgICAgICAgICAgLy8gdG8gYmUgcmVtb3ZlZCBpcyBub3cgbm90LCB3ZSBkb24ndCBjcmVhdGUgYSBuZXcgdmlld1xuICAgICAgICAgICAgLy8gc2luY2UgdGhlIG9sZCBvbmUgaXMgc3RpbGwgaW4gdGhlIERPTSwgbWFya2VkIGFzIHRvUmVtb3ZlLlxuICAgICAgICAgICAgaWYgKHRoaXMuX3RyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdHJhbnNhY3Rpb24sIGdldCBpbml0aWFsIGxheW91dCBhdHRyaWJ1dGVzIGZvciB0aGUgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RyYW5zYWN0aW9uLmluaXRpYWxMYXlvdXRJbmZvLmhhcyhrZXkpKSBsYXlvdXRJbmZvID0gdGhpcy5fdHJhbnNhY3Rpb24uaW5pdGlhbExheW91dEluZm8uZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgdmlldyA9IHRoaXMuX3RyYW5zYWN0aW9uLnRvUmVtb3ZlLmdldChrZXkpO1xuICAgICAgICAgICAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zYWN0aW9uLnRvUmVtb3ZlLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hcHBseUxheW91dEluZm8odmlldywgbGF5b3V0SW5mbyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF2aWV3KSB7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIG9yIHJldXNlIGEgdmlldyBmb3IgdGhpcyByb3dcbiAgICAgICAgICAgICAgICB2aWV3ID0gdGhpcy5nZXRSZXVzYWJsZVZpZXcobGF5b3V0SW5mbyk7XG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSB2aWV3IHRvIHRoZSBET00gaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgaWYgKCFyZW1vdmVkLmhhcyh2aWV3KSkgdGhpcy5fY2hpbGRyZW4uYWRkKHZpZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdmlzaWJsZVZpZXdzLnNldChrZXksIHZpZXcpO1xuICAgICAgICAgICAgcmVtb3ZlZC5kZWxldGUodmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQga2V5IG9mIHRvVXBkYXRlKXtcbiAgICAgICAgICAgIGxldCB2aWV3ID0gY3VycmVudGx5VmlzaWJsZS5nZXQoa2V5KTtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVkQ29udGVudC5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclZpZXcodmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSByZW1haW5pbmcgcm93cyB0byBkZWxldGUgZnJvbSB0aGUgRE9NXG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNhY3Rpb24pIHRoaXMucmVtb3ZlVmlld3MocmVtb3ZlZCk7XG4gICAgICAgIHRoaXMuX2NvcnJlY3RJdGVtT3JkZXIoKTtcbiAgICAgICAgdGhpcy5fZmx1c2hWaXNpYmxlVmlld3MoKTtcbiAgICAgICAgbGV0IGhhc0xheW91dFVwZGF0ZXMgPSB0aGlzLl90cmFuc2FjdGlvbiAmJiAodG9BZGQuc2l6ZSA+IDAgfHwgdG9SZW1vdmUuc2l6ZSA+IDAgfHwgdGhpcy5faGFzTGF5b3V0VXBkYXRlcygpKTtcbiAgICAgICAgaWYgKGhhc0xheW91dFVwZGF0ZXMpIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKT0+e1xuICAgICAgICAgICAgLy8gSWYgd2UncmUgaW4gYSB0cmFuc2FjdGlvbiwgYXBwbHkgYW5pbWF0aW9ucyB0byB2aXNpYmxlIHZpZXdzXG4gICAgICAgICAgICAvLyBhbmQgXCJ0byBiZSByZW1vdmVkXCIgdmlld3MsIHdoaWNoIGFuaW1hdGUgb2ZmIHNjcmVlbi5cbiAgICAgICAgICAgIGlmICh0aGlzLl90cmFuc2FjdGlvbikgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpPT50aGlzLl9hcHBseUxheW91dEluZm9zKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGhhc0xheW91dFVwZGF0ZXM7XG4gICAgfVxuICAgIGFmdGVyUmVuZGVyKCkge1xuICAgICAgICBpZiAodGhpcy5fdHJhbnNhY3Rpb25RdWV1ZS5sZW5ndGggPiAwKSB0aGlzLl9wcm9jZXNzVHJhbnNhY3Rpb25RdWV1ZSgpO1xuICAgICAgICBlbHNlIGlmICh0aGlzLl9pbnZhbGlkYXRpb25Db250ZXh0KSB0aGlzLnJlbGF5b3V0Tm93KCk7XG4gICAgICAgIGlmICh0aGlzLnNob3VsZE92ZXJzY2FuKSB0aGlzLl9vdmVyc2Nhbk1hbmFnZXIuY29sbGVjdE1ldHJpY3MoKTtcbiAgICB9XG4gICAgX2ZsdXNoVmlzaWJsZVZpZXdzKCkge1xuICAgICAgICAvLyBDb2xsZWN0aW9uVmlydHVhbGl6ZXIgZGVhbHMgd2l0aCBhIGZsYXR0ZW5lZCBzZXQgb2YgTGF5b3V0SW5mb3MsIGJ1dCB0aGV5IGNhbiByZXByZXNlbnQgaGVpcmFyY2h5XG4gICAgICAgIC8vIGJ5IHJlZmVyZW5jaW5nIGEgcGFyZW50S2V5LiBKdXN0IGJlZm9yZSByZW5kZXJpbmcgdGhlIHZpc2libGUgdmlld3MsIHdlIHJlYnVpbGQgdGhpcyBoZWlyYXJjaHlcbiAgICAgICAgLy8gYnkgY3JlYXRpbmcgYSBtYXBwaW5nIG9mIHZpZXdzIGJ5IHBhcmVudCBrZXkgYW5kIHJlY3Vyc2l2ZWx5IGNhbGxpbmcgdGhlIGRlbGVnYXRlJ3MgcmVuZGVyV3JhcHBlclxuICAgICAgICAvLyBtZXRob2QgdG8gYnVpbGQgdGhlIGZpbmFsIHRyZWUuXG4gICAgICAgIGxldCB2aWV3c0J5UGFyZW50S2V5ID0gbmV3IE1hcChbXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBbXVxuICAgICAgICAgICAgXVxuICAgICAgICBdKTtcbiAgICAgICAgZm9yIChsZXQgdmlldyBvZiB0aGlzLl9jaGlsZHJlbil7XG4gICAgICAgICAgICB2YXIgX3ZpZXdfbGF5b3V0SW5mbywgX3ZpZXdzQnlQYXJlbnRLZXlfZ2V0LCBfdmlld19sYXlvdXRJbmZvMSwgX3ZpZXdfbGF5b3V0SW5mbzIsIF92aWV3X2xheW91dEluZm8zO1xuICAgICAgICAgICAgaWYgKCgoX3ZpZXdfbGF5b3V0SW5mbyA9IHZpZXcubGF5b3V0SW5mbykgPT09IG51bGwgfHwgX3ZpZXdfbGF5b3V0SW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3ZpZXdfbGF5b3V0SW5mby5wYXJlbnRLZXkpICE9IG51bGwgJiYgIXZpZXdzQnlQYXJlbnRLZXkuaGFzKHZpZXcubGF5b3V0SW5mby5wYXJlbnRLZXkpKSB2aWV3c0J5UGFyZW50S2V5LnNldCh2aWV3LmxheW91dEluZm8ucGFyZW50S2V5LCBbXSk7XG4gICAgICAgICAgICAoX3ZpZXdzQnlQYXJlbnRLZXlfZ2V0ID0gdmlld3NCeVBhcmVudEtleS5nZXQoKF92aWV3X2xheW91dEluZm8xID0gdmlldy5sYXlvdXRJbmZvKSA9PT0gbnVsbCB8fCBfdmlld19sYXlvdXRJbmZvMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3ZpZXdfbGF5b3V0SW5mbzEucGFyZW50S2V5KSkgPT09IG51bGwgfHwgX3ZpZXdzQnlQYXJlbnRLZXlfZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdmlld3NCeVBhcmVudEtleV9nZXQucHVzaCh2aWV3KTtcbiAgICAgICAgICAgIGlmICghdmlld3NCeVBhcmVudEtleS5oYXMoKF92aWV3X2xheW91dEluZm8yID0gdmlldy5sYXlvdXRJbmZvKSA9PT0gbnVsbCB8fCBfdmlld19sYXlvdXRJbmZvMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3ZpZXdfbGF5b3V0SW5mbzIua2V5KSkgdmlld3NCeVBhcmVudEtleS5zZXQoKF92aWV3X2xheW91dEluZm8zID0gdmlldy5sYXlvdXRJbmZvKSA9PT0gbnVsbCB8fCBfdmlld19sYXlvdXRJbmZvMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3ZpZXdfbGF5b3V0SW5mbzMua2V5LCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJ1aWxkVHJlZSA9IChwYXJlbnQsIHZpZXdzKT0+dmlld3MubWFwKCh2aWV3KT0+e1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZHJlbiA9IHZpZXdzQnlQYXJlbnRLZXkuZ2V0KHZpZXcubGF5b3V0SW5mby5rZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLnJlbmRlcldyYXBwZXIocGFyZW50LCB2aWV3LCBjaGlsZHJlbiwgKGNoaWxkVmlld3MpPT5idWlsZFRyZWUodmlldywgY2hpbGRWaWV3cykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IGJ1aWxkVHJlZShudWxsLCB2aWV3c0J5UGFyZW50S2V5LmdldChudWxsKSk7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUuc2V0VmlzaWJsZVZpZXdzKGNoaWxkcmVuKTtcbiAgICB9XG4gICAgX2FwcGx5TGF5b3V0SW5mbyh2aWV3LCBsYXlvdXRJbmZvKSB7XG4gICAgICAgIGlmICh2aWV3LmxheW91dEluZm8gPT09IGxheW91dEluZm8pIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmlldy5sYXlvdXRJbmZvID0gbGF5b3V0SW5mbztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIF9hcHBseUxheW91dEluZm9zKCkge1xuICAgICAgICBsZXQgdXBkYXRlZCA9IGZhbHNlO1xuICAgICAgICAvLyBBcHBseSBsYXlvdXQgaW5mb3MgdG8gdmlzaWJsZSB2aWV3c1xuICAgICAgICBmb3IgKGxldCB2aWV3IG9mIHRoaXMuX3Zpc2libGVWaWV3cy52YWx1ZXMoKSl7XG4gICAgICAgICAgICBsZXQgY3VyID0gdmlldy5sYXlvdXRJbmZvO1xuICAgICAgICAgICAgaWYgKChjdXIgPT09IG51bGwgfHwgY3VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXIua2V5KSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxheW91dEluZm8gPSB0aGlzLmxheW91dC5nZXRMYXlvdXRJbmZvKGN1ci5rZXkpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hcHBseUxheW91dEluZm8odmlldywgbGF5b3V0SW5mbykpIHVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFwcGx5IGZpbmFsIGxheW91dCBpbmZvcyBmb3Igdmlld3MgdGhhdCB3aWxsIGJlIHJlbW92ZWRcbiAgICAgICAgaWYgKHRoaXMuX3RyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB2aWV3IG9mIHRoaXMuX3RyYW5zYWN0aW9uLnRvUmVtb3ZlLnZhbHVlcygpKXtcbiAgICAgICAgICAgICAgICBsZXQgY3VyID0gdmlldy5sYXlvdXRJbmZvO1xuICAgICAgICAgICAgICAgIGlmICgoY3VyID09PSBudWxsIHx8IGN1ciA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VyLmtleSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IHRoaXMubGF5b3V0LmdldExheW91dEluZm8oY3VyLmtleSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hcHBseUxheW91dEluZm8odmlldywgbGF5b3V0SW5mbykpIHVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IHZpZXcgb2YgdGhpcy5fdHJhbnNhY3Rpb24ucmVtb3ZlZC52YWx1ZXMoKSl7XG4gICAgICAgICAgICAgICAgbGV0IGN1ciA9IHZpZXcubGF5b3V0SW5mbztcbiAgICAgICAgICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IHRoaXMuX3RyYW5zYWN0aW9uLmZpbmFsTGF5b3V0SW5mby5nZXQoY3VyLmtleSkgfHwgY3VyO1xuICAgICAgICAgICAgICAgIGxheW91dEluZm8gPSB0aGlzLmxheW91dC5nZXRGaW5hbExheW91dEluZm8obGF5b3V0SW5mby5jb3B5KCkpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hcHBseUxheW91dEluZm8odmlldywgbGF5b3V0SW5mbykpIHVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVkKSB0aGlzLl9mbHVzaFZpc2libGVWaWV3cygpO1xuICAgIH1cbiAgICBfaGFzTGF5b3V0VXBkYXRlcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc2FjdGlvbikgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCB2aWV3IG9mIHRoaXMuX3Zpc2libGVWaWV3cy52YWx1ZXMoKSl7XG4gICAgICAgICAgICBsZXQgY3VyID0gdmlldy5sYXlvdXRJbmZvO1xuICAgICAgICAgICAgaWYgKCFjdXIpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgbGV0IGxheW91dEluZm8gPSB0aGlzLmxheW91dC5nZXRMYXlvdXRJbmZvKGN1ci5rZXkpO1xuICAgICAgICAgICAgaWYgKC8vIFVzZXMgZXF1YWxzIHJhdGhlciB0aGFuIHBvaW50RXF1YWxzIHNvIHRoYXQgd2lkdGgvaGVpZ2h0IGNoYW5nZXMgYXJlIHRha2VuIGludG8gYWNjb3VudFxuICAgICAgICAgICAgIWN1ci5yZWN0LmVxdWFscyhsYXlvdXRJbmZvLnJlY3QpIHx8IGN1ci5vcGFjaXR5ICE9PSBsYXlvdXRJbmZvLm9wYWNpdHkgfHwgY3VyLnRyYW5zZm9ybSAhPT0gbGF5b3V0SW5mby50cmFuc2Zvcm0pIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV1c2VWaWV3KHZpZXcpIHtcbiAgICAgICAgdmlldy5wcmVwYXJlRm9yUmV1c2UoKTtcbiAgICAgICAgdGhpcy5fcmV1c2FibGVWaWV3c1t2aWV3LnZpZXdUeXBlXS5wdXNoKHZpZXcpO1xuICAgIH1cbiAgICByZW1vdmVWaWV3cyh0b1JlbW92ZSkge1xuICAgICAgICBmb3IgKGxldCB2aWV3IG9mIHRvUmVtb3ZlKXRoaXMuX2NoaWxkcmVuLmRlbGV0ZSh2aWV3KTtcbiAgICB9XG4gICAgdXBkYXRlSXRlbVNpemUoa2V5LCBzaXplKSB7XG4gICAgICAgIC8vIFRPRE86IHdlIHNob3VsZCBiZSBhYmxlIHRvIGludmFsaWRhdGUgYSBzaW5nbGUgaW5kZXggcGF0aFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmICghdGhpcy5sYXlvdXQudXBkYXRlSXRlbVNpemUpIHJldHVybjtcbiAgICAgICAgLy8gSWYgdGhlIHNjcm9sbCBwb3NpdGlvbiBpcyBjdXJyZW50bHkgYW5pbWF0aW5nLCBhZGQgdGhlIHVwZGF0ZVxuICAgICAgICAvLyB0byBhIHF1ZXVlIHRvIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgYW5pbWF0aW9uIGlzIGNvbXBsZXRlLlxuICAgICAgICBpZiAodGhpcy5fc2Nyb2xsQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9zaXplVXBkYXRlUXVldWUuc2V0KGtleSwgc2l6ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBsZXQgY2hhbmdlZCA9IHRoaXMubGF5b3V0LnVwZGF0ZUl0ZW1TaXplKGtleSwgc2l6ZSk7XG4gICAgICAgIGlmIChjaGFuZ2VkKSB0aGlzLnJlbGF5b3V0KCk7XG4gICAgfVxuICAgIHN0YXJ0U2Nyb2xsaW5nKCkge1xuICAgICAgICB0aGlzLl9pc1Njcm9sbGluZyA9IHRydWU7XG4gICAgfVxuICAgIGVuZFNjcm9sbGluZygpIHtcbiAgICAgICAgdGhpcy5faXNTY3JvbGxpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY29ycmVjdEl0ZW1PcmRlcigpO1xuICAgICAgICB0aGlzLl9mbHVzaFZpc2libGVWaWV3cygpO1xuICAgIH1cbiAgICBfcmVzZXRBbmltYXRlZENvbnRlbnRPZmZzZXQoKSB7XG4gICAgICAgIC8vIFJlc2V0IHRoZSBhbmltYXRlZCBjb250ZW50IG9mZnNldCBvZiBzdWJ2aWV3cy4gU2VlIGNvbW1lbnQgaW4gcmVsYXlvdXROb3cgZm9yIGRldGFpbHMuXG4gICAgICAgIGlmICghdGhpcy5fYW5pbWF0ZWRDb250ZW50T2Zmc2V0LmlzT3JpZ2luKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2FuaW1hdGVkQ29udGVudE9mZnNldCA9IG5ldyAoMCwgJDMwNDFkYjMyOTY5NDVlNmUkZXhwb3J0JGJhZjI2MTQ2YTQxNGYyNGEpKDAsIDApO1xuICAgICAgICAgICAgdGhpcy5fYXBwbHlMYXlvdXRJbmZvcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgKiBTY3JvbGxzIHRoZSBpdGVtIHdpdGggdGhlIGdpdmVuIGtleSBpbnRvIHZpZXcsIG9wdGlvbmFsbHkgd2l0aCBhbiBhbmltYXRpb24uXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgaXRlbSB0byBzY3JvbGwgaW50byB2aWV3LlxuICAgKiBAcGFyYW0gZHVyYXRpb24gVGhlIGR1cmF0aW9uIG9mIHRoZSBzY3JvbGwgYW5pbWF0aW9uLlxuICAgKi8gc2Nyb2xsVG9JdGVtKGtleSwgb3B0aW9ucykge1xuICAgICAgICAvLyBrZXkgY2FuIGJlIDAsIHNvIGNoZWNrIGlmIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgIGlmIChrZXkgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IHRoaXMubGF5b3V0LmdldExheW91dEluZm8oa2V5KTtcbiAgICAgICAgaWYgKCFsYXlvdXRJbmZvKSByZXR1cm47XG4gICAgICAgIGxldCB7IGR1cmF0aW9uOiBkdXJhdGlvbiA9IDMwMCwgc2hvdWxkU2Nyb2xsWDogc2hvdWxkU2Nyb2xsWCA9IHRydWUsIHNob3VsZFNjcm9sbFk6IHNob3VsZFNjcm9sbFkgPSB0cnVlLCBvZmZzZXRYOiBvZmZzZXRYID0gMCwgb2Zmc2V0WTogb2Zmc2V0WSA9IDAgfSA9IG9wdGlvbnM7XG4gICAgICAgIGxldCB4ID0gdGhpcy52aXNpYmxlUmVjdC54O1xuICAgICAgICBsZXQgeSA9IHRoaXMudmlzaWJsZVJlY3QueTtcbiAgICAgICAgbGV0IG1pblggPSBsYXlvdXRJbmZvLnJlY3QueCAtIG9mZnNldFg7XG4gICAgICAgIGxldCBtaW5ZID0gbGF5b3V0SW5mby5yZWN0LnkgLSBvZmZzZXRZO1xuICAgICAgICBsZXQgbWF4WCA9IHggKyB0aGlzLnZpc2libGVSZWN0LndpZHRoO1xuICAgICAgICBsZXQgbWF4WSA9IHkgKyB0aGlzLnZpc2libGVSZWN0LmhlaWdodDtcbiAgICAgICAgaWYgKHNob3VsZFNjcm9sbFgpIHtcbiAgICAgICAgICAgIGlmIChtaW5YIDw9IHggfHwgbWF4WCA9PT0gMCkgeCA9IG1pblg7XG4gICAgICAgICAgICBlbHNlIGlmIChsYXlvdXRJbmZvLnJlY3QubWF4WCA+IG1heFgpIHggKz0gbGF5b3V0SW5mby5yZWN0Lm1heFggLSBtYXhYO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRTY3JvbGxZKSB7XG4gICAgICAgICAgICBpZiAobWluWSA8PSB5IHx8IG1heFkgPT09IDApIHkgPSBtaW5ZO1xuICAgICAgICAgICAgZWxzZSBpZiAobGF5b3V0SW5mby5yZWN0Lm1heFkgPiBtYXhZKSB5ICs9IGxheW91dEluZm8ucmVjdC5tYXhZIC0gbWF4WTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxUbyhuZXcgKDAsICQzMDQxZGIzMjk2OTQ1ZTZlJGV4cG9ydCRiYWYyNjE0NmE0MTRmMjRhKSh4LCB5KSwgZHVyYXRpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICogUGVyZm9ybXMgYW4gYW5pbWF0ZWQgc2Nyb2xsIHRvIHRoZSBnaXZlbiBvZmZzZXQuXG4gICAqIEBwYXJhbSBvZmZzZXQgLSBUaGUgb2Zmc2V0IHRvIHNjcm9sbCB0by5cbiAgICogQHBhcmFtIGR1cmF0aW9uIFRoZSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBhbmltYXRpb24gaXMgY29tcGxldGUuXG4gICAqLyBzY3JvbGxUbyhvZmZzZXQsIGR1cmF0aW9uID0gMzAwKSB7XG4gICAgICAgIC8vIENhbmNlbCB0aGUgY3VycmVudCBzY3JvbGwgYW5pbWF0aW9uXG4gICAgICAgIGlmICh0aGlzLl9zY3JvbGxBbmltYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbEFuaW1hdGlvbi5jYW5jZWwoKTtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbEFuaW1hdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IHRoZSBjb250ZW50IG9mZnNldCBzeW5jaHJvbm91c2x5IGlmIHRoZSBkdXJhdGlvbiBpcyB6ZXJvXG4gICAgICAgIGlmIChkdXJhdGlvbiA8PSAwIHx8IHRoaXMudmlzaWJsZVJlY3QucG9pbnRFcXVhbHMob2Zmc2V0KSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0Q29udGVudE9mZnNldChvZmZzZXQpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhcnRTY3JvbGxpbmcoKTtcbiAgICAgICAgdGhpcy5fc2Nyb2xsQW5pbWF0aW9uID0gKDAsICQzZWIxMzFkY2YzN2FkNWY4JGV4cG9ydCRkYzBiNjM3MjA3ODgwOTBjKSh0aGlzLnZpc2libGVSZWN0LCBvZmZzZXQsIGR1cmF0aW9uLCAoMCwgJDNlYjEzMWRjZjM3YWQ1ZjgkZXhwb3J0JDU3NjM2YmI0M2IxY2NiYjApLCAob2Zmc2V0KT0+e1xuICAgICAgICAgICAgdGhpcy5fc2V0Q29udGVudE9mZnNldChvZmZzZXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc2Nyb2xsQW5pbWF0aW9uLnRoZW4oKCk9PntcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbEFuaW1hdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAvLyBQcm9jZXNzIHZpZXcgc2l6ZSB1cGRhdGVzIHRoYXQgb2NjdXJyZWQgZHVyaW5nIHRoZSBhbmltYXRpb24uXG4gICAgICAgICAgICAvLyBPbmx5IHZpZXdzIHRoYXQgYXJlIHN0aWxsIHZpc2libGUgd2lsbCBiZSBhY3R1YWxseSB1cGRhdGVkLlxuICAgICAgICAgICAgZm9yIChsZXQgW2tleSwgc2l6ZV0gb2YgdGhpcy5fc2l6ZVVwZGF0ZVF1ZXVlKXRoaXMudXBkYXRlSXRlbVNpemUoa2V5LCBzaXplKTtcbiAgICAgICAgICAgIHRoaXMuX3NpemVVcGRhdGVRdWV1ZS5jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy5yZWxheW91dCgpO1xuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc1RyYW5zYWN0aW9uUXVldWUoKTtcbiAgICAgICAgICAgIHRoaXMuZW5kU2Nyb2xsaW5nKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5fc2Nyb2xsQW5pbWF0aW9uO1xuICAgIH1cbiAgICBfcnVuVHJhbnNhY3Rpb24oYWN0aW9uLCBhbmltYXRlZCkge1xuICAgICAgICB0aGlzLl9zdGFydFRyYW5zYWN0aW9uKCk7XG4gICAgICAgIGlmICh0aGlzLl9uZXh0VHJhbnNhY3Rpb24pIHRoaXMuX25leHRUcmFuc2FjdGlvbi5hY3Rpb25zLnB1c2goYWN0aW9uKTtcbiAgICAgICAgdGhpcy5fZW5kVHJhbnNhY3Rpb24oYW5pbWF0ZWQpO1xuICAgIH1cbiAgICBfc3RhcnRUcmFuc2FjdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9uZXh0VHJhbnNhY3Rpb24pIHRoaXMuX25leHRUcmFuc2FjdGlvbiA9IG5ldyAoMCwgJDhlMTM1ZTUzMWQ4ZGNiNjYkZXhwb3J0JGZlYmM1NTczYzc1Y2VmYjApO1xuICAgICAgICB0aGlzLl9uZXh0VHJhbnNhY3Rpb24ubGV2ZWwrKztcbiAgICB9XG4gICAgX2VuZFRyYW5zYWN0aW9uKGFuaW1hdGVkKSB7XG4gICAgICAgIGlmICghdGhpcy5fbmV4dFRyYW5zYWN0aW9uKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIFNhdmUgd2hldGhlciB0aGUgdHJhbnNhY3Rpb24gc2hvdWxkIGJlIGFuaW1hdGVkLlxuICAgICAgICBpZiAoYW5pbWF0ZWQgIT0gbnVsbCkgdGhpcy5fbmV4dFRyYW5zYWN0aW9uLmFuaW1hdGVkID0gYW5pbWF0ZWQ7XG4gICAgICAgIC8vIElmIHdlIGhhdmVuJ3QgcmVhY2hlZCBsZXZlbCAwLCB3ZSBhcmUgc3RpbGwgaW4gYVxuICAgICAgICAvLyBuZXN0ZWQgdHJhbnNhY3Rpb24uIFdhaXQgZm9yIHRoZSBwYXJlbnQgdG8gZW5kLlxuICAgICAgICBpZiAoLS10aGlzLl9uZXh0VHJhbnNhY3Rpb24ubGV2ZWwgPiAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIERvIG5vdGhpbmcgZm9yIGVtcHR5IHRyYW5zYWN0aW9uc1xuICAgICAgICBpZiAodGhpcy5fbmV4dFRyYW5zYWN0aW9uLmFjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9uZXh0VHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIERlZmF1bHQgYW5pbWF0aW9ucyB0byB0cnVlXG4gICAgICAgIGlmICh0aGlzLl9uZXh0VHJhbnNhY3Rpb24uYW5pbWF0ZWQgPT0gbnVsbCkgdGhpcy5fbmV4dFRyYW5zYWN0aW9uLmFuaW1hdGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gRW5xdWV1ZSB0aGUgdHJhbnNhY3Rpb25cbiAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb25RdWV1ZS5wdXNoKHRoaXMuX25leHRUcmFuc2FjdGlvbik7XG4gICAgICAgIHRoaXMuX25leHRUcmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBfcHJvY2Vzc1RyYW5zYWN0aW9uUXVldWUoKSB7XG4gICAgICAgIC8vIElmIHRoZSBjdXJyZW50IHRyYW5zYWN0aW9uIGlzIGFuaW1hdGluZywgd2FpdCB1bnRpbCB0aGUgZW5kXG4gICAgICAgIC8vIHRvIHByb2Nlc3MgdGhlIG5leHQgdHJhbnNhY3Rpb24uXG4gICAgICAgIGlmICh0aGlzLl90cmFuc2FjdGlvbiB8fCB0aGlzLl9zY3JvbGxBbmltYXRpb24pIHJldHVybjtcbiAgICAgICAgbGV0IG5leHQgPSB0aGlzLl90cmFuc2FjdGlvblF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIGlmIChuZXh0KSB0aGlzLl9wZXJmb3JtVHJhbnNhY3Rpb24obmV4dCk7XG4gICAgfVxuICAgIF9nZXRDb250ZW50UmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAoMCwgJDYwNDIzZjkyYzdmOWFkODckZXhwb3J0JGM3OWZjNjQ5MmYzYWYxM2QpKDAsIDAsIHRoaXMuY29udGVudFNpemUud2lkdGgsIHRoaXMuY29udGVudFNpemUuaGVpZ2h0KTtcbiAgICB9XG4gICAgX3BlcmZvcm1UcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICB0aGlzLl90cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uO1xuICAgICAgICB0aGlzLnJlbGF5b3V0Tm93KHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvbixcbiAgICAgICAgICAgIGFuaW1hdGVkOiB0cmFuc2FjdGlvbi5hbmltYXRlZCxcbiAgICAgICAgICAgIGJlZm9yZUxheW91dDogKCk9PntcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGluaXRpYWwgbGF5b3V0IGluZm9zIGZvciBhbGwgdmlld3MgYmVmb3JlIHRoZSB1cGRhdGVzXG4gICAgICAgICAgICAgICAgLy8gc28gd2UgY2FuIGZpZ3VyZSBvdXQgd2hpY2ggdmlld3MgdG8gYWRkIGFuZCByZW1vdmUuXG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmFuaW1hdGVkKSB0cmFuc2FjdGlvbi5pbml0aWFsTWFwID0gdGhpcy5fZ2V0TGF5b3V0SW5mb01hcCh0aGlzLl9nZXRDb250ZW50UmVjdCgpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAvLyBBcHBseSB0aGUgYWN0aW9ucyB0aGF0IG9jY3VycmVkIGR1cmluZyB0aGlzIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYWN0aW9uIG9mIHRyYW5zYWN0aW9uLmFjdGlvbnMpYWN0aW9uKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWZ0ZXJMYXlvdXQ6ICgpPT57XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBmaW5hbCBsYXlvdXQgaW5mb3MgYWZ0ZXIgdGhlIHVwZGF0ZXNcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNhY3Rpb24uYW5pbWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uZmluYWxNYXAgPSB0aGlzLl9nZXRMYXlvdXRJbmZvTWFwKHRoaXMuX2dldENvbnRlbnRSZWN0KCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXR1cFRyYW5zYWN0aW9uQW5pbWF0aW9ucyh0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHRoaXMuX3RyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZnRlckFuaW1hdGlvbjogKCk9PntcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYW5kIHJldXNlIHZpZXdzIHdoZW4gYW5pbWF0aW9ucyBhcmUgZG9uZVxuICAgICAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbi50b1JlbW92ZS5zaXplID4gMCB8fCB0cmFuc2FjdGlvbi5yZW1vdmVkLnNpemUgPiAwKSBmb3IgKGxldCB2aWV3IG9mICgwLCAkZmMzNmY5YTA0NmE5Y2U3OSRleHBvcnQkY2ZjMTQwODhkZmVmY2U1ZikodHJhbnNhY3Rpb24udG9SZW1vdmUudmFsdWVzKCksIHRyYW5zYWN0aW9uLnJlbW92ZWQudmFsdWVzKCkpKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW4uZGVsZXRlKHZpZXcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJldXNlVmlldyh2aWV3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBET00gb3JkZXIgaXMgY29ycmVjdCBmb3IgYWNjZXNzaWJpbGl0eSBhZnRlciBhbmltYXRpb25zIGFyZSBjb21wbGV0ZVxuICAgICAgICAgICAgICAgIHRoaXMuX2NvcnJlY3RJdGVtT3JkZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9mbHVzaFZpc2libGVWaWV3cygpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NUcmFuc2FjdGlvblF1ZXVlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfc2V0dXBUcmFuc2FjdGlvbkFuaW1hdGlvbnModHJhbnNhY3Rpb24pIHtcbiAgICAgICAgbGV0IHsgaW5pdGlhbE1hcDogaW5pdGlhbE1hcCwgZmluYWxNYXA6IGZpbmFsTWFwIH0gPSB0cmFuc2FjdGlvbjtcbiAgICAgICAgLy8gU3RvcmUgaW5pdGlhbCBhbmQgZmluYWwgbGF5b3V0IGluZm9zIGZvciBhbmltYXRpb25zXG4gICAgICAgIGZvciAobGV0IFtrZXksIGxheW91dEluZm9dIG9mIGluaXRpYWxNYXApaWYgKGZpbmFsTWFwLmhhcyhrZXkpKSAvLyBTdG9yZSB0aGUgaW5pdGlhbCBsYXlvdXQgaW5mbyBmb3IgdXNlIGR1cmluZyBhbmltYXRpb25zLlxuICAgICAgICB0cmFuc2FjdGlvbi5pbml0aWFsTGF5b3V0SW5mby5zZXQoa2V5LCBsYXlvdXRJbmZvKTtcbiAgICAgICAgZWxzZSAvLyBUaGlzIHZpZXcgd2FzIHJlbW92ZWQuIFN0b3JlIHRoZSBsYXlvdXQgaW5mbyBmb3IgdXNlXG4gICAgICAgIC8vIGluIExheW91dCNnZXRGaW5hbExheW91dEluZm8gZHVyaW5nIGFuaW1hdGlvbnMuXG4gICAgICAgIHRyYW5zYWN0aW9uLmZpbmFsTGF5b3V0SW5mby5zZXQobGF5b3V0SW5mby5rZXksIGxheW91dEluZm8pO1xuICAgICAgICAvLyBHZXQgaW5pdGlhbCBsYXlvdXQgaW5mb3MgZm9yIHZpZXdzIHRoYXQgd2VyZSBhZGRlZFxuICAgICAgICBmb3IgKGxldCBba2V5LCBsYXlvdXRJbmZvXSBvZiBmaW5hbE1hcClpZiAoIWluaXRpYWxNYXAuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIGxldCBpbml0aWFsTGF5b3V0SW5mbyA9IHRoaXMubGF5b3V0LmdldEluaXRpYWxMYXlvdXRJbmZvKGxheW91dEluZm8uY29weSgpKTtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmluaXRpYWxMYXlvdXRJbmZvLnNldChrZXksIGluaXRpYWxMYXlvdXRJbmZvKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaWd1cmUgb3V0IHdoaWNoIHZpZXdzIHdlcmUgcmVtb3ZlZC5cbiAgICAgICAgZm9yIChsZXQgW2tleSwgdmlld10gb2YgdGhpcy5fdmlzaWJsZVZpZXdzKS8vIElmIGFuIGl0ZW0gaGFzIGEgd2lkdGggb2YgMCwgdGhlcmUgaXMgbm8gbmVlZCB0byByZW1vdmUgaXQgZnJvbSB0aGUgX3Zpc2libGVWaWV3cy5cbiAgICAgICAgLy8gUmVtb3ZpbmcgYW4gaXRlbSB3aXRoICB3aWR0aCBvZiAwIGNhbiBjYXVzZSBhIGxvb3Agd2hlcmUgdGhlIGl0ZW0gZ2V0cyBhZGRlZCwgcmVtb3ZlZCxcbiAgICAgICAgLy8gYWRkZWQsIHJlbW92ZWQuLi4gZXRjIGluIGEgbG9vcC5cbiAgICAgICAgaWYgKCFmaW5hbE1hcC5oYXMoa2V5KSAmJiB2aWV3LmxheW91dEluZm8ucmVjdC53aWR0aCA+IDApIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLnJlbW92ZWQuc2V0KGtleSwgdmlldyk7XG4gICAgICAgICAgICB0aGlzLl92aXNpYmxlVmlld3MuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAvLyBJbiBjYXNlIHNvbWV0aGluZyB3ZWlyZCBoYXBwZW5lZCwgd2hlcmUgd2UgaGF2ZSBhIHZpZXcgYnV0IG5vXG4gICAgICAgICAgICAvLyBpbml0aWFsIGxheW91dCBpbmZvLCB1c2UgdGhlIG9uZSBhdHRhY2hlZCB0byB0aGUgdmlldy5cbiAgICAgICAgICAgIGlmICh2aWV3LmxheW91dEluZm8pIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRyYW5zYWN0aW9uLmZpbmFsTGF5b3V0SW5mby5oYXModmlldy5sYXlvdXRJbmZvLmtleSkpIHRyYW5zYWN0aW9uLmZpbmFsTGF5b3V0SW5mby5zZXQodmlldy5sYXlvdXRJbmZvLmtleSwgdmlldy5sYXlvdXRJbmZvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pe1xuICAgICAgICB0aGlzLl9jb250ZW50U2l6ZSA9IG5ldyAoMCwgJGVlMWJmYTkwYTk1N2ZiOGEkZXhwb3J0JGNiNmRhODljNmFmMWE4ZWMpO1xuICAgICAgICB0aGlzLl92aXNpYmxlUmVjdCA9IG5ldyAoMCwgJDYwNDIzZjkyYzdmOWFkODckZXhwb3J0JGM3OWZjNjQ5MmYzYWYxM2QpO1xuICAgICAgICB0aGlzLl9yZXVzYWJsZVZpZXdzID0ge307XG4gICAgICAgIHRoaXMuX3Zpc2libGVMYXlvdXRJbmZvcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fdmlzaWJsZVZpZXdzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9yZW5kZXJlZENvbnRlbnQgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICB0aGlzLl9jaGlsZHJlbiA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5faW52YWxpZGF0aW9uQ29udGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMuX292ZXJzY2FuTWFuYWdlciA9IG5ldyAoMCwgJDM2NDE5MWIzZGVjZjM2OTckZXhwb3J0JDQ0NTVlZTZhZmIzOGRjYmIpKCk7XG4gICAgICAgIHRoaXMuX3BlcnNpc3RlZEtleXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuX3Njcm9sbEFuaW1hdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuX2lzU2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3NpemVVcGRhdGVRdWV1ZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fYW5pbWF0ZWRDb250ZW50T2Zmc2V0ID0gbmV3ICgwLCAkMzA0MWRiMzI5Njk0NWU2ZSRleHBvcnQkYmFmMjYxNDZhNDE0ZjI0YSkoMCwgMCk7XG4gICAgICAgIHRoaXMuX3RyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbmV4dFRyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb25RdWV1ZSA9IFtdO1xuICAgICAgICB2YXIgX29wdGlvbnNfdHJhbnNpdGlvbkR1cmF0aW9uO1xuICAgICAgICAvLyBTZXQgb3B0aW9ucyBmcm9tIHBhc3NlZCBvYmplY3QgaWYgZ2l2ZW5cbiAgICAgICAgdGhpcy50cmFuc2l0aW9uRHVyYXRpb24gPSAoX29wdGlvbnNfdHJhbnNpdGlvbkR1cmF0aW9uID0gb3B0aW9ucy50cmFuc2l0aW9uRHVyYXRpb24pICE9PSBudWxsICYmIF9vcHRpb25zX3RyYW5zaXRpb25EdXJhdGlvbiAhPT0gdm9pZCAwID8gX29wdGlvbnNfdHJhbnNpdGlvbkR1cmF0aW9uIDogNTAwO1xuICAgICAgICB0aGlzLmFuY2hvclNjcm9sbFBvc2l0aW9uID0gb3B0aW9ucy5hbmNob3JTY3JvbGxQb3NpdGlvbiB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5hbmNob3JTY3JvbGxQb3NpdGlvbkF0VG9wID0gb3B0aW9ucy5hbmNob3JTY3JvbGxQb3NpdGlvbkF0VG9wIHx8IGZhbHNlO1xuICAgICAgICB0aGlzLnNob3VsZE92ZXJzY2FuID0gb3B0aW9ucy5zaG91bGRPdmVyc2NhbiAhPT0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGtleSBvZiBbXG4gICAgICAgICAgICBcImRlbGVnYXRlXCIsXG4gICAgICAgICAgICBcInNpemVcIixcbiAgICAgICAgICAgIFwibGF5b3V0XCIsXG4gICAgICAgICAgICBcImNvbGxlY3Rpb25cIlxuICAgICAgICBdKWlmIChvcHRpb25zW2tleV0pIHRoaXNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICB9XG59XG5cblxuZnVuY3Rpb24gJGZjMGIxM2I0ODRhYzExOTQkZXhwb3J0JDE1MDVkYjgyZmUzNTdlNjUob3B0cykge1xuICAgIGxldCBbdmlzaWJsZVZpZXdzLCBzZXRWaXNpYmxlVmlld3NdID0gKDAsICQ4RDNuciR1c2VTdGF0ZSkoW10pO1xuICAgIGxldCBbY29udGVudFNpemUsIHNldENvbnRlbnRTaXplXSA9ICgwLCAkOEQzbnIkdXNlU3RhdGUpKG5ldyAoMCwgJGVlMWJmYTkwYTk1N2ZiOGEkZXhwb3J0JGNiNmRhODljNmFmMWE4ZWMpKCkpO1xuICAgIGxldCBbaXNBbmltYXRpbmcsIHNldEFuaW1hdGluZ10gPSAoMCwgJDhEM25yJHVzZVN0YXRlKShmYWxzZSk7XG4gICAgbGV0IFtpc1Njcm9sbGluZywgc2V0U2Nyb2xsaW5nXSA9ICgwLCAkOEQzbnIkdXNlU3RhdGUpKGZhbHNlKTtcbiAgICBsZXQgdmlydHVhbGl6ZXIgPSAoMCwgJDhEM25yJHVzZU1lbW8pKCgpPT5uZXcgKDAsICQzOGI5NDkwYzFjY2E4ZmM0JGV4cG9ydCQ4OWJlNWEyNDNlNTljNGIyKSgpLCBbXSk7XG4gICAgdmlydHVhbGl6ZXIuZGVsZWdhdGUgPSB7XG4gICAgICAgIHNldFZpc2libGVWaWV3czogc2V0VmlzaWJsZVZpZXdzLFxuICAgICAgICBzZXRWaXNpYmxlUmVjdCAocmVjdCkge1xuICAgICAgICAgICAgdmlydHVhbGl6ZXIudmlzaWJsZVJlY3QgPSByZWN0O1xuICAgICAgICAgICAgb3B0cy5vblZpc2libGVSZWN0Q2hhbmdlKHJlY3QpO1xuICAgICAgICB9LFxuICAgICAgICBzZXRDb250ZW50U2l6ZTogc2V0Q29udGVudFNpemUsXG4gICAgICAgIHJlbmRlclZpZXc6IG9wdHMucmVuZGVyVmlldyxcbiAgICAgICAgcmVuZGVyV3JhcHBlcjogb3B0cy5yZW5kZXJXcmFwcGVyLFxuICAgICAgICBiZWdpbkFuaW1hdGlvbnM6ICgpPT5zZXRBbmltYXRpbmcodHJ1ZSksXG4gICAgICAgIGVuZEFuaW1hdGlvbnM6ICgpPT5zZXRBbmltYXRpbmcoZmFsc2UpLFxuICAgICAgICBnZXRTY3JvbGxBbmNob3I6IG9wdHMuZ2V0U2Nyb2xsQW5jaG9yXG4gICAgfTtcbiAgICB2aXJ0dWFsaXplci5sYXlvdXQgPSBvcHRzLmxheW91dDtcbiAgICB2aXJ0dWFsaXplci5jb2xsZWN0aW9uID0gb3B0cy5jb2xsZWN0aW9uO1xuICAgIHZpcnR1YWxpemVyLnRyYW5zaXRpb25EdXJhdGlvbiA9IG9wdHMudHJhbnNpdGlvbkR1cmF0aW9uO1xuICAgICgwLCAkOEQzbnIkdXNlTGF5b3V0RWZmZWN0KSgoKT0+e1xuICAgICAgICB2aXJ0dWFsaXplci5hZnRlclJlbmRlcigpO1xuICAgIH0pO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBhcnJvdy1ib2R5LXN0eWxlXG4gICAgKDAsICQ4RDNuciR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIHJldHVybiAoKT0+dmlydHVhbGl6ZXIud2lsbFVubW91bnQoKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgfSwgW10pO1xuICAgIGxldCBzZXRWaXNpYmxlUmVjdCA9ICgwLCAkOEQzbnIkdXNlQ2FsbGJhY2spKChyZWN0KT0+e1xuICAgICAgICB2aXJ0dWFsaXplci52aXNpYmxlUmVjdCA9IHJlY3Q7XG4gICAgfSwgW1xuICAgICAgICB2aXJ0dWFsaXplclxuICAgIF0pO1xuICAgIGxldCBzdGFydFNjcm9sbGluZyA9ICgwLCAkOEQzbnIkdXNlQ2FsbGJhY2spKCgpPT57XG4gICAgICAgIHZpcnR1YWxpemVyLnN0YXJ0U2Nyb2xsaW5nKCk7XG4gICAgICAgIHNldFNjcm9sbGluZyh0cnVlKTtcbiAgICB9LCBbXG4gICAgICAgIHZpcnR1YWxpemVyXG4gICAgXSk7XG4gICAgbGV0IGVuZFNjcm9sbGluZyA9ICgwLCAkOEQzbnIkdXNlQ2FsbGJhY2spKCgpPT57XG4gICAgICAgIHZpcnR1YWxpemVyLmVuZFNjcm9sbGluZygpO1xuICAgICAgICBzZXRTY3JvbGxpbmcoZmFsc2UpO1xuICAgIH0sIFtcbiAgICAgICAgdmlydHVhbGl6ZXJcbiAgICBdKTtcbiAgICBsZXQgc3RhdGUgPSAoMCwgJDhEM25yJHVzZU1lbW8pKCgpPT4oe1xuICAgICAgICAgICAgdmlydHVhbGl6ZXI6IHZpcnR1YWxpemVyLFxuICAgICAgICAgICAgdmlzaWJsZVZpZXdzOiB2aXNpYmxlVmlld3MsXG4gICAgICAgICAgICBzZXRWaXNpYmxlUmVjdDogc2V0VmlzaWJsZVJlY3QsXG4gICAgICAgICAgICBjb250ZW50U2l6ZTogY29udGVudFNpemUsXG4gICAgICAgICAgICBpc0FuaW1hdGluZzogaXNBbmltYXRpbmcsXG4gICAgICAgICAgICBpc1Njcm9sbGluZzogaXNTY3JvbGxpbmcsXG4gICAgICAgICAgICBzdGFydFNjcm9sbGluZzogc3RhcnRTY3JvbGxpbmcsXG4gICAgICAgICAgICBlbmRTY3JvbGxpbmc6IGVuZFNjcm9sbGluZ1xuICAgICAgICB9KSwgW1xuICAgICAgICB2aXJ0dWFsaXplcixcbiAgICAgICAgdmlzaWJsZVZpZXdzLFxuICAgICAgICBzZXRWaXNpYmxlUmVjdCxcbiAgICAgICAgY29udGVudFNpemUsXG4gICAgICAgIGlzQW5pbWF0aW5nLFxuICAgICAgICBpc1Njcm9sbGluZyxcbiAgICAgICAgc3RhcnRTY3JvbGxpbmcsXG4gICAgICAgIGVuZFNjcm9sbGluZ1xuICAgIF0pO1xuICAgIHJldHVybiBzdGF0ZTtcbn1cblxuXG5cblxuZXhwb3J0IHskYzc0Y2RhN2QzMWFmMTI1MyRleHBvcnQkYzg0NjcxZjQ2ZDZhMWNhIGFzIExheW91dCwgJGQ3ZmQ2MTAwOWMyMWQwYmIkZXhwb3J0JDdlMGVlYjlkYTcwMmEwODUgYXMgTGF5b3V0SW5mbywgJDMwNDFkYjMyOTY5NDVlNmUkZXhwb3J0JGJhZjI2MTQ2YTQxNGYyNGEgYXMgUG9pbnQsICQ2MDQyM2Y5MmM3ZjlhZDg3JGV4cG9ydCRjNzlmYzY0OTJmM2FmMTNkIGFzIFJlY3QsICRlZTFiZmE5MGE5NTdmYjhhJGV4cG9ydCRjYjZkYTg5YzZhZjFhOGVjIGFzIFNpemUsICRhZDFkOThhYThmMGMzMWI0JGV4cG9ydCQxYTUyMjM4ODdjNTYwNDQxIGFzIFJldXNhYmxlVmlldywgJGZjMGIxM2I0ODRhYzExOTQkZXhwb3J0JDE1MDVkYjgyZmUzNTdlNjUgYXMgdXNlVmlydHVhbGl6ZXJTdGF0ZX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCIkOEQzbnIkdXNlU3RhdGUiLCJ1c2VNZW1vIiwiJDhEM25yJHVzZU1lbW8iLCJ1c2VFZmZlY3QiLCIkOEQzbnIkdXNlRWZmZWN0IiwidXNlQ2FsbGJhY2siLCIkOEQzbnIkdXNlQ2FsbGJhY2siLCJ1c2VMYXlvdXRFZmZlY3QiLCIkOEQzbnIkdXNlTGF5b3V0RWZmZWN0IiwiJGM3NGNkYTdkMzFhZjEyNTMkZXhwb3J0JGM4NDY3MWY0NmQ2YTFjYSIsInNob3VsZEludmFsaWRhdGUiLCJuZXdSZWN0Iiwib2xkUmVjdCIsIndpZHRoIiwiaGVpZ2h0IiwidmFsaWRhdGUiLCJpbnZhbGlkYXRpb25Db250ZXh0IiwiZ2V0SW5pdGlhbExheW91dEluZm8iLCJsYXlvdXRJbmZvIiwiZ2V0RmluYWxMYXlvdXRJbmZvIiwiJGQ3ZmQ2MTAwOWMyMWQwYmIkZXhwb3J0JDdlMGVlYjlkYTcwMmEwODUiLCJjb3B5IiwicmVzIiwidHlwZSIsImtleSIsInJlY3QiLCJlc3RpbWF0ZWRTaXplIiwib3BhY2l0eSIsInRyYW5zZm9ybSIsInBhcmVudEtleSIsImlzU3RpY2t5IiwiekluZGV4IiwiYWxsb3dPdmVyZmxvdyIsImNvbnN0cnVjdG9yIiwiJDMwNDFkYjMyOTY5NDVlNmUkZXhwb3J0JGJhZjI2MTQ2YTQxNGYyNGEiLCJ4IiwieSIsImVxdWFscyIsInBvaW50IiwiaXNPcmlnaW4iLCIkNjA0MjNmOTJjN2Y5YWQ4NyRleHBvcnQkYzc5ZmM2NDkyZjNhZjEzZCIsIm1heFgiLCJtYXhZIiwiYXJlYSIsInRvcExlZnQiLCJ0b3BSaWdodCIsImJvdHRvbUxlZnQiLCJib3R0b21SaWdodCIsImludGVyc2VjdHMiLCJjb250YWluc1JlY3QiLCJjb250YWluc1BvaW50IiwiZ2V0Q29ybmVySW5SZWN0IiwicG9pbnRFcXVhbHMiLCJzaXplRXF1YWxzIiwic2l6ZSIsInVuaW9uIiwib3RoZXIiLCJNYXRoIiwibWluIiwibWF4IiwiaW50ZXJzZWN0aW9uIiwiJGVlMWJmYTkwYTk1N2ZiOGEkZXhwb3J0JGNiNmRhODljNmFmMWE4ZWMiLCIkYWQxZDk4YWE4ZjBjMzFiNCR2YXIkS0VZIiwiJGFkMWQ5OGFhOGYwYzMxYjQkZXhwb3J0JDFhNTIyMzg4N2M1NjA0NDEiLCJwcmVwYXJlRm9yUmV1c2UiLCJjb250ZW50IiwicmVuZGVyZWQiLCJ2aXJ0dWFsaXplciIsIiQzZWIxMzFkY2YzN2FkNWY4JHZhciRwZXJmIiwid2luZG93IiwicGVyZm9ybWFuY2UiLCIkM2ViMTMxZGNmMzdhZDVmOCR2YXIkcGVyZk5vdyIsIm5vdyIsIndlYmtpdE5vdyIsIm1zTm93IiwibW96Tm93IiwiJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJGdldFRpbWUiLCJiaW5kIiwiRGF0ZSIsImdldFRpbWUiLCIkM2ViMTMxZGNmMzdhZDVmOCR2YXIkZml4VHMiLCIkM2ViMTMxZGNmMzdhZDVmOCRleHBvcnQkZGMwYjYzNzIwNzg4MDkwYyIsImJlZ2luIiwiZW5kIiwiZHVyYXRpb24iLCJlYXNlIiwiZm4iLCJjYW5jZWxlZCIsInJhZl9pZCIsInByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInN0YXJ0IiwiZGlmZlgiLCJkaWZmWSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInJ1biIsInQiLCJkZWx0YSIsInByb2NlZWQiLCJjYW5jZWwiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsIiQzZWIxMzFkY2YzN2FkNWY4JGV4cG9ydCQ3Nzg2MGMxMDZiNGE2YTJlIiwiJDNlYjEzMWRjZjM3YWQ1ZjgkZXhwb3J0JDU3NjM2YmI0M2IxY2NiYjAiLCJzaW4iLCJQSSIsIiRmYzM2ZjlhMDQ2YTljZTc5JGV4cG9ydCQzN2EyNmIyODNmZDc3NDBlIiwiYSIsImIiLCJTZXQiLCJrZXlzIiwiaGFzIiwiYWRkIiwiJGZjMzZmOWEwNDZhOWNlNzkkZXhwb3J0JGFjYWY5NmEyNzQzODI0NmIiLCJ0b1JlbW92ZSIsInRvQWRkIiwidG9VcGRhdGUiLCIkZmMzNmY5YTA0NmE5Y2U3OSRleHBvcnQkY2ZjMTQwODhkZmVmY2U1ZiIsIml0ZXJhdG9ycyIsIml0ZXJhdG9yIiwiJGZjMzZmOWEwNDZhOWNlNzkkZXhwb3J0JDY4OTdjMjg0YjZmOWY0ZGMiLCJvYmplY3QiLCIkZmMzNmY5YTA0NmE5Y2U3OSRleHBvcnQkYThkMGQwYzhkMWM1ZGY2NCIsIiQzNjQxOTFiM2RlY2YzNjk3JHZhciRSb2xsaW5nQXZlcmFnZSIsImFkZFNhbXBsZSIsInNhbXBsZSIsImNvdW50IiwidmFsdWUiLCIkMzY0MTkxYjNkZWNmMzY5NyRleHBvcnQkNDQ1NWVlNmFmYjM4ZGNiYiIsInNldFZpc2libGVSZWN0IiwidGltZSIsInN0YXJ0VGltZSIsImF2ZXJhZ2VUaW1lIiwidmlzaWJsZVJlY3QiLCJ2ZWxvY2l0eSIsImNvbGxlY3RNZXRyaWNzIiwiYXZlcmFnZVBlcmYiLCJvIiwiYWJzIiwib3ZlcnNjYW5ZIiwib3ZlcnNjYW5YIiwiZ2V0T3ZlcnNjYW5uZWRSZWN0Iiwib3ZlcnNjYW5uZWQiLCJyb3VuZCIsIiQ4ZTEzNWU1MzFkOGRjYjY2JGV4cG9ydCRmZWJjNTU3M2M3NWNlZmIwIiwibGV2ZWwiLCJhY3Rpb25zIiwiYW5pbWF0ZWQiLCJpbml0aWFsTWFwIiwiTWFwIiwiZmluYWxNYXAiLCJpbml0aWFsTGF5b3V0SW5mbyIsImZpbmFsTGF5b3V0SW5mbyIsInJlbW92ZWQiLCIkMzhiOTQ5MGMxY2NhOGZjNCRleHBvcnQkODliZTVhMjQzZTU5YzRiMiIsIl9zZXRDb250ZW50U2l6ZSIsIl9jb250ZW50U2l6ZSIsImRlbGVnYXRlIiwic2V0Q29udGVudFNpemUiLCJfc2V0Q29udGVudE9mZnNldCIsIm9mZnNldCIsIl92aXNpYmxlUmVjdCIsImNvbnRlbnRTaXplIiwiX3NldFZpc2libGVSZWN0IiwiZm9yY2VVcGRhdGUiLCJjdXJyZW50Iiwic2hvdWxkT3ZlcnNjYW4iLCJfb3ZlcnNjYW5NYW5hZ2VyIiwibGF5b3V0IiwiX3Jlc2V0QW5pbWF0ZWRDb250ZW50T2Zmc2V0IiwicmVsYXlvdXROb3ciLCJvZmZzZXRDaGFuZ2VkIiwic2l6ZUNoYW5nZWQiLCJ1cGRhdGVTdWJ2aWV3cyIsImNvbGxlY3Rpb24iLCJfY29sbGVjdGlvbiIsImRhdGEiLCJfc2V0RGF0YSIsIl9ydW5UcmFuc2FjdGlvbiIsInRyYW5zaXRpb25EdXJhdGlvbiIsInJlbG9hZERhdGEiLCJyZWxheW91dCIsImNvbnRlbnRDaGFuZ2VkIiwiZ2V0SXRlbSIsInBlcnNpc3RlZEtleXMiLCJfcGVyc2lzdGVkS2V5cyIsImlzUGVyc2lzdGVkS2V5IiwiayIsImdldExheW91dEluZm8iLCJfbGF5b3V0Iiwic2V0TGF5b3V0IiwiYXBwbHlMYXlvdXQiLCJfZ2V0UmV1c2VUeXBlIiwiZ2V0VHlwZSIsInJldXNlVHlwZSIsImdldFJldXNhYmxlVmlldyIsIl9yZXVzYWJsZVZpZXdzIiwicmV1c2FibGUiLCJ2aWV3IiwibGVuZ3RoIiwicG9wIiwidmlld1R5cGUiLCJfYW5pbWF0ZWRDb250ZW50T2Zmc2V0IiwiX3JlbmRlclZpZXciLCJyZXVzYWJsZVZpZXciLCJfcmVuZGVyQ29udGVudCIsImNhY2hlZCIsIl9yZW5kZXJlZENvbnRlbnQiLCJnZXQiLCJyZW5kZXJWaWV3Iiwic2V0IiwidmlzaWJsZVZpZXdzIiwiQXJyYXkiLCJmcm9tIiwiX3Zpc2libGVWaWV3cyIsInZhbHVlcyIsImdldFZpZXciLCJnZXRWaWV3c09mVHlwZSIsImZpbHRlciIsInYiLCJrZXlGb3JWaWV3Iiwia2V5QXRQb2ludCIsImxheW91dEluZm9zIiwiZ2V0VmlzaWJsZUxheW91dEluZm9zIiwid2lsbFVubW91bnQiLCJfcmVsYXlvdXRSYWYiLCJjb250ZXh0IiwiX3Njcm9sbEFuaW1hdGlvbiIsIl9pbnZhbGlkYXRpb25Db250ZXh0IiwiT2JqZWN0IiwiYXNzaWduIiwic2Nyb2xsQW5jaG9yIiwiX2dldFNjcm9sbEFuY2hvciIsImJlZm9yZUxheW91dCIsImdldENvbnRlbnRTaXplIiwiYWZ0ZXJMYXlvdXQiLCJnZXRWaXNpYmxlUmVjdCIsInJlc3RvcmVkU2Nyb2xsQW5jaG9yIiwiX3Jlc3RvcmVTY3JvbGxBbmNob3IiLCJjb250ZW50T2Zmc2V0WCIsImNvbnRlbnRPZmZzZXRZIiwiaGFzTGF5b3V0VXBkYXRlcyIsInRyYW5zYWN0aW9uIiwiX2FwcGx5TGF5b3V0SW5mb3MiLCJfZW5hYmxlVHJhbnNpdGlvbnMiLCJkb25lIiwiX2Rpc2FibGVUcmFuc2l0aW9ucyIsImFmdGVyQW5pbWF0aW9uIiwic2V0VGltZW91dCIsIl9jb3JyZWN0SXRlbU9yZGVyIiwiX2lzU2Nyb2xsaW5nIiwiX3RyYW5zYWN0aW9uIiwiX3Zpc2libGVMYXlvdXRJbmZvcyIsIl9jaGlsZHJlbiIsImRlbGV0ZSIsImJlZ2luQW5pbWF0aW9ucyIsImVuZEFuaW1hdGlvbnMiLCJhbmNob3JTY3JvbGxQb3NpdGlvbiIsImdldFNjcm9sbEFuY2hvciIsImNvcm5lciIsImFuY2hvclNjcm9sbFBvc2l0aW9uQXRUb3AiLCJjb3JuZXJBbmNob3IiLCJjb250ZW50T2Zmc2V0IiwiX2NvbnRleHRfdHJhbnNhY3Rpb24iLCJmaW5hbEFuY2hvciIsImFkanVzdG1lbnQiLCJfZ2V0TGF5b3V0SW5mb01hcCIsIm1hcCIsInZpc2libGVMYXlvdXRJbmZvcyIsImN1cnJlbnRseVZpc2libGUiLCJpdGVtIiwicmV1c2VWaWV3IiwiX2FwcGx5TGF5b3V0SW5mbyIsInJlbW92ZVZpZXdzIiwiX2ZsdXNoVmlzaWJsZVZpZXdzIiwiX2hhc0xheW91dFVwZGF0ZXMiLCJhZnRlclJlbmRlciIsIl90cmFuc2FjdGlvblF1ZXVlIiwiX3Byb2Nlc3NUcmFuc2FjdGlvblF1ZXVlIiwidmlld3NCeVBhcmVudEtleSIsIl92aWV3X2xheW91dEluZm8iLCJfdmlld3NCeVBhcmVudEtleV9nZXQiLCJfdmlld19sYXlvdXRJbmZvMSIsIl92aWV3X2xheW91dEluZm8yIiwiX3ZpZXdfbGF5b3V0SW5mbzMiLCJwdXNoIiwiYnVpbGRUcmVlIiwicGFyZW50Iiwidmlld3MiLCJjaGlsZHJlbiIsInJlbmRlcldyYXBwZXIiLCJjaGlsZFZpZXdzIiwic2V0VmlzaWJsZVZpZXdzIiwidXBkYXRlZCIsImN1ciIsInVwZGF0ZUl0ZW1TaXplIiwiX3NpemVVcGRhdGVRdWV1ZSIsImNoYW5nZWQiLCJzdGFydFNjcm9sbGluZyIsImVuZFNjcm9sbGluZyIsInNjcm9sbFRvSXRlbSIsIm9wdGlvbnMiLCJzaG91bGRTY3JvbGxYIiwic2hvdWxkU2Nyb2xsWSIsIm9mZnNldFgiLCJvZmZzZXRZIiwibWluWCIsIm1pblkiLCJzY3JvbGxUbyIsInRoZW4iLCJjbGVhciIsImFjdGlvbiIsIl9zdGFydFRyYW5zYWN0aW9uIiwiX25leHRUcmFuc2FjdGlvbiIsIl9lbmRUcmFuc2FjdGlvbiIsIm5leHQiLCJzaGlmdCIsIl9wZXJmb3JtVHJhbnNhY3Rpb24iLCJfZ2V0Q29udGVudFJlY3QiLCJfc2V0dXBUcmFuc2FjdGlvbkFuaW1hdGlvbnMiLCJXZWFrTWFwIiwiX29wdGlvbnNfdHJhbnNpdGlvbkR1cmF0aW9uIiwiJGZjMGIxM2I0ODRhYzExOTQkZXhwb3J0JDE1MDVkYjgyZmUzNTdlNjUiLCJvcHRzIiwiaXNBbmltYXRpbmciLCJzZXRBbmltYXRpbmciLCJpc1Njcm9sbGluZyIsInNldFNjcm9sbGluZyIsIm9uVmlzaWJsZVJlY3RDaGFuZ2UiLCJzdGF0ZSIsIkxheW91dCIsIkxheW91dEluZm8iLCJQb2ludCIsIlJlY3QiLCJTaXplIiwiUmV1c2FibGVWaWV3IiwidXNlVmlydHVhbGl6ZXJTdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@react-stately+virtualizer@3.6.6_react@18.2.0/node_modules/@react-stately/virtualizer/dist/import.mjs\n");

/***/ })

};
;