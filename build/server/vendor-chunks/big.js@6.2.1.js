"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/big.js@6.2.1";
exports.ids = ["vendor-chunks/big.js@6.2.1"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/big.js@6.2.1/node_modules/big.js/big.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/.pnpm/big.js@6.2.1/node_modules/big.js/big.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Big: () => (/* binding */ Big),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*\r\n *  big.js v6.2.1\r\n *  A small, fast, easy-to-use library for arbitrary-precision decimal arithmetic.\r\n *  Copyright (c) 2022 Michael Mclaughlin\r\n *  https://github.com/MikeMcl/big.js/LICENCE.md\r\n */ /************************************** EDITABLE DEFAULTS *****************************************/ // The default values below must be integers within the stated ranges.\n/*\r\n   * The maximum number of decimal places (DP) of the results of operations involving division:\r\n   * div and sqrt, and pow with negative exponents.\r\n   */ var DP = 20, /*\r\n   * The rounding mode (RM) used when rounding to the above decimal places.\r\n   *\r\n   *  0  Towards zero (i.e. truncate, no rounding).       (ROUND_DOWN)\r\n   *  1  To nearest neighbour. If equidistant, round up.  (ROUND_HALF_UP)\r\n   *  2  To nearest neighbour. If equidistant, to even.   (ROUND_HALF_EVEN)\r\n   *  3  Away from zero.                                  (ROUND_UP)\r\n   */ RM = 1, // The maximum value of DP and Big.DP.\nMAX_DP = 1E6, // The maximum magnitude of the exponent argument to the pow method.\nMAX_POWER = 1E6, /*\r\n   * The negative exponent (NE) at and beneath which toString returns exponential notation.\r\n   * (JavaScript numbers: -7)\r\n   * -1000000 is the minimum recommended exponent value of a Big.\r\n   */ NE = -7, /*\r\n   * The positive exponent (PE) at and above which toString returns exponential notation.\r\n   * (JavaScript numbers: 21)\r\n   * 1000000 is the maximum recommended exponent value of a Big, but this limit is not enforced.\r\n   */ PE = 21, /*\r\n   * When true, an error will be thrown if a primitive number is passed to the Big constructor,\r\n   * or if valueOf is called, or if toNumber is called on a Big which cannot be converted to a\r\n   * primitive number without a loss of precision.\r\n   */ STRICT = false, /**************************************************************************************************/ // Error messages.\nNAME = \"[big.js] \", INVALID = NAME + \"Invalid \", INVALID_DP = INVALID + \"decimal places\", INVALID_RM = INVALID + \"rounding mode\", DIV_BY_ZERO = NAME + \"Division by zero\", // The shared prototype object.\nP = {}, UNDEFINED = void 0, NUMERIC = /^-?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i;\n/*\r\n * Create and return a Big constructor.\r\n */ function _Big_() {\n    /*\r\n   * The Big constructor and exported function.\r\n   * Create and return a new instance of a Big number object.\r\n   *\r\n   * n {number|string|Big} A numeric value.\r\n   */ function Big(n) {\n        var x = this;\n        // Enable constructor usage without new.\n        if (!(x instanceof Big)) return n === UNDEFINED ? _Big_() : new Big(n);\n        // Duplicate.\n        if (n instanceof Big) {\n            x.s = n.s;\n            x.e = n.e;\n            x.c = n.c.slice();\n        } else {\n            if (typeof n !== \"string\") {\n                if (Big.strict === true && typeof n !== \"bigint\") {\n                    throw TypeError(INVALID + \"value\");\n                }\n                // Minus zero?\n                n = n === 0 && 1 / n < 0 ? \"-0\" : String(n);\n            }\n            parse(x, n);\n        }\n        // Retain a reference to this Big constructor.\n        // Shadow Big.prototype.constructor which points to Object.\n        x.constructor = Big;\n    }\n    Big.prototype = P;\n    Big.DP = DP;\n    Big.RM = RM;\n    Big.NE = NE;\n    Big.PE = PE;\n    Big.strict = STRICT;\n    Big.roundDown = 0;\n    Big.roundHalfUp = 1;\n    Big.roundHalfEven = 2;\n    Big.roundUp = 3;\n    return Big;\n}\n/*\r\n * Parse the number or string value passed to a Big constructor.\r\n *\r\n * x {Big} A Big number instance.\r\n * n {number|string} A numeric value.\r\n */ function parse(x, n) {\n    var e, i, nl;\n    if (!NUMERIC.test(n)) {\n        throw Error(INVALID + \"number\");\n    }\n    // Determine sign.\n    x.s = n.charAt(0) == \"-\" ? (n = n.slice(1), -1) : 1;\n    // Decimal point?\n    if ((e = n.indexOf(\".\")) > -1) n = n.replace(\".\", \"\");\n    // Exponential form?\n    if ((i = n.search(/e/i)) > 0) {\n        // Determine exponent.\n        if (e < 0) e = i;\n        e += +n.slice(i + 1);\n        n = n.substring(0, i);\n    } else if (e < 0) {\n        // Integer.\n        e = n.length;\n    }\n    nl = n.length;\n    // Determine leading zeros.\n    for(i = 0; i < nl && n.charAt(i) == \"0\";)++i;\n    if (i == nl) {\n        // Zero.\n        x.c = [\n            x.e = 0\n        ];\n    } else {\n        // Determine trailing zeros.\n        for(; nl > 0 && n.charAt(--nl) == \"0\";);\n        x.e = e - i - 1;\n        x.c = [];\n        // Convert string to array of digits without leading/trailing zeros.\n        for(e = 0; i <= nl;)x.c[e++] = +n.charAt(i++);\n    }\n    return x;\n}\n/*\r\n * Round Big x to a maximum of sd significant digits using rounding mode rm.\r\n *\r\n * x {Big} The Big to round.\r\n * sd {number} Significant digits: integer, 0 to MAX_DP inclusive.\r\n * rm {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n * [more] {boolean} Whether the result of division was truncated.\r\n */ function round(x, sd, rm, more) {\n    var xc = x.c;\n    if (rm === UNDEFINED) rm = x.constructor.RM;\n    if (rm !== 0 && rm !== 1 && rm !== 2 && rm !== 3) {\n        throw Error(INVALID_RM);\n    }\n    if (sd < 1) {\n        more = rm === 3 && (more || !!xc[0]) || sd === 0 && (rm === 1 && xc[0] >= 5 || rm === 2 && (xc[0] > 5 || xc[0] === 5 && (more || xc[1] !== UNDEFINED)));\n        xc.length = 1;\n        if (more) {\n            // 1, 0.1, 0.01, 0.001, 0.0001 etc.\n            x.e = x.e - sd + 1;\n            xc[0] = 1;\n        } else {\n            // Zero.\n            xc[0] = x.e = 0;\n        }\n    } else if (sd < xc.length) {\n        // xc[sd] is the digit after the digit that may be rounded up.\n        more = rm === 1 && xc[sd] >= 5 || rm === 2 && (xc[sd] > 5 || xc[sd] === 5 && (more || xc[sd + 1] !== UNDEFINED || xc[sd - 1] & 1)) || rm === 3 && (more || !!xc[0]);\n        // Remove any digits after the required precision.\n        xc.length = sd;\n        // Round up?\n        if (more) {\n            // Rounding up may mean the previous digit has to be rounded up.\n            for(; ++xc[--sd] > 9;){\n                xc[sd] = 0;\n                if (sd === 0) {\n                    ++x.e;\n                    xc.unshift(1);\n                    break;\n                }\n            }\n        }\n        // Remove trailing zeros.\n        for(sd = xc.length; !xc[--sd];)xc.pop();\n    }\n    return x;\n}\n/*\r\n * Return a string representing the value of Big x in normal or exponential notation.\r\n * Handles P.toExponential, P.toFixed, P.toJSON, P.toPrecision, P.toString and P.valueOf.\r\n */ function stringify(x, doExponential, isNonzero) {\n    var e = x.e, s = x.c.join(\"\"), n = s.length;\n    // Exponential notation?\n    if (doExponential) {\n        s = s.charAt(0) + (n > 1 ? \".\" + s.slice(1) : \"\") + (e < 0 ? \"e\" : \"e+\") + e;\n    // Normal notation.\n    } else if (e < 0) {\n        for(; ++e;)s = \"0\" + s;\n        s = \"0.\" + s;\n    } else if (e > 0) {\n        if (++e > n) {\n            for(e -= n; e--;)s += \"0\";\n        } else if (e < n) {\n            s = s.slice(0, e) + \".\" + s.slice(e);\n        }\n    } else if (n > 1) {\n        s = s.charAt(0) + \".\" + s.slice(1);\n    }\n    return x.s < 0 && isNonzero ? \"-\" + s : s;\n}\n// Prototype/instance methods\n/*\r\n * Return a new Big whose value is the absolute value of this Big.\r\n */ P.abs = function() {\n    var x = new this.constructor(this);\n    x.s = 1;\n    return x;\n};\n/*\r\n * Return 1 if the value of this Big is greater than the value of Big y,\r\n *       -1 if the value of this Big is less than the value of Big y, or\r\n *        0 if they have the same value.\r\n */ P.cmp = function(y) {\n    var isneg, x = this, xc = x.c, yc = (y = new x.constructor(y)).c, i = x.s, j = y.s, k = x.e, l = y.e;\n    // Either zero?\n    if (!xc[0] || !yc[0]) return !xc[0] ? !yc[0] ? 0 : -j : i;\n    // Signs differ?\n    if (i != j) return i;\n    isneg = i < 0;\n    // Compare exponents.\n    if (k != l) return k > l ^ isneg ? 1 : -1;\n    j = (k = xc.length) < (l = yc.length) ? k : l;\n    // Compare digit by digit.\n    for(i = -1; ++i < j;){\n        if (xc[i] != yc[i]) return xc[i] > yc[i] ^ isneg ? 1 : -1;\n    }\n    // Compare lengths.\n    return k == l ? 0 : k > l ^ isneg ? 1 : -1;\n};\n/*\r\n * Return a new Big whose value is the value of this Big divided by the value of Big y, rounded,\r\n * if necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.\r\n */ P.div = function(y) {\n    var x = this, Big = x.constructor, a = x.c, b = (y = new Big(y)).c, k = x.s == y.s ? 1 : -1, dp = Big.DP;\n    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {\n        throw Error(INVALID_DP);\n    }\n    // Divisor is zero?\n    if (!b[0]) {\n        throw Error(DIV_BY_ZERO);\n    }\n    // Dividend is 0? Return +-0.\n    if (!a[0]) {\n        y.s = k;\n        y.c = [\n            y.e = 0\n        ];\n        return y;\n    }\n    var bl, bt, n, cmp, ri, bz = b.slice(), ai = bl = b.length, al = a.length, r = a.slice(0, bl), rl = r.length, q = y, qc = q.c = [], qi = 0, p = dp + (q.e = x.e - y.e) + 1; // precision of the result\n    q.s = k;\n    k = p < 0 ? 0 : p;\n    // Create version of divisor with leading zero.\n    bz.unshift(0);\n    // Add zeros to make remainder as long as divisor.\n    for(; rl++ < bl;)r.push(0);\n    do {\n        // n is how many times the divisor goes into current remainder.\n        for(n = 0; n < 10; n++){\n            // Compare divisor and remainder.\n            if (bl != (rl = r.length)) {\n                cmp = bl > rl ? 1 : -1;\n            } else {\n                for(ri = -1, cmp = 0; ++ri < bl;){\n                    if (b[ri] != r[ri]) {\n                        cmp = b[ri] > r[ri] ? 1 : -1;\n                        break;\n                    }\n                }\n            }\n            // If divisor < remainder, subtract divisor from remainder.\n            if (cmp < 0) {\n                // Remainder can't be more than 1 digit longer than divisor.\n                // Equalise lengths using divisor with extra leading zero?\n                for(bt = rl == bl ? b : bz; rl;){\n                    if (r[--rl] < bt[rl]) {\n                        ri = rl;\n                        for(; ri && !r[--ri];)r[ri] = 9;\n                        --r[ri];\n                        r[rl] += 10;\n                    }\n                    r[rl] -= bt[rl];\n                }\n                for(; !r[0];)r.shift();\n            } else {\n                break;\n            }\n        }\n        // Add the digit n to the result array.\n        qc[qi++] = cmp ? n : ++n;\n        // Update the remainder.\n        if (r[0] && cmp) r[rl] = a[ai] || 0;\n        else r = [\n            a[ai]\n        ];\n    }while ((ai++ < al || r[0] !== UNDEFINED) && k--);\n    // Leading zero? Do not remove if result is simply zero (qi == 1).\n    if (!qc[0] && qi != 1) {\n        // There can't be more than one zero.\n        qc.shift();\n        q.e--;\n        p--;\n    }\n    // Round?\n    if (qi > p) round(q, p, Big.RM, r[0] !== UNDEFINED);\n    return q;\n};\n/*\r\n * Return true if the value of this Big is equal to the value of Big y, otherwise return false.\r\n */ P.eq = function(y) {\n    return this.cmp(y) === 0;\n};\n/*\r\n * Return true if the value of this Big is greater than the value of Big y, otherwise return\r\n * false.\r\n */ P.gt = function(y) {\n    return this.cmp(y) > 0;\n};\n/*\r\n * Return true if the value of this Big is greater than or equal to the value of Big y, otherwise\r\n * return false.\r\n */ P.gte = function(y) {\n    return this.cmp(y) > -1;\n};\n/*\r\n * Return true if the value of this Big is less than the value of Big y, otherwise return false.\r\n */ P.lt = function(y) {\n    return this.cmp(y) < 0;\n};\n/*\r\n * Return true if the value of this Big is less than or equal to the value of Big y, otherwise\r\n * return false.\r\n */ P.lte = function(y) {\n    return this.cmp(y) < 1;\n};\n/*\r\n * Return a new Big whose value is the value of this Big minus the value of Big y.\r\n */ P.minus = P.sub = function(y) {\n    var i, j, t, xlty, x = this, Big = x.constructor, a = x.s, b = (y = new Big(y)).s;\n    // Signs differ?\n    if (a != b) {\n        y.s = -b;\n        return x.plus(y);\n    }\n    var xc = x.c.slice(), xe = x.e, yc = y.c, ye = y.e;\n    // Either zero?\n    if (!xc[0] || !yc[0]) {\n        if (yc[0]) {\n            y.s = -b;\n        } else if (xc[0]) {\n            y = new Big(x);\n        } else {\n            y.s = 1;\n        }\n        return y;\n    }\n    // Determine which is the bigger number. Prepend zeros to equalise exponents.\n    if (a = xe - ye) {\n        if (xlty = a < 0) {\n            a = -a;\n            t = xc;\n        } else {\n            ye = xe;\n            t = yc;\n        }\n        t.reverse();\n        for(b = a; b--;)t.push(0);\n        t.reverse();\n    } else {\n        // Exponents equal. Check digit by digit.\n        j = ((xlty = xc.length < yc.length) ? xc : yc).length;\n        for(a = b = 0; b < j; b++){\n            if (xc[b] != yc[b]) {\n                xlty = xc[b] < yc[b];\n                break;\n            }\n        }\n    }\n    // x < y? Point xc to the array of the bigger number.\n    if (xlty) {\n        t = xc;\n        xc = yc;\n        yc = t;\n        y.s = -y.s;\n    }\n    /*\r\n   * Append zeros to xc if shorter. No need to add zeros to yc if shorter as subtraction only\r\n   * needs to start at yc.length.\r\n   */ if ((b = (j = yc.length) - (i = xc.length)) > 0) for(; b--;)xc[i++] = 0;\n    // Subtract yc from xc.\n    for(b = i; j > a;){\n        if (xc[--j] < yc[j]) {\n            for(i = j; i && !xc[--i];)xc[i] = 9;\n            --xc[i];\n            xc[j] += 10;\n        }\n        xc[j] -= yc[j];\n    }\n    // Remove trailing zeros.\n    for(; xc[--b] === 0;)xc.pop();\n    // Remove leading zeros and adjust exponent accordingly.\n    for(; xc[0] === 0;){\n        xc.shift();\n        --ye;\n    }\n    if (!xc[0]) {\n        // n - n = +0\n        y.s = 1;\n        // Result must be zero.\n        xc = [\n            ye = 0\n        ];\n    }\n    y.c = xc;\n    y.e = ye;\n    return y;\n};\n/*\r\n * Return a new Big whose value is the value of this Big modulo the value of Big y.\r\n */ P.mod = function(y) {\n    var ygtx, x = this, Big = x.constructor, a = x.s, b = (y = new Big(y)).s;\n    if (!y.c[0]) {\n        throw Error(DIV_BY_ZERO);\n    }\n    x.s = y.s = 1;\n    ygtx = y.cmp(x) == 1;\n    x.s = a;\n    y.s = b;\n    if (ygtx) return new Big(x);\n    a = Big.DP;\n    b = Big.RM;\n    Big.DP = Big.RM = 0;\n    x = x.div(y);\n    Big.DP = a;\n    Big.RM = b;\n    return this.minus(x.times(y));\n};\n/*\r\n * Return a new Big whose value is the value of this Big negated.\r\n */ P.neg = function() {\n    var x = new this.constructor(this);\n    x.s = -x.s;\n    return x;\n};\n/*\r\n * Return a new Big whose value is the value of this Big plus the value of Big y.\r\n */ P.plus = P.add = function(y) {\n    var e, k, t, x = this, Big = x.constructor;\n    y = new Big(y);\n    // Signs differ?\n    if (x.s != y.s) {\n        y.s = -y.s;\n        return x.minus(y);\n    }\n    var xe = x.e, xc = x.c, ye = y.e, yc = y.c;\n    // Either zero?\n    if (!xc[0] || !yc[0]) {\n        if (!yc[0]) {\n            if (xc[0]) {\n                y = new Big(x);\n            } else {\n                y.s = x.s;\n            }\n        }\n        return y;\n    }\n    xc = xc.slice();\n    // Prepend zeros to equalise exponents.\n    // Note: reverse faster than unshifts.\n    if (e = xe - ye) {\n        if (e > 0) {\n            ye = xe;\n            t = yc;\n        } else {\n            e = -e;\n            t = xc;\n        }\n        t.reverse();\n        for(; e--;)t.push(0);\n        t.reverse();\n    }\n    // Point xc to the longer array.\n    if (xc.length - yc.length < 0) {\n        t = yc;\n        yc = xc;\n        xc = t;\n    }\n    e = yc.length;\n    // Only start adding at yc.length - 1 as the further digits of xc can be left as they are.\n    for(k = 0; e; xc[e] %= 10)k = (xc[--e] = xc[e] + yc[e] + k) / 10 | 0;\n    // No need to check for zero, as +x + +y != 0 && -x + -y != 0\n    if (k) {\n        xc.unshift(k);\n        ++ye;\n    }\n    // Remove trailing zeros.\n    for(e = xc.length; xc[--e] === 0;)xc.pop();\n    y.c = xc;\n    y.e = ye;\n    return y;\n};\n/*\r\n * Return a Big whose value is the value of this Big raised to the power n.\r\n * If n is negative, round to a maximum of Big.DP decimal places using rounding\r\n * mode Big.RM.\r\n *\r\n * n {number} Integer, -MAX_POWER to MAX_POWER inclusive.\r\n */ P.pow = function(n) {\n    var x = this, one = new x.constructor(\"1\"), y = one, isneg = n < 0;\n    if (n !== ~~n || n < -MAX_POWER || n > MAX_POWER) {\n        throw Error(INVALID + \"exponent\");\n    }\n    if (isneg) n = -n;\n    for(;;){\n        if (n & 1) y = y.times(x);\n        n >>= 1;\n        if (!n) break;\n        x = x.times(x);\n    }\n    return isneg ? one.div(y) : y;\n};\n/*\r\n * Return a new Big whose value is the value of this Big rounded to a maximum precision of sd\r\n * significant digits using rounding mode rm, or Big.RM if rm is not specified.\r\n *\r\n * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.\r\n * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n */ P.prec = function(sd, rm) {\n    if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {\n        throw Error(INVALID + \"precision\");\n    }\n    return round(new this.constructor(this), sd, rm);\n};\n/*\r\n * Return a new Big whose value is the value of this Big rounded to a maximum of dp decimal places\r\n * using rounding mode rm, or Big.RM if rm is not specified.\r\n * If dp is negative, round to an integer which is a multiple of 10**-dp.\r\n * If dp is not specified, round to 0 decimal places.\r\n *\r\n * dp? {number} Integer, -MAX_DP to MAX_DP inclusive.\r\n * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n */ P.round = function(dp, rm) {\n    if (dp === UNDEFINED) dp = 0;\n    else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP) {\n        throw Error(INVALID_DP);\n    }\n    return round(new this.constructor(this), dp + this.e + 1, rm);\n};\n/*\r\n * Return a new Big whose value is the square root of the value of this Big, rounded, if\r\n * necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.\r\n */ P.sqrt = function() {\n    var r, c, t, x = this, Big = x.constructor, s = x.s, e = x.e, half = new Big(\"0.5\");\n    // Zero?\n    if (!x.c[0]) return new Big(x);\n    // Negative?\n    if (s < 0) {\n        throw Error(NAME + \"No square root\");\n    }\n    // Estimate.\n    s = Math.sqrt(x + \"\");\n    // Math.sqrt underflow/overflow?\n    // Re-estimate: pass x coefficient to Math.sqrt as integer, then adjust the result exponent.\n    if (s === 0 || s === 1 / 0) {\n        c = x.c.join(\"\");\n        if (!(c.length + e & 1)) c += \"0\";\n        s = Math.sqrt(c);\n        e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);\n        r = new Big((s == 1 / 0 ? \"5e\" : (s = s.toExponential()).slice(0, s.indexOf(\"e\") + 1)) + e);\n    } else {\n        r = new Big(s + \"\");\n    }\n    e = r.e + (Big.DP += 4);\n    // Newton-Raphson iteration.\n    do {\n        t = r;\n        r = half.times(t.plus(x.div(t)));\n    }while (t.c.slice(0, e).join(\"\") !== r.c.slice(0, e).join(\"\"));\n    return round(r, (Big.DP -= 4) + r.e + 1, Big.RM);\n};\n/*\r\n * Return a new Big whose value is the value of this Big times the value of Big y.\r\n */ P.times = P.mul = function(y) {\n    var c, x = this, Big = x.constructor, xc = x.c, yc = (y = new Big(y)).c, a = xc.length, b = yc.length, i = x.e, j = y.e;\n    // Determine sign of result.\n    y.s = x.s == y.s ? 1 : -1;\n    // Return signed 0 if either 0.\n    if (!xc[0] || !yc[0]) {\n        y.c = [\n            y.e = 0\n        ];\n        return y;\n    }\n    // Initialise exponent of result as x.e + y.e.\n    y.e = i + j;\n    // If array xc has fewer digits than yc, swap xc and yc, and lengths.\n    if (a < b) {\n        c = xc;\n        xc = yc;\n        yc = c;\n        j = a;\n        a = b;\n        b = j;\n    }\n    // Initialise coefficient array of result with zeros.\n    for(c = new Array(j = a + b); j--;)c[j] = 0;\n    // Multiply.\n    // i is initially xc.length.\n    for(i = b; i--;){\n        b = 0;\n        // a is yc.length.\n        for(j = a + i; j > i;){\n            // Current sum of products at this digit position, plus carry.\n            b = c[j] + yc[i] * xc[j - i - 1] + b;\n            c[j--] = b % 10;\n            // carry\n            b = b / 10 | 0;\n        }\n        c[j] = b;\n    }\n    // Increment result exponent if there is a final carry, otherwise remove leading zero.\n    if (b) ++y.e;\n    else c.shift();\n    // Remove trailing zeros.\n    for(i = c.length; !c[--i];)c.pop();\n    y.c = c;\n    return y;\n};\n/*\r\n * Return a string representing the value of this Big in exponential notation rounded to dp fixed\r\n * decimal places using rounding mode rm, or Big.RM if rm is not specified.\r\n *\r\n * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.\r\n * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n */ P.toExponential = function(dp, rm) {\n    var x = this, n = x.c[0];\n    if (dp !== UNDEFINED) {\n        if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {\n            throw Error(INVALID_DP);\n        }\n        x = round(new x.constructor(x), ++dp, rm);\n        for(; x.c.length < dp;)x.c.push(0);\n    }\n    return stringify(x, true, !!n);\n};\n/*\r\n * Return a string representing the value of this Big in normal notation rounded to dp fixed\r\n * decimal places using rounding mode rm, or Big.RM if rm is not specified.\r\n *\r\n * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.\r\n * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n *\r\n * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.\r\n * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.\r\n */ P.toFixed = function(dp, rm) {\n    var x = this, n = x.c[0];\n    if (dp !== UNDEFINED) {\n        if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {\n            throw Error(INVALID_DP);\n        }\n        x = round(new x.constructor(x), dp + x.e + 1, rm);\n        // x.e may have changed if the value is rounded up.\n        for(dp = dp + x.e + 1; x.c.length < dp;)x.c.push(0);\n    }\n    return stringify(x, false, !!n);\n};\n/*\r\n * Return a string representing the value of this Big.\r\n * Return exponential notation if this Big has a positive exponent equal to or greater than\r\n * Big.PE, or a negative exponent equal to or less than Big.NE.\r\n * Omit the sign for negative zero.\r\n */ P[Symbol.for(\"nodejs.util.inspect.custom\")] = P.toJSON = P.toString = function() {\n    var x = this, Big = x.constructor;\n    return stringify(x, x.e <= Big.NE || x.e >= Big.PE, !!x.c[0]);\n};\n/*\r\n * Return the value of this Big as a primitve number.\r\n */ P.toNumber = function() {\n    var n = Number(stringify(this, true, true));\n    if (this.constructor.strict === true && !this.eq(n.toString())) {\n        throw Error(NAME + \"Imprecise conversion\");\n    }\n    return n;\n};\n/*\r\n * Return a string representing the value of this Big rounded to sd significant digits using\r\n * rounding mode rm, or Big.RM if rm is not specified.\r\n * Use exponential notation if sd is less than the number of digits necessary to represent\r\n * the integer part of the value in normal notation.\r\n *\r\n * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.\r\n * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n */ P.toPrecision = function(sd, rm) {\n    var x = this, Big = x.constructor, n = x.c[0];\n    if (sd !== UNDEFINED) {\n        if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {\n            throw Error(INVALID + \"precision\");\n        }\n        x = round(new Big(x), sd, rm);\n        for(; x.c.length < sd;)x.c.push(0);\n    }\n    return stringify(x, sd <= x.e || x.e <= Big.NE || x.e >= Big.PE, !!n);\n};\n/*\r\n * Return a string representing the value of this Big.\r\n * Return exponential notation if this Big has a positive exponent equal to or greater than\r\n * Big.PE, or a negative exponent equal to or less than Big.NE.\r\n * Include the sign for negative zero.\r\n */ P.valueOf = function() {\n    var x = this, Big = x.constructor;\n    if (Big.strict === true) {\n        throw Error(NAME + \"valueOf disallowed\");\n    }\n    return stringify(x, x.e <= Big.NE || x.e >= Big.PE, true);\n};\n// Export\nvar Big = _Big_();\n/// <reference types=\"https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/master/types/big.js/index.d.ts\" />\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Big);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vYmlnLmpzQDYuMi4xL25vZGVfbW9kdWxlcy9iaWcuanMvYmlnLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7OztDQUtDLEdBR0Qsa0dBQWtHLEdBR2hHLHNFQUFzRTtBQUV0RTs7O0dBR0MsR0FDSCxJQUFJQSxLQUFLLElBRVA7Ozs7Ozs7R0FPQyxHQUNEQyxLQUFLLEdBRUwsc0NBQXNDO0FBQ3RDQyxTQUFTLEtBRVQsb0VBQW9FO0FBQ3BFQyxZQUFZLEtBRVo7Ozs7R0FJQyxHQUNEQyxLQUFLLENBQUMsR0FFTjs7OztHQUlDLEdBQ0RDLEtBQUssSUFFTDs7OztHQUlDLEdBQ0RDLFNBQVMsT0FHWCxrR0FBa0csR0FHaEcsa0JBQWtCO0FBQ2xCQyxPQUFPLGFBQ1BDLFVBQVVELE9BQU8sWUFDakJFLGFBQWFELFVBQVUsa0JBQ3ZCRSxhQUFhRixVQUFVLGlCQUN2QkcsY0FBY0osT0FBTyxvQkFFckIsK0JBQStCO0FBQy9CSyxJQUFJLENBQUMsR0FDTEMsWUFBWSxLQUFLLEdBQ2pCQyxVQUFVO0FBR1o7O0NBRUMsR0FDRCxTQUFTQztJQUVQOzs7OztHQUtDLEdBQ0QsU0FBU0MsSUFBSUMsQ0FBQztRQUNaLElBQUlDLElBQUksSUFBSTtRQUVaLHdDQUF3QztRQUN4QyxJQUFJLENBQUVBLENBQUFBLGFBQWFGLEdBQUUsR0FBSSxPQUFPQyxNQUFNSixZQUFZRSxVQUFVLElBQUlDLElBQUlDO1FBRXBFLGFBQWE7UUFDYixJQUFJQSxhQUFhRCxLQUFLO1lBQ3BCRSxFQUFFQyxDQUFDLEdBQUdGLEVBQUVFLENBQUM7WUFDVEQsRUFBRUUsQ0FBQyxHQUFHSCxFQUFFRyxDQUFDO1lBQ1RGLEVBQUVHLENBQUMsR0FBR0osRUFBRUksQ0FBQyxDQUFDQyxLQUFLO1FBQ2pCLE9BQU87WUFDTCxJQUFJLE9BQU9MLE1BQU0sVUFBVTtnQkFDekIsSUFBSUQsSUFBSU8sTUFBTSxLQUFLLFFBQVEsT0FBT04sTUFBTSxVQUFVO29CQUNo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RTtBQUdBOzs7OztDQUtDLEdBQ0RMLEVBQUV1RyxPQUFPLEdBQUc7SUFDVixJQUFJakcsSUFBSSxJQUFJLEVBQ1ZGLE1BQU1FLEVBQUVTLFdBQVc7SUFDckIsSUFBSVgsSUFBSU8sTUFBTSxLQUFLLE1BQU07UUFDdkIsTUFBTWEsTUFBTTdCLE9BQU87SUFDckI7SUFDQSxPQUFPMkMsVUFBVWhDLEdBQUdBLEVBQUVFLENBQUMsSUFBSUosSUFBSVosRUFBRSxJQUFJYyxFQUFFRSxDQUFDLElBQUlKLElBQUlYLEVBQUUsRUFBRTtBQUN0RDtBQUdBLFNBQVM7QUFHRixJQUFJVyxNQUFNRCxRQUFRO0FBRXpCLDBIQUEwSDtBQUMxSCxpRUFBZUMsR0FBR0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Nzcy1wYW5lbC8uL25vZGVfbW9kdWxlcy8ucG5wbS9iaWcuanNANi4yLjEvbm9kZV9tb2R1bGVzL2JpZy5qcy9iaWcubWpzP2M0ZGYiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogIGJpZy5qcyB2Ni4yLjFcclxuICogIEEgc21hbGwsIGZhc3QsIGVhc3ktdG8tdXNlIGxpYnJhcnkgZm9yIGFyYml0cmFyeS1wcmVjaXNpb24gZGVjaW1hbCBhcml0aG1ldGljLlxyXG4gKiAgQ29weXJpZ2h0IChjKSAyMDIyIE1pY2hhZWwgTWNsYXVnaGxpblxyXG4gKiAgaHR0cHM6Ly9naXRodWIuY29tL01pa2VNY2wvYmlnLmpzL0xJQ0VOQ0UubWRcclxuICovXHJcblxyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIEVESVRBQkxFIERFRkFVTFRTICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuXHJcbiAgLy8gVGhlIGRlZmF1bHQgdmFsdWVzIGJlbG93IG11c3QgYmUgaW50ZWdlcnMgd2l0aGluIHRoZSBzdGF0ZWQgcmFuZ2VzLlxyXG5cclxuICAvKlxyXG4gICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyAoRFApIG9mIHRoZSByZXN1bHRzIG9mIG9wZXJhdGlvbnMgaW52b2x2aW5nIGRpdmlzaW9uOlxyXG4gICAqIGRpdiBhbmQgc3FydCwgYW5kIHBvdyB3aXRoIG5lZ2F0aXZlIGV4cG9uZW50cy5cclxuICAgKi9cclxudmFyIERQID0gMjAsICAgICAgICAgIC8vIDAgdG8gTUFYX0RQXHJcblxyXG4gIC8qXHJcbiAgICogVGhlIHJvdW5kaW5nIG1vZGUgKFJNKSB1c2VkIHdoZW4gcm91bmRpbmcgdG8gdGhlIGFib3ZlIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAqXHJcbiAgICogIDAgIFRvd2FyZHMgemVybyAoaS5lLiB0cnVuY2F0ZSwgbm8gcm91bmRpbmcpLiAgICAgICAoUk9VTkRfRE9XTilcclxuICAgKiAgMSAgVG8gbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCByb3VuZCB1cC4gIChST1VORF9IQUxGX1VQKVxyXG4gICAqICAyICBUbyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvIGV2ZW4uICAgKFJPVU5EX0hBTEZfRVZFTilcclxuICAgKiAgMyAgQXdheSBmcm9tIHplcm8uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChST1VORF9VUClcclxuICAgKi9cclxuICBSTSA9IDEsICAgICAgICAgICAgIC8vIDAsIDEsIDIgb3IgM1xyXG5cclxuICAvLyBUaGUgbWF4aW11bSB2YWx1ZSBvZiBEUCBhbmQgQmlnLkRQLlxyXG4gIE1BWF9EUCA9IDFFNiwgICAgICAgLy8gMCB0byAxMDAwMDAwXHJcblxyXG4gIC8vIFRoZSBtYXhpbXVtIG1hZ25pdHVkZSBvZiB0aGUgZXhwb25lbnQgYXJndW1lbnQgdG8gdGhlIHBvdyBtZXRob2QuXHJcbiAgTUFYX1BPV0VSID0gMUU2LCAgICAvLyAxIHRvIDEwMDAwMDBcclxuXHJcbiAgLypcclxuICAgKiBUaGUgbmVnYXRpdmUgZXhwb25lbnQgKE5FKSBhdCBhbmQgYmVuZWF0aCB3aGljaCB0b1N0cmluZyByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAqIChKYXZhU2NyaXB0IG51bWJlcnM6IC03KVxyXG4gICAqIC0xMDAwMDAwIGlzIHRoZSBtaW5pbXVtIHJlY29tbWVuZGVkIGV4cG9uZW50IHZhbHVlIG9mIGEgQmlnLlxyXG4gICAqL1xyXG4gIE5FID0gLTcsICAgICAgICAgICAgLy8gMCB0byAtMTAwMDAwMFxyXG5cclxuICAvKlxyXG4gICAqIFRoZSBwb3NpdGl2ZSBleHBvbmVudCAoUEUpIGF0IGFuZCBhYm92ZSB3aGljaCB0b1N0cmluZyByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAqIChKYXZhU2NyaXB0IG51bWJlcnM6IDIxKVxyXG4gICAqIDEwMDAwMDAgaXMgdGhlIG1heGltdW0gcmVjb21tZW5kZWQgZXhwb25lbnQgdmFsdWUgb2YgYSBCaWcsIGJ1dCB0aGlzIGxpbWl0IGlzIG5vdCBlbmZvcmNlZC5cclxuICAgKi9cclxuICBQRSA9IDIxLCAgICAgICAgICAgIC8vIDAgdG8gMTAwMDAwMFxyXG5cclxuICAvKlxyXG4gICAqIFdoZW4gdHJ1ZSwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24gaWYgYSBwcmltaXRpdmUgbnVtYmVyIGlzIHBhc3NlZCB0byB0aGUgQmlnIGNvbnN0cnVjdG9yLFxyXG4gICAqIG9yIGlmIHZhbHVlT2YgaXMgY2FsbGVkLCBvciBpZiB0b051bWJlciBpcyBjYWxsZWQgb24gYSBCaWcgd2hpY2ggY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhXHJcbiAgICogcHJpbWl0aXZlIG51bWJlciB3aXRob3V0IGEgbG9zcyBvZiBwcmVjaXNpb24uXHJcbiAgICovXHJcbiAgU1RSSUNUID0gZmFsc2UsICAgICAvLyB0cnVlIG9yIGZhbHNlXHJcblxyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuXHJcbiAgLy8gRXJyb3IgbWVzc2FnZXMuXHJcbiAgTkFNRSA9ICdbYmlnLmpzXSAnLFxyXG4gIElOVkFMSUQgPSBOQU1FICsgJ0ludmFsaWQgJyxcclxuICBJTlZBTElEX0RQID0gSU5WQUxJRCArICdkZWNpbWFsIHBsYWNlcycsXHJcbiAgSU5WQUxJRF9STSA9IElOVkFMSUQgKyAncm91bmRpbmcgbW9kZScsXHJcbiAgRElWX0JZX1pFUk8gPSBOQU1FICsgJ0RpdmlzaW9uIGJ5IHplcm8nLFxyXG5cclxuICAvLyBUaGUgc2hhcmVkIHByb3RvdHlwZSBvYmplY3QuXHJcbiAgUCA9IHt9LFxyXG4gIFVOREVGSU5FRCA9IHZvaWQgMCxcclxuICBOVU1FUklDID0gL14tPyhcXGQrKFxcLlxcZCopP3xcXC5cXGQrKShlWystXT9cXGQrKT8kL2k7XHJcblxyXG5cclxuLypcclxuICogQ3JlYXRlIGFuZCByZXR1cm4gYSBCaWcgY29uc3RydWN0b3IuXHJcbiAqL1xyXG5mdW5jdGlvbiBfQmlnXygpIHtcclxuXHJcbiAgLypcclxuICAgKiBUaGUgQmlnIGNvbnN0cnVjdG9yIGFuZCBleHBvcnRlZCBmdW5jdGlvbi5cclxuICAgKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBpbnN0YW5jZSBvZiBhIEJpZyBudW1iZXIgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogbiB7bnVtYmVyfHN0cmluZ3xCaWd9IEEgbnVtZXJpYyB2YWx1ZS5cclxuICAgKi9cclxuICBmdW5jdGlvbiBCaWcobikge1xyXG4gICAgdmFyIHggPSB0aGlzO1xyXG5cclxuICAgIC8vIEVuYWJsZSBjb25zdHJ1Y3RvciB1c2FnZSB3aXRob3V0IG5ldy5cclxuICAgIGlmICghKHggaW5zdGFuY2VvZiBCaWcpKSByZXR1cm4gbiA9PT0gVU5ERUZJTkVEID8gX0JpZ18oKSA6IG5ldyBCaWcobik7XHJcblxyXG4gICAgLy8gRHVwbGljYXRlLlxyXG4gICAgaWYgKG4gaW5zdGFuY2VvZiBCaWcpIHtcclxuICAgICAgeC5zID0gbi5zO1xyXG4gICAgICB4LmUgPSBuLmU7XHJcbiAgICAgIHguYyA9IG4uYy5zbGljZSgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHR5cGVvZiBuICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGlmIChCaWcuc3RyaWN0ID09PSB0cnVlICYmIHR5cGVvZiBuICE9PSAnYmlnaW50Jykge1xyXG4gICAgICAgICAgdGhyb3cgVHlwZUVycm9yKElOVkFMSUQgKyAndmFsdWUnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE1pbnVzIHplcm8/XHJcbiAgICAgICAgbiA9IG4gPT09IDAgJiYgMSAvIG4gPCAwID8gJy0wJyA6IFN0cmluZyhuKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcGFyc2UoeCwgbik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmV0YWluIGEgcmVmZXJlbmNlIHRvIHRoaXMgQmlnIGNvbnN0cnVjdG9yLlxyXG4gICAgLy8gU2hhZG93IEJpZy5wcm90b3R5cGUuY29uc3RydWN0b3Igd2hpY2ggcG9pbnRzIHRvIE9iamVjdC5cclxuICAgIHguY29uc3RydWN0b3IgPSBCaWc7XHJcbiAgfVxyXG5cclxuICBCaWcucHJvdG90eXBlID0gUDtcclxuICBCaWcuRFAgPSBEUDtcclxuICBCaWcuUk0gPSBSTTtcclxuICBCaWcuTkUgPSBORTtcclxuICBCaWcuUEUgPSBQRTtcclxuICBCaWcuc3RyaWN0ID0gU1RSSUNUO1xyXG4gIEJpZy5yb3VuZERvd24gPSAwO1xyXG4gIEJpZy5yb3VuZEhhbGZVcCA9IDE7XHJcbiAgQmlnLnJvdW5kSGFsZkV2ZW4gPSAyO1xyXG4gIEJpZy5yb3VuZFVwID0gMztcclxuXHJcbiAgcmV0dXJuIEJpZztcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFBhcnNlIHRoZSBudW1iZXIgb3Igc3RyaW5nIHZhbHVlIHBhc3NlZCB0byBhIEJpZyBjb25zdHJ1Y3Rvci5cclxuICpcclxuICogeCB7QmlnfSBBIEJpZyBudW1iZXIgaW5zdGFuY2UuXHJcbiAqIG4ge251bWJlcnxzdHJpbmd9IEEgbnVtZXJpYyB2YWx1ZS5cclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlKHgsIG4pIHtcclxuICB2YXIgZSwgaSwgbmw7XHJcblxyXG4gIGlmICghTlVNRVJJQy50ZXN0KG4pKSB7XHJcbiAgICB0aHJvdyBFcnJvcihJTlZBTElEICsgJ251bWJlcicpO1xyXG4gIH1cclxuXHJcbiAgLy8gRGV0ZXJtaW5lIHNpZ24uXHJcbiAgeC5zID0gbi5jaGFyQXQoMCkgPT0gJy0nID8gKG4gPSBuLnNsaWNlKDEpLCAtMSkgOiAxO1xyXG5cclxuICAvLyBEZWNpbWFsIHBvaW50P1xyXG4gIGlmICgoZSA9IG4uaW5kZXhPZignLicpKSA+IC0xKSBuID0gbi5yZXBsYWNlKCcuJywgJycpO1xyXG5cclxuICAvLyBFeHBvbmVudGlhbCBmb3JtP1xyXG4gIGlmICgoaSA9IG4uc2VhcmNoKC9lL2kpKSA+IDApIHtcclxuXHJcbiAgICAvLyBEZXRlcm1pbmUgZXhwb25lbnQuXHJcbiAgICBpZiAoZSA8IDApIGUgPSBpO1xyXG4gICAgZSArPSArbi5zbGljZShpICsgMSk7XHJcbiAgICBuID0gbi5zdWJzdHJpbmcoMCwgaSk7XHJcbiAgfSBlbHNlIGlmIChlIDwgMCkge1xyXG5cclxuICAgIC8vIEludGVnZXIuXHJcbiAgICBlID0gbi5sZW5ndGg7XHJcbiAgfVxyXG5cclxuICBubCA9IG4ubGVuZ3RoO1xyXG5cclxuICAvLyBEZXRlcm1pbmUgbGVhZGluZyB6ZXJvcy5cclxuICBmb3IgKGkgPSAwOyBpIDwgbmwgJiYgbi5jaGFyQXQoaSkgPT0gJzAnOykgKytpO1xyXG5cclxuICBpZiAoaSA9PSBubCkge1xyXG5cclxuICAgIC8vIFplcm8uXHJcbiAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgfSBlbHNlIHtcclxuXHJcbiAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICBmb3IgKDsgbmwgPiAwICYmIG4uY2hhckF0KC0tbmwpID09ICcwJzspO1xyXG4gICAgeC5lID0gZSAtIGkgLSAxO1xyXG4gICAgeC5jID0gW107XHJcblxyXG4gICAgLy8gQ29udmVydCBzdHJpbmcgdG8gYXJyYXkgb2YgZGlnaXRzIHdpdGhvdXQgbGVhZGluZy90cmFpbGluZyB6ZXJvcy5cclxuICAgIGZvciAoZSA9IDA7IGkgPD0gbmw7KSB4LmNbZSsrXSA9ICtuLmNoYXJBdChpKyspO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHg7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSb3VuZCBCaWcgeCB0byBhIG1heGltdW0gb2Ygc2Qgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0uXHJcbiAqXHJcbiAqIHgge0JpZ30gVGhlIEJpZyB0byByb3VuZC5cclxuICogc2Qge251bWJlcn0gU2lnbmlmaWNhbnQgZGlnaXRzOiBpbnRlZ2VyLCAwIHRvIE1BWF9EUCBpbmNsdXNpdmUuXHJcbiAqIHJtIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGU6IDAgKGRvd24pLCAxIChoYWxmLXVwKSwgMiAoaGFsZi1ldmVuKSBvciAzICh1cCkuXHJcbiAqIFttb3JlXSB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcmVzdWx0IG9mIGRpdmlzaW9uIHdhcyB0cnVuY2F0ZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiByb3VuZCh4LCBzZCwgcm0sIG1vcmUpIHtcclxuICB2YXIgeGMgPSB4LmM7XHJcblxyXG4gIGlmIChybSA9PT0gVU5ERUZJTkVEKSBybSA9IHguY29uc3RydWN0b3IuUk07XHJcbiAgaWYgKHJtICE9PSAwICYmIHJtICE9PSAxICYmIHJtICE9PSAyICYmIHJtICE9PSAzKSB7XHJcbiAgICB0aHJvdyBFcnJvcihJTlZBTElEX1JNKTtcclxuICB9XHJcblxyXG4gIGlmIChzZCA8IDEpIHtcclxuICAgIG1vcmUgPVxyXG4gICAgICBybSA9PT0gMyAmJiAobW9yZSB8fCAhIXhjWzBdKSB8fCBzZCA9PT0gMCAmJiAoXHJcbiAgICAgIHJtID09PSAxICYmIHhjWzBdID49IDUgfHxcclxuICAgICAgcm0gPT09IDIgJiYgKHhjWzBdID4gNSB8fCB4Y1swXSA9PT0gNSAmJiAobW9yZSB8fCB4Y1sxXSAhPT0gVU5ERUZJTkVEKSlcclxuICAgICk7XHJcblxyXG4gICAgeGMubGVuZ3RoID0gMTtcclxuXHJcbiAgICBpZiAobW9yZSkge1xyXG5cclxuICAgICAgLy8gMSwgMC4xLCAwLjAxLCAwLjAwMSwgMC4wMDAxIGV0Yy5cclxuICAgICAgeC5lID0geC5lIC0gc2QgKyAxO1xyXG4gICAgICB4Y1swXSA9IDE7XHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgLy8gWmVyby5cclxuICAgICAgeGNbMF0gPSB4LmUgPSAwO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoc2QgPCB4Yy5sZW5ndGgpIHtcclxuXHJcbiAgICAvLyB4Y1tzZF0gaXMgdGhlIGRpZ2l0IGFmdGVyIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwLlxyXG4gICAgbW9yZSA9XHJcbiAgICAgIHJtID09PSAxICYmIHhjW3NkXSA+PSA1IHx8XHJcbiAgICAgIHJtID09PSAyICYmICh4Y1tzZF0gPiA1IHx8IHhjW3NkXSA9PT0gNSAmJlxyXG4gICAgICAgIChtb3JlIHx8IHhjW3NkICsgMV0gIT09IFVOREVGSU5FRCB8fCB4Y1tzZCAtIDFdICYgMSkpIHx8XHJcbiAgICAgIHJtID09PSAzICYmIChtb3JlIHx8ICEheGNbMF0pO1xyXG5cclxuICAgIC8vIFJlbW92ZSBhbnkgZGlnaXRzIGFmdGVyIHRoZSByZXF1aXJlZCBwcmVjaXNpb24uXHJcbiAgICB4Yy5sZW5ndGggPSBzZDtcclxuXHJcbiAgICAvLyBSb3VuZCB1cD9cclxuICAgIGlmIChtb3JlKSB7XHJcblxyXG4gICAgICAvLyBSb3VuZGluZyB1cCBtYXkgbWVhbiB0aGUgcHJldmlvdXMgZGlnaXQgaGFzIHRvIGJlIHJvdW5kZWQgdXAuXHJcbiAgICAgIGZvciAoOyArK3hjWy0tc2RdID4gOTspIHtcclxuICAgICAgICB4Y1tzZF0gPSAwO1xyXG4gICAgICAgIGlmIChzZCA9PT0gMCkge1xyXG4gICAgICAgICAgKyt4LmU7XHJcbiAgICAgICAgICB4Yy51bnNoaWZ0KDEpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgZm9yIChzZCA9IHhjLmxlbmd0aDsgIXhjWy0tc2RdOykgeGMucG9wKCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4geDtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIEJpZyB4IGluIG5vcm1hbCBvciBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICogSGFuZGxlcyBQLnRvRXhwb25lbnRpYWwsIFAudG9GaXhlZCwgUC50b0pTT04sIFAudG9QcmVjaXNpb24sIFAudG9TdHJpbmcgYW5kIFAudmFsdWVPZi5cclxuICovXHJcbmZ1bmN0aW9uIHN0cmluZ2lmeSh4LCBkb0V4cG9uZW50aWFsLCBpc05vbnplcm8pIHtcclxuICB2YXIgZSA9IHguZSxcclxuICAgIHMgPSB4LmMuam9pbignJyksXHJcbiAgICBuID0gcy5sZW5ndGg7XHJcblxyXG4gIC8vIEV4cG9uZW50aWFsIG5vdGF0aW9uP1xyXG4gIGlmIChkb0V4cG9uZW50aWFsKSB7XHJcbiAgICBzID0gcy5jaGFyQXQoMCkgKyAobiA+IDEgPyAnLicgKyBzLnNsaWNlKDEpIDogJycpICsgKGUgPCAwID8gJ2UnIDogJ2UrJykgKyBlO1xyXG5cclxuICAvLyBOb3JtYWwgbm90YXRpb24uXHJcbiAgfSBlbHNlIGlmIChlIDwgMCkge1xyXG4gICAgZm9yICg7ICsrZTspIHMgPSAnMCcgKyBzO1xyXG4gICAgcyA9ICcwLicgKyBzO1xyXG4gIH0gZWxzZSBpZiAoZSA+IDApIHtcclxuICAgIGlmICgrK2UgPiBuKSB7XHJcbiAgICAgIGZvciAoZSAtPSBuOyBlLS07KSBzICs9ICcwJztcclxuICAgIH0gZWxzZSBpZiAoZSA8IG4pIHtcclxuICAgICAgcyA9IHMuc2xpY2UoMCwgZSkgKyAnLicgKyBzLnNsaWNlKGUpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAobiA+IDEpIHtcclxuICAgIHMgPSBzLmNoYXJBdCgwKSArICcuJyArIHMuc2xpY2UoMSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4geC5zIDwgMCAmJiBpc05vbnplcm8gPyAnLScgKyBzIDogcztcclxufVxyXG5cclxuXHJcbi8vIFByb3RvdHlwZS9pbnN0YW5jZSBtZXRob2RzXHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IEJpZyB3aG9zZSB2YWx1ZSBpcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhpcyBCaWcuXHJcbiAqL1xyXG5QLmFicyA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgeCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpO1xyXG4gIHgucyA9IDE7XHJcbiAgcmV0dXJuIHg7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIDEgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgb2YgQmlnIHksXHJcbiAqICAgICAgIC0xIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZyBpcyBsZXNzIHRoYW4gdGhlIHZhbHVlIG9mIEJpZyB5LCBvclxyXG4gKiAgICAgICAgMCBpZiB0aGV5IGhhdmUgdGhlIHNhbWUgdmFsdWUuXHJcbiAqL1xyXG5QLmNtcCA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgdmFyIGlzbmVnLFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICB4YyA9IHguYyxcclxuICAgIHljID0gKHkgPSBuZXcgeC5jb25zdHJ1Y3Rvcih5KSkuYyxcclxuICAgIGkgPSB4LnMsXHJcbiAgICBqID0geS5zLFxyXG4gICAgayA9IHguZSxcclxuICAgIGwgPSB5LmU7XHJcblxyXG4gIC8vIEVpdGhlciB6ZXJvP1xyXG4gIGlmICgheGNbMF0gfHwgIXljWzBdKSByZXR1cm4gIXhjWzBdID8gIXljWzBdID8gMCA6IC1qIDogaTtcclxuXHJcbiAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gIGlmIChpICE9IGopIHJldHVybiBpO1xyXG5cclxuICBpc25lZyA9IGkgPCAwO1xyXG5cclxuICAvLyBDb21wYXJlIGV4cG9uZW50cy5cclxuICBpZiAoayAhPSBsKSByZXR1cm4gayA+IGwgXiBpc25lZyA/IDEgOiAtMTtcclxuXHJcbiAgaiA9IChrID0geGMubGVuZ3RoKSA8IChsID0geWMubGVuZ3RoKSA/IGsgOiBsO1xyXG5cclxuICAvLyBDb21wYXJlIGRpZ2l0IGJ5IGRpZ2l0LlxyXG4gIGZvciAoaSA9IC0xOyArK2kgPCBqOykge1xyXG4gICAgaWYgKHhjW2ldICE9IHljW2ldKSByZXR1cm4geGNbaV0gPiB5Y1tpXSBeIGlzbmVnID8gMSA6IC0xO1xyXG4gIH1cclxuXHJcbiAgLy8gQ29tcGFyZSBsZW5ndGhzLlxyXG4gIHJldHVybiBrID09IGwgPyAwIDogayA+IGwgXiBpc25lZyA/IDEgOiAtMTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgQmlnIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZyBkaXZpZGVkIGJ5IHRoZSB2YWx1ZSBvZiBCaWcgeSwgcm91bmRlZCxcclxuICogaWYgbmVjZXNzYXJ5LCB0byBhIG1heGltdW0gb2YgQmlnLkRQIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgQmlnLlJNLlxyXG4gKi9cclxuUC5kaXYgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHZhciB4ID0gdGhpcyxcclxuICAgIEJpZyA9IHguY29uc3RydWN0b3IsXHJcbiAgICBhID0geC5jLCAgICAgICAgICAgICAgICAgIC8vIGRpdmlkZW5kXHJcbiAgICBiID0gKHkgPSBuZXcgQmlnKHkpKS5jLCAgIC8vIGRpdmlzb3JcclxuICAgIGsgPSB4LnMgPT0geS5zID8gMSA6IC0xLFxyXG4gICAgZHAgPSBCaWcuRFA7XHJcblxyXG4gIGlmIChkcCAhPT0gfn5kcCB8fCBkcCA8IDAgfHwgZHAgPiBNQVhfRFApIHtcclxuICAgIHRocm93IEVycm9yKElOVkFMSURfRFApO1xyXG4gIH1cclxuXHJcbiAgLy8gRGl2aXNvciBpcyB6ZXJvP1xyXG4gIGlmICghYlswXSkge1xyXG4gICAgdGhyb3cgRXJyb3IoRElWX0JZX1pFUk8pO1xyXG4gIH1cclxuXHJcbiAgLy8gRGl2aWRlbmQgaXMgMD8gUmV0dXJuICstMC5cclxuICBpZiAoIWFbMF0pIHtcclxuICAgIHkucyA9IGs7XHJcbiAgICB5LmMgPSBbeS5lID0gMF07XHJcbiAgICByZXR1cm4geTtcclxuICB9XHJcblxyXG4gIHZhciBibCwgYnQsIG4sIGNtcCwgcmksXHJcbiAgICBieiA9IGIuc2xpY2UoKSxcclxuICAgIGFpID0gYmwgPSBiLmxlbmd0aCxcclxuICAgIGFsID0gYS5sZW5ndGgsXHJcbiAgICByID0gYS5zbGljZSgwLCBibCksICAgLy8gcmVtYWluZGVyXHJcbiAgICBybCA9IHIubGVuZ3RoLFxyXG4gICAgcSA9IHksICAgICAgICAgICAgICAgIC8vIHF1b3RpZW50XHJcbiAgICBxYyA9IHEuYyA9IFtdLFxyXG4gICAgcWkgPSAwLFxyXG4gICAgcCA9IGRwICsgKHEuZSA9IHguZSAtIHkuZSkgKyAxOyAgICAvLyBwcmVjaXNpb24gb2YgdGhlIHJlc3VsdFxyXG5cclxuICBxLnMgPSBrO1xyXG4gIGsgPSBwIDwgMCA/IDAgOiBwO1xyXG5cclxuICAvLyBDcmVhdGUgdmVyc2lvbiBvZiBkaXZpc29yIHdpdGggbGVhZGluZyB6ZXJvLlxyXG4gIGJ6LnVuc2hpZnQoMCk7XHJcblxyXG4gIC8vIEFkZCB6ZXJvcyB0byBtYWtlIHJlbWFpbmRlciBhcyBsb25nIGFzIGRpdmlzb3IuXHJcbiAgZm9yICg7IHJsKysgPCBibDspIHIucHVzaCgwKTtcclxuXHJcbiAgZG8ge1xyXG5cclxuICAgIC8vIG4gaXMgaG93IG1hbnkgdGltZXMgdGhlIGRpdmlzb3IgZ29lcyBpbnRvIGN1cnJlbnQgcmVtYWluZGVyLlxyXG4gICAgZm9yIChuID0gMDsgbiA8IDEwOyBuKyspIHtcclxuXHJcbiAgICAgIC8vIENvbXBhcmUgZGl2aXNvciBhbmQgcmVtYWluZGVyLlxyXG4gICAgICBpZiAoYmwgIT0gKHJsID0gci5sZW5ndGgpKSB7XHJcbiAgICAgICAgY21wID0gYmwgPiBybCA/IDEgOiAtMTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBmb3IgKHJpID0gLTEsIGNtcCA9IDA7ICsrcmkgPCBibDspIHtcclxuICAgICAgICAgIGlmIChiW3JpXSAhPSByW3JpXSkge1xyXG4gICAgICAgICAgICBjbXAgPSBiW3JpXSA+IHJbcmldID8gMSA6IC0xO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIElmIGRpdmlzb3IgPCByZW1haW5kZXIsIHN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgIGlmIChjbXAgPCAwKSB7XHJcblxyXG4gICAgICAgIC8vIFJlbWFpbmRlciBjYW4ndCBiZSBtb3JlIHRoYW4gMSBkaWdpdCBsb25nZXIgdGhhbiBkaXZpc29yLlxyXG4gICAgICAgIC8vIEVxdWFsaXNlIGxlbmd0aHMgdXNpbmcgZGl2aXNvciB3aXRoIGV4dHJhIGxlYWRpbmcgemVybz9cclxuICAgICAgICBmb3IgKGJ0ID0gcmwgPT0gYmwgPyBiIDogYno7IHJsOykge1xyXG4gICAgICAgICAgaWYgKHJbLS1ybF0gPCBidFtybF0pIHtcclxuICAgICAgICAgICAgcmkgPSBybDtcclxuICAgICAgICAgICAgZm9yICg7IHJpICYmICFyWy0tcmldOykgcltyaV0gPSA5O1xyXG4gICAgICAgICAgICAtLXJbcmldO1xyXG4gICAgICAgICAgICByW3JsXSArPSAxMDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJbcmxdIC09IGJ0W3JsXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoOyAhclswXTspIHIuc2hpZnQoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEFkZCB0aGUgZGlnaXQgbiB0byB0aGUgcmVzdWx0IGFycmF5LlxyXG4gICAgcWNbcWkrK10gPSBjbXAgPyBuIDogKytuO1xyXG5cclxuICAgIC8vIFVwZGF0ZSB0aGUgcmVtYWluZGVyLlxyXG4gICAgaWYgKHJbMF0gJiYgY21wKSByW3JsXSA9IGFbYWldIHx8IDA7XHJcbiAgICBlbHNlIHIgPSBbYVthaV1dO1xyXG5cclxuICB9IHdoaWxlICgoYWkrKyA8IGFsIHx8IHJbMF0gIT09IFVOREVGSU5FRCkgJiYgay0tKTtcclxuXHJcbiAgLy8gTGVhZGluZyB6ZXJvPyBEbyBub3QgcmVtb3ZlIGlmIHJlc3VsdCBpcyBzaW1wbHkgemVybyAocWkgPT0gMSkuXHJcbiAgaWYgKCFxY1swXSAmJiBxaSAhPSAxKSB7XHJcblxyXG4gICAgLy8gVGhlcmUgY2FuJ3QgYmUgbW9yZSB0aGFuIG9uZSB6ZXJvLlxyXG4gICAgcWMuc2hpZnQoKTtcclxuICAgIHEuZS0tO1xyXG4gICAgcC0tO1xyXG4gIH1cclxuXHJcbiAgLy8gUm91bmQ/XHJcbiAgaWYgKHFpID4gcCkgcm91bmQocSwgcCwgQmlnLlJNLCByWzBdICE9PSBVTkRFRklORUQpO1xyXG5cclxuICByZXR1cm4gcTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgaXMgZXF1YWwgdG8gdGhlIHZhbHVlIG9mIEJpZyB5LCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gKi9cclxuUC5lcSA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgcmV0dXJuIHRoaXMuY21wKHkpID09PSAwO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZyBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIG9mIEJpZyB5LCBvdGhlcndpc2UgcmV0dXJuXHJcbiAqIGZhbHNlLlxyXG4gKi9cclxuUC5ndCA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgcmV0dXJuIHRoaXMuY21wKHkpID4gMDtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZiBCaWcgeSwgb3RoZXJ3aXNlXHJcbiAqIHJldHVybiBmYWxzZS5cclxuICovXHJcblAuZ3RlID0gZnVuY3Rpb24gKHkpIHtcclxuICByZXR1cm4gdGhpcy5jbXAoeSkgPiAtMTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgaXMgbGVzcyB0aGFuIHRoZSB2YWx1ZSBvZiBCaWcgeSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICovXHJcblAubHQgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHJldHVybiB0aGlzLmNtcCh5KSA8IDA7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgdmFsdWUgb2YgQmlnIHksIG90aGVyd2lzZVxyXG4gKiByZXR1cm4gZmFsc2UuXHJcbiAqL1xyXG5QLmx0ZSA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgcmV0dXJuIHRoaXMuY21wKHkpIDwgMTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgQmlnIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZyBtaW51cyB0aGUgdmFsdWUgb2YgQmlnIHkuXHJcbiAqL1xyXG5QLm1pbnVzID0gUC5zdWIgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHZhciBpLCBqLCB0LCB4bHR5LFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICBCaWcgPSB4LmNvbnN0cnVjdG9yLFxyXG4gICAgYSA9IHgucyxcclxuICAgIGIgPSAoeSA9IG5ldyBCaWcoeSkpLnM7XHJcblxyXG4gIC8vIFNpZ25zIGRpZmZlcj9cclxuICBpZiAoYSAhPSBiKSB7XHJcbiAgICB5LnMgPSAtYjtcclxuICAgIHJldHVybiB4LnBsdXMoeSk7XHJcbiAgfVxyXG5cclxuICB2YXIgeGMgPSB4LmMuc2xpY2UoKSxcclxuICAgIHhlID0geC5lLFxyXG4gICAgeWMgPSB5LmMsXHJcbiAgICB5ZSA9IHkuZTtcclxuXHJcbiAgLy8gRWl0aGVyIHplcm8/XHJcbiAgaWYgKCF4Y1swXSB8fCAheWNbMF0pIHtcclxuICAgIGlmICh5Y1swXSkge1xyXG4gICAgICB5LnMgPSAtYjtcclxuICAgIH0gZWxzZSBpZiAoeGNbMF0pIHtcclxuICAgICAgeSA9IG5ldyBCaWcoeCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB5LnMgPSAxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHk7XHJcbiAgfVxyXG5cclxuICAvLyBEZXRlcm1pbmUgd2hpY2ggaXMgdGhlIGJpZ2dlciBudW1iZXIuIFByZXBlbmQgemVyb3MgdG8gZXF1YWxpc2UgZXhwb25lbnRzLlxyXG4gIGlmIChhID0geGUgLSB5ZSkge1xyXG5cclxuICAgIGlmICh4bHR5ID0gYSA8IDApIHtcclxuICAgICAgYSA9IC1hO1xyXG4gICAgICB0ID0geGM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB5ZSA9IHhlO1xyXG4gICAgICB0ID0geWM7XHJcbiAgICB9XHJcblxyXG4gICAgdC5yZXZlcnNlKCk7XHJcbiAgICBmb3IgKGIgPSBhOyBiLS07KSB0LnB1c2goMCk7XHJcbiAgICB0LnJldmVyc2UoKTtcclxuICB9IGVsc2Uge1xyXG5cclxuICAgIC8vIEV4cG9uZW50cyBlcXVhbC4gQ2hlY2sgZGlnaXQgYnkgZGlnaXQuXHJcbiAgICBqID0gKCh4bHR5ID0geGMubGVuZ3RoIDwgeWMubGVuZ3RoKSA/IHhjIDogeWMpLmxlbmd0aDtcclxuXHJcbiAgICBmb3IgKGEgPSBiID0gMDsgYiA8IGo7IGIrKykge1xyXG4gICAgICBpZiAoeGNbYl0gIT0geWNbYl0pIHtcclxuICAgICAgICB4bHR5ID0geGNbYl0gPCB5Y1tiXTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8geCA8IHk/IFBvaW50IHhjIHRvIHRoZSBhcnJheSBvZiB0aGUgYmlnZ2VyIG51bWJlci5cclxuICBpZiAoeGx0eSkge1xyXG4gICAgdCA9IHhjO1xyXG4gICAgeGMgPSB5YztcclxuICAgIHljID0gdDtcclxuICAgIHkucyA9IC15LnM7XHJcbiAgfVxyXG5cclxuICAvKlxyXG4gICAqIEFwcGVuZCB6ZXJvcyB0byB4YyBpZiBzaG9ydGVyLiBObyBuZWVkIHRvIGFkZCB6ZXJvcyB0byB5YyBpZiBzaG9ydGVyIGFzIHN1YnRyYWN0aW9uIG9ubHlcclxuICAgKiBuZWVkcyB0byBzdGFydCBhdCB5Yy5sZW5ndGguXHJcbiAgICovXHJcbiAgaWYgKChiID0gKGogPSB5Yy5sZW5ndGgpIC0gKGkgPSB4Yy5sZW5ndGgpKSA+IDApIGZvciAoOyBiLS07KSB4Y1tpKytdID0gMDtcclxuXHJcbiAgLy8gU3VidHJhY3QgeWMgZnJvbSB4Yy5cclxuICBmb3IgKGIgPSBpOyBqID4gYTspIHtcclxuICAgIGlmICh4Y1stLWpdIDwgeWNbal0pIHtcclxuICAgICAgZm9yIChpID0gajsgaSAmJiAheGNbLS1pXTspIHhjW2ldID0gOTtcclxuICAgICAgLS14Y1tpXTtcclxuICAgICAgeGNbal0gKz0gMTA7XHJcbiAgICB9XHJcblxyXG4gICAgeGNbal0gLT0geWNbal07XHJcbiAgfVxyXG5cclxuICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgZm9yICg7IHhjWy0tYl0gPT09IDA7KSB4Yy5wb3AoKTtcclxuXHJcbiAgLy8gUmVtb3ZlIGxlYWRpbmcgemVyb3MgYW5kIGFkanVzdCBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICBmb3IgKDsgeGNbMF0gPT09IDA7KSB7XHJcbiAgICB4Yy5zaGlmdCgpO1xyXG4gICAgLS15ZTtcclxuICB9XHJcblxyXG4gIGlmICgheGNbMF0pIHtcclxuXHJcbiAgICAvLyBuIC0gbiA9ICswXHJcbiAgICB5LnMgPSAxO1xyXG5cclxuICAgIC8vIFJlc3VsdCBtdXN0IGJlIHplcm8uXHJcbiAgICB4YyA9IFt5ZSA9IDBdO1xyXG4gIH1cclxuXHJcbiAgeS5jID0geGM7XHJcbiAgeS5lID0geWU7XHJcblxyXG4gIHJldHVybiB5O1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBCaWcgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIG1vZHVsbyB0aGUgdmFsdWUgb2YgQmlnIHkuXHJcbiAqL1xyXG5QLm1vZCA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgdmFyIHlndHgsXHJcbiAgICB4ID0gdGhpcyxcclxuICAgIEJpZyA9IHguY29uc3RydWN0b3IsXHJcbiAgICBhID0geC5zLFxyXG4gICAgYiA9ICh5ID0gbmV3IEJpZyh5KSkucztcclxuXHJcbiAgaWYgKCF5LmNbMF0pIHtcclxuICAgIHRocm93IEVycm9yKERJVl9CWV9aRVJPKTtcclxuICB9XHJcblxyXG4gIHgucyA9IHkucyA9IDE7XHJcbiAgeWd0eCA9IHkuY21wKHgpID09IDE7XHJcbiAgeC5zID0gYTtcclxuICB5LnMgPSBiO1xyXG5cclxuICBpZiAoeWd0eCkgcmV0dXJuIG5ldyBCaWcoeCk7XHJcblxyXG4gIGEgPSBCaWcuRFA7XHJcbiAgYiA9IEJpZy5STTtcclxuICBCaWcuRFAgPSBCaWcuUk0gPSAwO1xyXG4gIHggPSB4LmRpdih5KTtcclxuICBCaWcuRFAgPSBhO1xyXG4gIEJpZy5STSA9IGI7XHJcblxyXG4gIHJldHVybiB0aGlzLm1pbnVzKHgudGltZXMoeSkpO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBCaWcgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIG5lZ2F0ZWQuXHJcbiAqL1xyXG5QLm5lZyA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgeCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpO1xyXG4gIHgucyA9IC14LnM7XHJcbiAgcmV0dXJuIHg7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IEJpZyB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgcGx1cyB0aGUgdmFsdWUgb2YgQmlnIHkuXHJcbiAqL1xyXG5QLnBsdXMgPSBQLmFkZCA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgdmFyIGUsIGssIHQsXHJcbiAgICB4ID0gdGhpcyxcclxuICAgIEJpZyA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gIHkgPSBuZXcgQmlnKHkpO1xyXG5cclxuICAvLyBTaWducyBkaWZmZXI/XHJcbiAgaWYgKHgucyAhPSB5LnMpIHtcclxuICAgIHkucyA9IC15LnM7XHJcbiAgICByZXR1cm4geC5taW51cyh5KTtcclxuICB9XHJcblxyXG4gIHZhciB4ZSA9IHguZSxcclxuICAgIHhjID0geC5jLFxyXG4gICAgeWUgPSB5LmUsXHJcbiAgICB5YyA9IHkuYztcclxuXHJcbiAgLy8gRWl0aGVyIHplcm8/XHJcbiAgaWYgKCF4Y1swXSB8fCAheWNbMF0pIHtcclxuICAgIGlmICgheWNbMF0pIHtcclxuICAgICAgaWYgKHhjWzBdKSB7XHJcbiAgICAgICAgeSA9IG5ldyBCaWcoeCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgeS5zID0geC5zO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4geTtcclxuICB9XHJcblxyXG4gIHhjID0geGMuc2xpY2UoKTtcclxuXHJcbiAgLy8gUHJlcGVuZCB6ZXJvcyB0byBlcXVhbGlzZSBleHBvbmVudHMuXHJcbiAgLy8gTm90ZTogcmV2ZXJzZSBmYXN0ZXIgdGhhbiB1bnNoaWZ0cy5cclxuICBpZiAoZSA9IHhlIC0geWUpIHtcclxuICAgIGlmIChlID4gMCkge1xyXG4gICAgICB5ZSA9IHhlO1xyXG4gICAgICB0ID0geWM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBlID0gLWU7XHJcbiAgICAgIHQgPSB4YztcclxuICAgIH1cclxuXHJcbiAgICB0LnJldmVyc2UoKTtcclxuICAgIGZvciAoOyBlLS07KSB0LnB1c2goMCk7XHJcbiAgICB0LnJldmVyc2UoKTtcclxuICB9XHJcblxyXG4gIC8vIFBvaW50IHhjIHRvIHRoZSBsb25nZXIgYXJyYXkuXHJcbiAgaWYgKHhjLmxlbmd0aCAtIHljLmxlbmd0aCA8IDApIHtcclxuICAgIHQgPSB5YztcclxuICAgIHljID0geGM7XHJcbiAgICB4YyA9IHQ7XHJcbiAgfVxyXG5cclxuICBlID0geWMubGVuZ3RoO1xyXG5cclxuICAvLyBPbmx5IHN0YXJ0IGFkZGluZyBhdCB5Yy5sZW5ndGggLSAxIGFzIHRoZSBmdXJ0aGVyIGRpZ2l0cyBvZiB4YyBjYW4gYmUgbGVmdCBhcyB0aGV5IGFyZS5cclxuICBmb3IgKGsgPSAwOyBlOyB4Y1tlXSAlPSAxMCkgayA9ICh4Y1stLWVdID0geGNbZV0gKyB5Y1tlXSArIGspIC8gMTAgfCAwO1xyXG5cclxuICAvLyBObyBuZWVkIHRvIGNoZWNrIGZvciB6ZXJvLCBhcyAreCArICt5ICE9IDAgJiYgLXggKyAteSAhPSAwXHJcblxyXG4gIGlmIChrKSB7XHJcbiAgICB4Yy51bnNoaWZ0KGspO1xyXG4gICAgKyt5ZTtcclxuICB9XHJcblxyXG4gIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICBmb3IgKGUgPSB4Yy5sZW5ndGg7IHhjWy0tZV0gPT09IDA7KSB4Yy5wb3AoKTtcclxuXHJcbiAgeS5jID0geGM7XHJcbiAgeS5lID0geWU7XHJcblxyXG4gIHJldHVybiB5O1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIEJpZyB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgcmFpc2VkIHRvIHRoZSBwb3dlciBuLlxyXG4gKiBJZiBuIGlzIG5lZ2F0aXZlLCByb3VuZCB0byBhIG1heGltdW0gb2YgQmlnLkRQIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nXHJcbiAqIG1vZGUgQmlnLlJNLlxyXG4gKlxyXG4gKiBuIHtudW1iZXJ9IEludGVnZXIsIC1NQVhfUE9XRVIgdG8gTUFYX1BPV0VSIGluY2x1c2l2ZS5cclxuICovXHJcblAucG93ID0gZnVuY3Rpb24gKG4pIHtcclxuICB2YXIgeCA9IHRoaXMsXHJcbiAgICBvbmUgPSBuZXcgeC5jb25zdHJ1Y3RvcignMScpLFxyXG4gICAgeSA9IG9uZSxcclxuICAgIGlzbmVnID0gbiA8IDA7XHJcblxyXG4gIGlmIChuICE9PSB+fm4gfHwgbiA8IC1NQVhfUE9XRVIgfHwgbiA+IE1BWF9QT1dFUikge1xyXG4gICAgdGhyb3cgRXJyb3IoSU5WQUxJRCArICdleHBvbmVudCcpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlzbmVnKSBuID0gLW47XHJcblxyXG4gIGZvciAoOzspIHtcclxuICAgIGlmIChuICYgMSkgeSA9IHkudGltZXMoeCk7XHJcbiAgICBuID4+PSAxO1xyXG4gICAgaWYgKCFuKSBicmVhaztcclxuICAgIHggPSB4LnRpbWVzKHgpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGlzbmVnID8gb25lLmRpdih5KSA6IHk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IEJpZyB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgcm91bmRlZCB0byBhIG1heGltdW0gcHJlY2lzaW9uIG9mIHNkXHJcbiAqIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvciBCaWcuUk0gaWYgcm0gaXMgbm90IHNwZWNpZmllZC5cclxuICpcclxuICogc2Qge251bWJlcn0gU2lnbmlmaWNhbnQgZGlnaXRzOiBpbnRlZ2VyLCAxIHRvIE1BWF9EUCBpbmNsdXNpdmUuXHJcbiAqIHJtPyB7bnVtYmVyfSBSb3VuZGluZyBtb2RlOiAwIChkb3duKSwgMSAoaGFsZi11cCksIDIgKGhhbGYtZXZlbikgb3IgMyAodXApLlxyXG4gKi9cclxuUC5wcmVjID0gZnVuY3Rpb24gKHNkLCBybSkge1xyXG4gIGlmIChzZCAhPT0gfn5zZCB8fCBzZCA8IDEgfHwgc2QgPiBNQVhfRFApIHtcclxuICAgIHRocm93IEVycm9yKElOVkFMSUQgKyAncHJlY2lzaW9uJyk7XHJcbiAgfVxyXG4gIHJldHVybiByb3VuZChuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKSwgc2QsIHJtKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgQmlnIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZyByb3VuZGVkIHRvIGEgbWF4aW11bSBvZiBkcCBkZWNpbWFsIHBsYWNlc1xyXG4gKiB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvciBCaWcuUk0gaWYgcm0gaXMgbm90IHNwZWNpZmllZC5cclxuICogSWYgZHAgaXMgbmVnYXRpdmUsIHJvdW5kIHRvIGFuIGludGVnZXIgd2hpY2ggaXMgYSBtdWx0aXBsZSBvZiAxMCoqLWRwLlxyXG4gKiBJZiBkcCBpcyBub3Qgc3BlY2lmaWVkLCByb3VuZCB0byAwIGRlY2ltYWwgcGxhY2VzLlxyXG4gKlxyXG4gKiBkcD8ge251bWJlcn0gSW50ZWdlciwgLU1BWF9EUCB0byBNQVhfRFAgaW5jbHVzaXZlLlxyXG4gKiBybT8ge251bWJlcn0gUm91bmRpbmcgbW9kZTogMCAoZG93biksIDEgKGhhbGYtdXApLCAyIChoYWxmLWV2ZW4pIG9yIDMgKHVwKS5cclxuICovXHJcblAucm91bmQgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgaWYgKGRwID09PSBVTkRFRklORUQpIGRwID0gMDtcclxuICBlbHNlIGlmIChkcCAhPT0gfn5kcCB8fCBkcCA8IC1NQVhfRFAgfHwgZHAgPiBNQVhfRFApIHtcclxuICAgIHRocm93IEVycm9yKElOVkFMSURfRFApO1xyXG4gIH1cclxuICByZXR1cm4gcm91bmQobmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyksIGRwICsgdGhpcy5lICsgMSwgcm0pO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBCaWcgd2hvc2UgdmFsdWUgaXMgdGhlIHNxdWFyZSByb290IG9mIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZywgcm91bmRlZCwgaWZcclxuICogbmVjZXNzYXJ5LCB0byBhIG1heGltdW0gb2YgQmlnLkRQIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgQmlnLlJNLlxyXG4gKi9cclxuUC5zcXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciByLCBjLCB0LFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICBCaWcgPSB4LmNvbnN0cnVjdG9yLFxyXG4gICAgcyA9IHgucyxcclxuICAgIGUgPSB4LmUsXHJcbiAgICBoYWxmID0gbmV3IEJpZygnMC41Jyk7XHJcblxyXG4gIC8vIFplcm8/XHJcbiAgaWYgKCF4LmNbMF0pIHJldHVybiBuZXcgQmlnKHgpO1xyXG5cclxuICAvLyBOZWdhdGl2ZT9cclxuICBpZiAocyA8IDApIHtcclxuICAgIHRocm93IEVycm9yKE5BTUUgKyAnTm8gc3F1YXJlIHJvb3QnKTtcclxuICB9XHJcblxyXG4gIC8vIEVzdGltYXRlLlxyXG4gIHMgPSBNYXRoLnNxcnQoeCArICcnKTtcclxuXHJcbiAgLy8gTWF0aC5zcXJ0IHVuZGVyZmxvdy9vdmVyZmxvdz9cclxuICAvLyBSZS1lc3RpbWF0ZTogcGFzcyB4IGNvZWZmaWNpZW50IHRvIE1hdGguc3FydCBhcyBpbnRlZ2VyLCB0aGVuIGFkanVzdCB0aGUgcmVzdWx0IGV4cG9uZW50LlxyXG4gIGlmIChzID09PSAwIHx8IHMgPT09IDEgLyAwKSB7XHJcbiAgICBjID0geC5jLmpvaW4oJycpO1xyXG4gICAgaWYgKCEoYy5sZW5ndGggKyBlICYgMSkpIGMgKz0gJzAnO1xyXG4gICAgcyA9IE1hdGguc3FydChjKTtcclxuICAgIGUgPSAoKGUgKyAxKSAvIDIgfCAwKSAtIChlIDwgMCB8fCBlICYgMSk7XHJcbiAgICByID0gbmV3IEJpZygocyA9PSAxIC8gMCA/ICc1ZScgOiAocyA9IHMudG9FeHBvbmVudGlhbCgpKS5zbGljZSgwLCBzLmluZGV4T2YoJ2UnKSArIDEpKSArIGUpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByID0gbmV3IEJpZyhzICsgJycpO1xyXG4gIH1cclxuXHJcbiAgZSA9IHIuZSArIChCaWcuRFAgKz0gNCk7XHJcblxyXG4gIC8vIE5ld3Rvbi1SYXBoc29uIGl0ZXJhdGlvbi5cclxuICBkbyB7XHJcbiAgICB0ID0gcjtcclxuICAgIHIgPSBoYWxmLnRpbWVzKHQucGx1cyh4LmRpdih0KSkpO1xyXG4gIH0gd2hpbGUgKHQuYy5zbGljZSgwLCBlKS5qb2luKCcnKSAhPT0gci5jLnNsaWNlKDAsIGUpLmpvaW4oJycpKTtcclxuXHJcbiAgcmV0dXJuIHJvdW5kKHIsIChCaWcuRFAgLT0gNCkgKyByLmUgKyAxLCBCaWcuUk0pO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBCaWcgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIHRpbWVzIHRoZSB2YWx1ZSBvZiBCaWcgeS5cclxuICovXHJcblAudGltZXMgPSBQLm11bCA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgdmFyIGMsXHJcbiAgICB4ID0gdGhpcyxcclxuICAgIEJpZyA9IHguY29uc3RydWN0b3IsXHJcbiAgICB4YyA9IHguYyxcclxuICAgIHljID0gKHkgPSBuZXcgQmlnKHkpKS5jLFxyXG4gICAgYSA9IHhjLmxlbmd0aCxcclxuICAgIGIgPSB5Yy5sZW5ndGgsXHJcbiAgICBpID0geC5lLFxyXG4gICAgaiA9IHkuZTtcclxuXHJcbiAgLy8gRGV0ZXJtaW5lIHNpZ24gb2YgcmVzdWx0LlxyXG4gIHkucyA9IHgucyA9PSB5LnMgPyAxIDogLTE7XHJcblxyXG4gIC8vIFJldHVybiBzaWduZWQgMCBpZiBlaXRoZXIgMC5cclxuICBpZiAoIXhjWzBdIHx8ICF5Y1swXSkge1xyXG4gICAgeS5jID0gW3kuZSA9IDBdO1xyXG4gICAgcmV0dXJuIHk7XHJcbiAgfVxyXG5cclxuICAvLyBJbml0aWFsaXNlIGV4cG9uZW50IG9mIHJlc3VsdCBhcyB4LmUgKyB5LmUuXHJcbiAgeS5lID0gaSArIGo7XHJcblxyXG4gIC8vIElmIGFycmF5IHhjIGhhcyBmZXdlciBkaWdpdHMgdGhhbiB5Yywgc3dhcCB4YyBhbmQgeWMsIGFuZCBsZW5ndGhzLlxyXG4gIGlmIChhIDwgYikge1xyXG4gICAgYyA9IHhjO1xyXG4gICAgeGMgPSB5YztcclxuICAgIHljID0gYztcclxuICAgIGogPSBhO1xyXG4gICAgYSA9IGI7XHJcbiAgICBiID0gajtcclxuICB9XHJcblxyXG4gIC8vIEluaXRpYWxpc2UgY29lZmZpY2llbnQgYXJyYXkgb2YgcmVzdWx0IHdpdGggemVyb3MuXHJcbiAgZm9yIChjID0gbmV3IEFycmF5KGogPSBhICsgYik7IGotLTspIGNbal0gPSAwO1xyXG5cclxuICAvLyBNdWx0aXBseS5cclxuXHJcbiAgLy8gaSBpcyBpbml0aWFsbHkgeGMubGVuZ3RoLlxyXG4gIGZvciAoaSA9IGI7IGktLTspIHtcclxuICAgIGIgPSAwO1xyXG5cclxuICAgIC8vIGEgaXMgeWMubGVuZ3RoLlxyXG4gICAgZm9yIChqID0gYSArIGk7IGogPiBpOykge1xyXG5cclxuICAgICAgLy8gQ3VycmVudCBzdW0gb2YgcHJvZHVjdHMgYXQgdGhpcyBkaWdpdCBwb3NpdGlvbiwgcGx1cyBjYXJyeS5cclxuICAgICAgYiA9IGNbal0gKyB5Y1tpXSAqIHhjW2ogLSBpIC0gMV0gKyBiO1xyXG4gICAgICBjW2otLV0gPSBiICUgMTA7XHJcblxyXG4gICAgICAvLyBjYXJyeVxyXG4gICAgICBiID0gYiAvIDEwIHwgMDtcclxuICAgIH1cclxuXHJcbiAgICBjW2pdID0gYjtcclxuICB9XHJcblxyXG4gIC8vIEluY3JlbWVudCByZXN1bHQgZXhwb25lbnQgaWYgdGhlcmUgaXMgYSBmaW5hbCBjYXJyeSwgb3RoZXJ3aXNlIHJlbW92ZSBsZWFkaW5nIHplcm8uXHJcbiAgaWYgKGIpICsreS5lO1xyXG4gIGVsc2UgYy5zaGlmdCgpO1xyXG5cclxuICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgZm9yIChpID0gYy5sZW5ndGg7ICFjWy0taV07KSBjLnBvcCgpO1xyXG4gIHkuYyA9IGM7XHJcblxyXG4gIHJldHVybiB5O1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIGluIGV4cG9uZW50aWFsIG5vdGF0aW9uIHJvdW5kZWQgdG8gZHAgZml4ZWRcclxuICogZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3IgQmlnLlJNIGlmIHJtIGlzIG5vdCBzcGVjaWZpZWQuXHJcbiAqXHJcbiAqIGRwPyB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlczogaW50ZWdlciwgMCB0byBNQVhfRFAgaW5jbHVzaXZlLlxyXG4gKiBybT8ge251bWJlcn0gUm91bmRpbmcgbW9kZTogMCAoZG93biksIDEgKGhhbGYtdXApLCAyIChoYWxmLWV2ZW4pIG9yIDMgKHVwKS5cclxuICovXHJcblAudG9FeHBvbmVudGlhbCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICB2YXIgeCA9IHRoaXMsXHJcbiAgICBuID0geC5jWzBdO1xyXG5cclxuICBpZiAoZHAgIT09IFVOREVGSU5FRCkge1xyXG4gICAgaWYgKGRwICE9PSB+fmRwIHx8IGRwIDwgMCB8fCBkcCA+IE1BWF9EUCkge1xyXG4gICAgICB0aHJvdyBFcnJvcihJTlZBTElEX0RQKTtcclxuICAgIH1cclxuICAgIHggPSByb3VuZChuZXcgeC5jb25zdHJ1Y3Rvcih4KSwgKytkcCwgcm0pO1xyXG4gICAgZm9yICg7IHguYy5sZW5ndGggPCBkcDspIHguYy5wdXNoKDApO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHN0cmluZ2lmeSh4LCB0cnVlLCAhIW4pO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIGluIG5vcm1hbCBub3RhdGlvbiByb3VuZGVkIHRvIGRwIGZpeGVkXHJcbiAqIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yIEJpZy5STSBpZiBybSBpcyBub3Qgc3BlY2lmaWVkLlxyXG4gKlxyXG4gKiBkcD8ge251bWJlcn0gRGVjaW1hbCBwbGFjZXM6IGludGVnZXIsIDAgdG8gTUFYX0RQIGluY2x1c2l2ZS5cclxuICogcm0/IHtudW1iZXJ9IFJvdW5kaW5nIG1vZGU6IDAgKGRvd24pLCAxIChoYWxmLXVwKSwgMiAoaGFsZi1ldmVuKSBvciAzICh1cCkuXHJcbiAqXHJcbiAqICgtMCkudG9GaXhlZCgwKSBpcyAnMCcsIGJ1dCAoLTAuMSkudG9GaXhlZCgwKSBpcyAnLTAnLlxyXG4gKiAoLTApLnRvRml4ZWQoMSkgaXMgJzAuMCcsIGJ1dCAoLTAuMDEpLnRvRml4ZWQoMSkgaXMgJy0wLjAnLlxyXG4gKi9cclxuUC50b0ZpeGVkID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gIHZhciB4ID0gdGhpcyxcclxuICAgIG4gPSB4LmNbMF07XHJcblxyXG4gIGlmIChkcCAhPT0gVU5ERUZJTkVEKSB7XHJcbiAgICBpZiAoZHAgIT09IH5+ZHAgfHwgZHAgPCAwIHx8IGRwID4gTUFYX0RQKSB7XHJcbiAgICAgIHRocm93IEVycm9yKElOVkFMSURfRFApO1xyXG4gICAgfVxyXG4gICAgeCA9IHJvdW5kKG5ldyB4LmNvbnN0cnVjdG9yKHgpLCBkcCArIHguZSArIDEsIHJtKTtcclxuXHJcbiAgICAvLyB4LmUgbWF5IGhhdmUgY2hhbmdlZCBpZiB0aGUgdmFsdWUgaXMgcm91bmRlZCB1cC5cclxuICAgIGZvciAoZHAgPSBkcCArIHguZSArIDE7IHguYy5sZW5ndGggPCBkcDspIHguYy5wdXNoKDApO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHN0cmluZ2lmeSh4LCBmYWxzZSwgISFuKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZy5cclxuICogUmV0dXJuIGV4cG9uZW50aWFsIG5vdGF0aW9uIGlmIHRoaXMgQmlnIGhhcyBhIHBvc2l0aXZlIGV4cG9uZW50IGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhblxyXG4gKiBCaWcuUEUsIG9yIGEgbmVnYXRpdmUgZXhwb25lbnQgZXF1YWwgdG8gb3IgbGVzcyB0aGFuIEJpZy5ORS5cclxuICogT21pdCB0aGUgc2lnbiBmb3IgbmVnYXRpdmUgemVyby5cclxuICovXHJcblBbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0gPSBQLnRvSlNPTiA9IFAudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHggPSB0aGlzLFxyXG4gICAgQmlnID0geC5jb25zdHJ1Y3RvcjtcclxuICByZXR1cm4gc3RyaW5naWZ5KHgsIHguZSA8PSBCaWcuTkUgfHwgeC5lID49IEJpZy5QRSwgISF4LmNbMF0pO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgYXMgYSBwcmltaXR2ZSBudW1iZXIuXHJcbiAqL1xyXG5QLnRvTnVtYmVyID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBuID0gTnVtYmVyKHN0cmluZ2lmeSh0aGlzLCB0cnVlLCB0cnVlKSk7XHJcbiAgaWYgKHRoaXMuY29uc3RydWN0b3Iuc3RyaWN0ID09PSB0cnVlICYmICF0aGlzLmVxKG4udG9TdHJpbmcoKSkpIHtcclxuICAgIHRocm93IEVycm9yKE5BTUUgKyAnSW1wcmVjaXNlIGNvbnZlcnNpb24nKTtcclxuICB9XHJcbiAgcmV0dXJuIG47XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgcm91bmRlZCB0byBzZCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmdcclxuICogcm91bmRpbmcgbW9kZSBybSwgb3IgQmlnLlJNIGlmIHJtIGlzIG5vdCBzcGVjaWZpZWQuXHJcbiAqIFVzZSBleHBvbmVudGlhbCBub3RhdGlvbiBpZiBzZCBpcyBsZXNzIHRoYW4gdGhlIG51bWJlciBvZiBkaWdpdHMgbmVjZXNzYXJ5IHRvIHJlcHJlc2VudFxyXG4gKiB0aGUgaW50ZWdlciBwYXJ0IG9mIHRoZSB2YWx1ZSBpbiBub3JtYWwgbm90YXRpb24uXHJcbiAqXHJcbiAqIHNkIHtudW1iZXJ9IFNpZ25pZmljYW50IGRpZ2l0czogaW50ZWdlciwgMSB0byBNQVhfRFAgaW5jbHVzaXZlLlxyXG4gKiBybT8ge251bWJlcn0gUm91bmRpbmcgbW9kZTogMCAoZG93biksIDEgKGhhbGYtdXApLCAyIChoYWxmLWV2ZW4pIG9yIDMgKHVwKS5cclxuICovXHJcblAudG9QcmVjaXNpb24gPSBmdW5jdGlvbiAoc2QsIHJtKSB7XHJcbiAgdmFyIHggPSB0aGlzLFxyXG4gICAgQmlnID0geC5jb25zdHJ1Y3RvcixcclxuICAgIG4gPSB4LmNbMF07XHJcblxyXG4gIGlmIChzZCAhPT0gVU5ERUZJTkVEKSB7XHJcbiAgICBpZiAoc2QgIT09IH5+c2QgfHwgc2QgPCAxIHx8IHNkID4gTUFYX0RQKSB7XHJcbiAgICAgIHRocm93IEVycm9yKElOVkFMSUQgKyAncHJlY2lzaW9uJyk7XHJcbiAgICB9XHJcbiAgICB4ID0gcm91bmQobmV3IEJpZyh4KSwgc2QsIHJtKTtcclxuICAgIGZvciAoOyB4LmMubGVuZ3RoIDwgc2Q7KSB4LmMucHVzaCgwKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBzdHJpbmdpZnkoeCwgc2QgPD0geC5lIHx8IHguZSA8PSBCaWcuTkUgfHwgeC5lID49IEJpZy5QRSwgISFuKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZy5cclxuICogUmV0dXJuIGV4cG9uZW50aWFsIG5vdGF0aW9uIGlmIHRoaXMgQmlnIGhhcyBhIHBvc2l0aXZlIGV4cG9uZW50IGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhblxyXG4gKiBCaWcuUEUsIG9yIGEgbmVnYXRpdmUgZXhwb25lbnQgZXF1YWwgdG8gb3IgbGVzcyB0aGFuIEJpZy5ORS5cclxuICogSW5jbHVkZSB0aGUgc2lnbiBmb3IgbmVnYXRpdmUgemVyby5cclxuICovXHJcblAudmFsdWVPZiA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgeCA9IHRoaXMsXHJcbiAgICBCaWcgPSB4LmNvbnN0cnVjdG9yO1xyXG4gIGlmIChCaWcuc3RyaWN0ID09PSB0cnVlKSB7XHJcbiAgICB0aHJvdyBFcnJvcihOQU1FICsgJ3ZhbHVlT2YgZGlzYWxsb3dlZCcpO1xyXG4gIH1cclxuICByZXR1cm4gc3RyaW5naWZ5KHgsIHguZSA8PSBCaWcuTkUgfHwgeC5lID49IEJpZy5QRSwgdHJ1ZSk7XHJcbn07XHJcblxyXG5cclxuLy8gRXhwb3J0XHJcblxyXG5cclxuZXhwb3J0IHZhciBCaWcgPSBfQmlnXygpO1xyXG5cclxuLy8vIDxyZWZlcmVuY2UgdHlwZXM9XCJodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vRGVmaW5pdGVseVR5cGVkL0RlZmluaXRlbHlUeXBlZC9tYXN0ZXIvdHlwZXMvYmlnLmpzL2luZGV4LmQudHNcIiAvPlxyXG5leHBvcnQgZGVmYXVsdCBCaWc7XHJcbiJdLCJuYW1lcyI6WyJEUCIsIlJNIiwiTUFYX0RQIiwiTUFYX1BPV0VSIiwiTkUiLCJQRSIsIlNUUklDVCIsIk5BTUUiLCJJTlZBTElEIiwiSU5WQUxJRF9EUCIsIklOVkFMSURfUk0iLCJESVZfQllfWkVSTyIsIlAiLCJVTkRFRklORUQiLCJOVU1FUklDIiwiX0JpZ18iLCJCaWciLCJuIiwieCIsInMiLCJlIiwiYyIsInNsaWNlIiwic3RyaWN0IiwiVHlwZUVycm9yIiwiU3RyaW5nIiwicGFyc2UiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsInJvdW5kRG93biIsInJvdW5kSGFsZlVwIiwicm91bmRIYWxmRXZlbiIsInJvdW5kVXAiLCJpIiwibmwiLCJ0ZXN0IiwiRXJyb3IiLCJjaGFyQXQiLCJpbmRleE9mIiwicmVwbGFjZSIsInNlYXJjaCIsInN1YnN0cmluZyIsImxlbmd0aCIsInJvdW5kIiwic2QiLCJybSIsIm1vcmUiLCJ4YyIsInVuc2hpZnQiLCJwb3AiLCJzdHJpbmdpZnkiLCJkb0V4cG9uZW50aWFsIiwiaXNOb256ZXJvIiwiam9pbiIsImFicyIsImNtcCIsInkiLCJpc25lZyIsInljIiwiaiIsImsiLCJsIiwiZGl2IiwiYSIsImIiLCJkcCIsImJsIiwiYnQiLCJyaSIsImJ6IiwiYWkiLCJhbCIsInIiLCJybCIsInEiLCJxYyIsInFpIiwicCIsInB1c2giLCJzaGlmdCIsImVxIiwiZ3QiLCJndGUiLCJsdCIsImx0ZSIsIm1pbnVzIiwic3ViIiwidCIsInhsdHkiLCJwbHVzIiwieGUiLCJ5ZSIsInJldmVyc2UiLCJtb2QiLCJ5Z3R4IiwidGltZXMiLCJuZWciLCJhZGQiLCJwb3ciLCJvbmUiLCJwcmVjIiwic3FydCIsImhhbGYiLCJNYXRoIiwidG9FeHBvbmVudGlhbCIsIm11bCIsIkFycmF5IiwidG9GaXhlZCIsIlN5bWJvbCIsImZvciIsInRvSlNPTiIsInRvU3RyaW5nIiwidG9OdW1iZXIiLCJOdW1iZXIiLCJ0b1ByZWNpc2lvbiIsInZhbHVlT2YiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/big.js@6.2.1/node_modules/big.js/big.mjs\n");

/***/ })

};
;